<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--
        This file is autogenerated from html/libvirt-libvirt.html.in
        Do not edit this file. Changes will be lost.
      --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><link rel="stylesheet" type="text/css" href="../main.css" /><link rel="SHORTCUT ICON" href="../32favicon.png" /><title>libvirt: Module libvirt from libvirt</title><meta name="description" content="libvirt, virtualization, virtualization API" /></head><body><div id="header"><div id="headerLogo"></div><div id="headerSearch"><form action="../search.php" enctype="application/x-www-form-urlencoded" method="get"><div><input id="query" name="query" type="text" size="12" value="" /><input id="submit" name="submit" type="submit" value="Search" /></div></form></div></div><div id="body"><div id="menu"><ul class="l0"><li><div><a title="Front page of the libvirt website" class="inactive" href="../index.html">Home</a></div></li><li><div><a title="Details of new features and bugs fixed in each release" class="inactive" href="../news.html">News</a></div></li><li><div><a title="Applications known to use libvirt" class="inactive" href="../apps.html">Applications</a></div></li><li><div><a title="Get the latest source releases, binary builds and get access to the source repository" class="inactive" href="../downloads.html">Downloads</a></div></li><li><div><a title="Information for users, administrators and developers" class="active" href="../docs.html">Documentation</a><ul class="l1"><li><div><a title="How to compile libvirt" class="inactive" href="../compiling.html">Compiling</a></div></li><li><div><a title="Information about deploying and using libvirt" class="inactive" href="../deployment.html">Deployment</a></div></li><li><div><a title="Overview of the logical subsystems in the libvirt API" class="inactive" href="../intro.html">Architecture</a></div></li><li><div><a title="Description of the XML formats used in libvirt" class="inactive" href="../format.html">XML format</a></div></li><li><div><a title="Hypervisor specific driver information" class="inactive" href="../drivers.html">Drivers</a></div></li><li><div><a title="Reference manual for the C public API" class="active" href="../html/index.html">API reference</a><ul class="l2"><li><div><span class="active">libvirt</span></div></li><li><div><a title="error handling interfaces for the libvirt library" class="inactive" href="../html/libvirt-virterror.html">virterror</a></div></li><li><div><a title="matrix of API support per hypervisor per release" class="inactive" href="../hvsupport.html">Driver support</a></div></li></ul></div></li><li><div><a title="Bindings of the libvirt API for other languages" class="inactive" href="../bindings.html">Language bindings</a></div></li><li><div><a title="Working on the internals of libvirt API, driver and daemon code" class="inactive" href="../internals.html">Internals</a></div></li><li><div><a title="A guide and reference for developing with libvirt" class="inactive" href="../devguide.html">Development Guide</a></div></li><li><div><a title="Command reference for virsh" class="inactive" href="../virshcmdref.html">Virsh Commands</a></div></li></ul></div></li><li><div><a title="User contributed content" class="inactive" href="http://wiki.libvirt.org">Wiki</a></div></li><li><div><a title="Frequently asked questions" class="inactive" href="../http://wiki.libvirt.org/page/FAQ">FAQ</a></div></li><li><div><a title="How and where to report bugs and request features" class="inactive" href="../bugs.html">Bug reports</a></div></li><li><div><a title="How to contact the developers via email and IRC" class="inactive" href="../contact.html">Contact</a></div></li><li><div><a title="Miscellaneous links of interest related to libvirt" class="inactive" href="../relatedlinks.html">Related Links</a></div></li><li><div><a title="Overview of all content on the website" class="inactive" href="../sitemap.html">Sitemap</a></div></li></ul></div><div id="content"><h1>Module libvirt from libvirt</h1><p>Provides the interfaces of the libvirt library to handle virtualized domains </p><h2>Table of Contents</h2><h3><a href="#macros">Macros</a></h3><pre>#define <a href="#LIBVIR_VERSION_NUMBER">LIBVIR_VERSION_NUMBER</a>
#define <a href="#VIR_COPY_CPUMAP">VIR_COPY_CPUMAP</a>
#define <a href="#VIR_CPU_MAPLEN">VIR_CPU_MAPLEN</a>
#define <a href="#VIR_CPU_USABLE">VIR_CPU_USABLE</a>
#define <a href="#VIR_DOMAIN_EVENT_CALLBACK">VIR_DOMAIN_EVENT_CALLBACK</a>
#define <a href="#VIR_DOMAIN_MEMORY_FIELD_LENGTH">VIR_DOMAIN_MEMORY_FIELD_LENGTH</a>
#define <a href="#VIR_DOMAIN_MEMORY_HARD_LIMIT">VIR_DOMAIN_MEMORY_HARD_LIMIT</a>
#define <a href="#VIR_DOMAIN_MEMORY_MIN_GUARANTEE">VIR_DOMAIN_MEMORY_MIN_GUARANTEE</a>
#define <a href="#VIR_DOMAIN_MEMORY_PARAM_UNLIMITED">VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</a>
#define <a href="#VIR_DOMAIN_MEMORY_SOFT_LIMIT">VIR_DOMAIN_MEMORY_SOFT_LIMIT</a>
#define <a href="#VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT">VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</a>
#define <a href="#VIR_DOMAIN_SCHED_FIELD_LENGTH">VIR_DOMAIN_SCHED_FIELD_LENGTH</a>
#define <a href="#VIR_GET_CPUMAP">VIR_GET_CPUMAP</a>
#define <a href="#VIR_NODEINFO_MAXCPUS">VIR_NODEINFO_MAXCPUS</a>
#define <a href="#VIR_SECURITY_DOI_BUFLEN">VIR_SECURITY_DOI_BUFLEN</a>
#define <a href="#VIR_SECURITY_LABEL_BUFLEN">VIR_SECURITY_LABEL_BUFLEN</a>
#define <a href="#VIR_SECURITY_MODEL_BUFLEN">VIR_SECURITY_MODEL_BUFLEN</a>
#define <a href="#VIR_UNUSE_CPU">VIR_UNUSE_CPU</a>
#define <a href="#VIR_USE_CPU">VIR_USE_CPU</a>
#define <a href="#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a>
#define <a href="#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a>
</pre><h3><a href="#types">Types</a></h3><pre>typedef enum <a href="#virCPUCompareResult">virCPUCompareResult</a>
typedef struct _virConnect <a href="#virConnect">virConnect</a>
typedef struct _virConnectAuth <a href="#virConnectAuth">virConnectAuth</a>
typedef <a href="libvirt-libvirt.html#virConnectAuth">virConnectAuth</a> * <a name="virConnectAuthPtr" id="virConnectAuthPtr">virConnectAuthPtr</a>
typedef struct _virConnectCredential <a href="#virConnectCredential">virConnectCredential</a>
typedef <a href="libvirt-libvirt.html#virConnectCredential">virConnectCredential</a> * <a name="virConnectCredentialPtr" id="virConnectCredentialPtr">virConnectCredentialPtr</a>
typedef enum <a href="#virConnectCredentialType">virConnectCredentialType</a>
typedef enum <a href="#virConnectFlags">virConnectFlags</a>
typedef <a href="libvirt-libvirt.html#virConnect">virConnect</a> * <a name="virConnectPtr" id="virConnectPtr">virConnectPtr</a>
typedef struct _virDomain <a href="#virDomain">virDomain</a>
typedef struct _virDomainBlockInfo <a href="#virDomainBlockInfo">virDomainBlockInfo</a>
typedef <a href="libvirt-libvirt.html#virDomainBlockInfo">virDomainBlockInfo</a> * <a name="virDomainBlockInfoPtr" id="virDomainBlockInfoPtr">virDomainBlockInfoPtr</a>
typedef <a href="libvirt-libvirt.html#virDomainBlockStatsStruct">virDomainBlockStatsStruct</a> * <a name="virDomainBlockStatsPtr" id="virDomainBlockStatsPtr">virDomainBlockStatsPtr</a>
typedef struct _virDomainBlockStats <a href="#virDomainBlockStatsStruct">virDomainBlockStatsStruct</a>
typedef enum <a href="#virDomainCoreDumpFlags">virDomainCoreDumpFlags</a>
typedef enum <a href="#virDomainCreateFlags">virDomainCreateFlags</a>
typedef enum <a href="#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a>
typedef enum <a href="#virDomainEventDefinedDetailType">virDomainEventDefinedDetailType</a>
typedef struct _virDomainEventGraphicsAddress <a href="#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a>
typedef <a href="libvirt-libvirt.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * <a name="virDomainEventGraphicsAddressPtr" id="virDomainEventGraphicsAddressPtr">virDomainEventGraphicsAddressPtr</a>
typedef enum <a href="#virDomainEventGraphicsAddressType">virDomainEventGraphicsAddressType</a>
typedef enum <a href="#virDomainEventGraphicsPhase">virDomainEventGraphicsPhase</a>
typedef struct _virDomainEventGraphicsSubject <a href="#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a>
typedef struct _virDomainEventGraphicsSubjectIdentity <a href="#virDomainEventGraphicsSubjectIdentity">virDomainEventGraphicsSubjectIdentity</a>
typedef <a href="libvirt-libvirt.html#virDomainEventGraphicsSubjectIdentity">virDomainEventGraphicsSubjectIdentity</a> * <a name="virDomainEventGraphicsSubjectIdentityPtr" id="virDomainEventGraphicsSubjectIdentityPtr">virDomainEventGraphicsSubjectIdentityPtr</a>
typedef <a href="libvirt-libvirt.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> * <a name="virDomainEventGraphicsSubjectPtr" id="virDomainEventGraphicsSubjectPtr">virDomainEventGraphicsSubjectPtr</a>
typedef enum <a href="#virDomainEventID">virDomainEventID</a>
typedef enum <a href="#virDomainEventIOErrorAction">virDomainEventIOErrorAction</a>
typedef enum <a href="#virDomainEventResumedDetailType">virDomainEventResumedDetailType</a>
typedef enum <a href="#virDomainEventStartedDetailType">virDomainEventStartedDetailType</a>
typedef enum <a href="#virDomainEventStoppedDetailType">virDomainEventStoppedDetailType</a>
typedef enum <a href="#virDomainEventSuspendedDetailType">virDomainEventSuspendedDetailType</a>
typedef enum <a href="#virDomainEventType">virDomainEventType</a>
typedef enum <a href="#virDomainEventUndefinedDetailType">virDomainEventUndefinedDetailType</a>
typedef enum <a href="#virDomainEventWatchdogAction">virDomainEventWatchdogAction</a>
typedef struct _virDomainInfo <a href="#virDomainInfo">virDomainInfo</a>
typedef <a href="libvirt-libvirt.html#virDomainInfo">virDomainInfo</a> * <a name="virDomainInfoPtr" id="virDomainInfoPtr">virDomainInfoPtr</a>
typedef <a href="libvirt-libvirt.html#virDomainInterfaceStatsStruct">virDomainInterfaceStatsStruct</a> * <a name="virDomainInterfaceStatsPtr" id="virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a>
typedef struct _virDomainInterfaceStats <a href="#virDomainInterfaceStatsStruct">virDomainInterfaceStatsStruct</a>
typedef struct _virDomainJobInfo <a href="#virDomainJobInfo">virDomainJobInfo</a>
typedef <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a> * <a name="virDomainJobInfoPtr" id="virDomainJobInfoPtr">virDomainJobInfoPtr</a>
typedef enum <a href="#virDomainJobType">virDomainJobType</a>
typedef enum <a href="#virDomainMemoryFlags">virDomainMemoryFlags</a>
typedef <a href="libvirt-libvirt.html#virDomainMemoryStatStruct">virDomainMemoryStatStruct</a> * <a name="virDomainMemoryStatPtr" id="virDomainMemoryStatPtr">virDomainMemoryStatPtr</a>
typedef struct _virDomainMemoryStat <a href="#virDomainMemoryStatStruct">virDomainMemoryStatStruct</a>
typedef enum <a href="#virDomainMemoryStatTags">virDomainMemoryStatTags</a>
typedef enum <a href="#virDomainMigrateFlags">virDomainMigrateFlags</a>
typedef <a href="libvirt-libvirt.html#virDomain">virDomain</a> * <a name="virDomainPtr" id="virDomainPtr">virDomainPtr</a>
typedef struct _virDomainSnapshot <a href="#virDomainSnapshot">virDomainSnapshot</a>
typedef enum <a href="#virDomainSnapshotDeleteFlags">virDomainSnapshotDeleteFlags</a>
typedef <a href="libvirt-libvirt.html#virDomainSnapshot">virDomainSnapshot</a> * <a name="virDomainSnapshotPtr" id="virDomainSnapshotPtr">virDomainSnapshotPtr</a>
typedef enum <a href="#virDomainState">virDomainState</a>
typedef enum <a href="#virDomainVcpuFlags">virDomainVcpuFlags</a>
typedef enum <a href="#virDomainXMLFlags">virDomainXMLFlags</a>
typedef enum <a href="#virEventHandleType">virEventHandleType</a>
typedef struct _virInterface <a href="#virInterface">virInterface</a>
typedef <a href="libvirt-libvirt.html#virInterface">virInterface</a> * <a name="virInterfacePtr" id="virInterfacePtr">virInterfacePtr</a>
typedef enum <a href="#virInterfaceXMLFlags">virInterfaceXMLFlags</a>
typedef struct _virMemoryParameter <a href="#virMemoryParameter">virMemoryParameter</a>
typedef <a href="libvirt-libvirt.html#virMemoryParameter">virMemoryParameter</a> * <a name="virMemoryParameterPtr" id="virMemoryParameterPtr">virMemoryParameterPtr</a>
typedef enum <a href="#virMemoryParameterType">virMemoryParameterType</a>
typedef struct _virNWFilter <a href="#virNWFilter">virNWFilter</a>
typedef <a href="libvirt-libvirt.html#virNWFilter">virNWFilter</a> * <a name="virNWFilterPtr" id="virNWFilterPtr">virNWFilterPtr</a>
typedef struct _virNetwork <a href="#virNetwork">virNetwork</a>
typedef <a href="libvirt-libvirt.html#virNetwork">virNetwork</a> * <a name="virNetworkPtr" id="virNetworkPtr">virNetworkPtr</a>
typedef struct _virNodeDevice <a href="#virNodeDevice">virNodeDevice</a>
typedef <a href="libvirt-libvirt.html#virNodeDevice">virNodeDevice</a> * <a name="virNodeDevicePtr" id="virNodeDevicePtr">virNodeDevicePtr</a>
typedef struct _virNodeInfo <a href="#virNodeInfo">virNodeInfo</a>
typedef <a href="libvirt-libvirt.html#virNodeInfo">virNodeInfo</a> * <a name="virNodeInfoPtr" id="virNodeInfoPtr">virNodeInfoPtr</a>
typedef struct _virSchedParameter <a href="#virSchedParameter">virSchedParameter</a>
typedef <a href="libvirt-libvirt.html#virSchedParameter">virSchedParameter</a> * <a name="virSchedParameterPtr" id="virSchedParameterPtr">virSchedParameterPtr</a>
typedef enum <a href="#virSchedParameterType">virSchedParameterType</a>
typedef struct _virSecret <a href="#virSecret">virSecret</a>
typedef <a href="libvirt-libvirt.html#virSecret">virSecret</a> * <a name="virSecretPtr" id="virSecretPtr">virSecretPtr</a>
typedef enum <a href="#virSecretUsageType">virSecretUsageType</a>
typedef struct _virSecurityLabel <a href="#virSecurityLabel">virSecurityLabel</a>
typedef <a href="libvirt-libvirt.html#virSecurityLabel">virSecurityLabel</a> * <a name="virSecurityLabelPtr" id="virSecurityLabelPtr">virSecurityLabelPtr</a>
typedef struct _virSecurityModel <a href="#virSecurityModel">virSecurityModel</a>
typedef <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> * <a name="virSecurityModelPtr" id="virSecurityModelPtr">virSecurityModelPtr</a>
typedef struct _virStoragePool <a href="#virStoragePool">virStoragePool</a>
typedef enum <a href="#virStoragePoolBuildFlags">virStoragePoolBuildFlags</a>
typedef enum <a href="#virStoragePoolDeleteFlags">virStoragePoolDeleteFlags</a>
typedef struct _virStoragePoolInfo <a href="#virStoragePoolInfo">virStoragePoolInfo</a>
typedef <a href="libvirt-libvirt.html#virStoragePoolInfo">virStoragePoolInfo</a> * <a name="virStoragePoolInfoPtr" id="virStoragePoolInfoPtr">virStoragePoolInfoPtr</a>
typedef <a href="libvirt-libvirt.html#virStoragePool">virStoragePool</a> * <a name="virStoragePoolPtr" id="virStoragePoolPtr">virStoragePoolPtr</a>
typedef enum <a href="#virStoragePoolState">virStoragePoolState</a>
typedef struct _virStorageVol <a href="#virStorageVol">virStorageVol</a>
typedef enum <a href="#virStorageVolDeleteFlags">virStorageVolDeleteFlags</a>
typedef struct _virStorageVolInfo <a href="#virStorageVolInfo">virStorageVolInfo</a>
typedef <a href="libvirt-libvirt.html#virStorageVolInfo">virStorageVolInfo</a> * <a name="virStorageVolInfoPtr" id="virStorageVolInfoPtr">virStorageVolInfoPtr</a>
typedef <a href="libvirt-libvirt.html#virStorageVol">virStorageVol</a> * <a name="virStorageVolPtr" id="virStorageVolPtr">virStorageVolPtr</a>
typedef enum <a href="#virStorageVolType">virStorageVolType</a>
typedef struct _virStream <a href="#virStream">virStream</a>
typedef enum <a href="#virStreamEventType">virStreamEventType</a>
typedef enum <a href="#virStreamFlags">virStreamFlags</a>
typedef <a href="libvirt-libvirt.html#virStream">virStream</a> * <a name="virStreamPtr" id="virStreamPtr">virStreamPtr</a>
typedef struct _virVcpuInfo <a href="#virVcpuInfo">virVcpuInfo</a>
typedef <a href="libvirt-libvirt.html#virVcpuInfo">virVcpuInfo</a> * <a name="virVcpuInfoPtr" id="virVcpuInfoPtr">virVcpuInfoPtr</a>
typedef enum <a href="#virVcpuState">virVcpuState</a>
</pre><h3><a href="#functions">Functions</a></h3><pre>typedef <a href="#virConnectAuthCallbackPtr">virConnectAuthCallbackPtr</a>
int	<a href="#virConnectAuthCallbackPtr">virConnectAuthCallbackPtr</a>	(<a href="libvirt-libvirt.html#virConnectCredentialPtr">virConnectCredentialPtr</a> cred, <br />					 unsigned int ncred, <br />					 void * cbdata)

char *	<a href="#virConnectBaselineCPU">virConnectBaselineCPU</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char ** xmlCPUs, <br />					 unsigned int ncpus, <br />					 unsigned int flags)
int	<a href="#virConnectClose">virConnectClose</a>			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectCompareCPU">virConnectCompareCPU</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xmlDesc, <br />					 unsigned int flags)
typedef <a href="#virConnectDomainEventCallback">virConnectDomainEventCallback</a>
int	<a href="#virConnectDomainEventCallback">virConnectDomainEventCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 int event, <br />					 int detail, <br />					 void * opaque)

int	<a href="#virConnectDomainEventDeregister">virConnectDomainEventDeregister</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 <a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb)
int	<a href="#virConnectDomainEventDeregisterAny">virConnectDomainEventDeregisterAny</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 int callbackID)
typedef <a href="#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a>
void	<a href="#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 void * opaque)

typedef <a href="#virConnectDomainEventGraphicsCallback">virConnectDomainEventGraphicsCallback</a>
void	<a href="#virConnectDomainEventGraphicsCallback">virConnectDomainEventGraphicsCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 int phase, <br />						 <a href="libvirt-libvirt.html#virDomainEventGraphicsAddressPtr">virDomainEventGraphicsAddressPtr</a> local, <br />						 <a href="libvirt-libvirt.html#virDomainEventGraphicsAddressPtr">virDomainEventGraphicsAddressPtr</a> remote, <br />						 const char * authScheme, <br />						 <a href="libvirt-libvirt.html#virDomainEventGraphicsSubjectPtr">virDomainEventGraphicsSubjectPtr</a> subject, <br />						 void * opaque)

typedef <a href="#virConnectDomainEventIOErrorCallback">virConnectDomainEventIOErrorCallback</a>
void	<a href="#virConnectDomainEventIOErrorCallback">virConnectDomainEventIOErrorCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 const char * srcPath, <br />						 const char * devAlias, <br />						 int action, <br />						 void * opaque)

typedef <a href="#virConnectDomainEventIOErrorReasonCallback">virConnectDomainEventIOErrorReasonCallback</a>
void	<a href="#virConnectDomainEventIOErrorReasonCallback">virConnectDomainEventIOErrorReasonCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />							 const char * srcPath, <br />							 const char * devAlias, <br />							 int action, <br />							 const char * reason, <br />							 void * opaque)

typedef <a href="#virConnectDomainEventRTCChangeCallback">virConnectDomainEventRTCChangeCallback</a>
void	<a href="#virConnectDomainEventRTCChangeCallback">virConnectDomainEventRTCChangeCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 long long utcoffset, <br />						 void * opaque)

int	<a href="#virConnectDomainEventRegister">virConnectDomainEventRegister</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 <a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb, <br />					 void * opaque, <br />					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> freecb)
int	<a href="#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 int eventID, <br />						 <a href="libvirt-libvirt.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a> cb, <br />						 void * opaque, <br />						 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> freecb)
typedef <a href="#virConnectDomainEventWatchdogCallback">virConnectDomainEventWatchdogCallback</a>
void	<a href="#virConnectDomainEventWatchdogCallback">virConnectDomainEventWatchdogCallback</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 int action, <br />						 void * opaque)

char *	<a href="#virConnectDomainXMLFromNative">virConnectDomainXMLFromNative</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * nativeFormat, <br />					 const char * nativeConfig, <br />					 unsigned int flags)
char *	<a href="#virConnectDomainXMLToNative">virConnectDomainXMLToNative</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * nativeFormat, <br />					 const char * domainXml, <br />					 unsigned int flags)
char *	<a href="#virConnectFindStoragePoolSources">virConnectFindStoragePoolSources</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * type, <br />						 const char * srcSpec, <br />						 unsigned int flags)
char *	<a href="#virConnectGetCapabilities">virConnectGetCapabilities</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
char *	<a href="#virConnectGetHostname">virConnectGetHostname</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectGetLibVersion">virConnectGetLibVersion</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 unsigned long * libVer)
int	<a href="#virConnectGetMaxVcpus">virConnectGetMaxVcpus</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * type)
char *	<a href="#virConnectGetSysinfo">virConnectGetSysinfo</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 unsigned int flags)
const char *	<a href="#virConnectGetType">virConnectGetType</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
char *	<a href="#virConnectGetURI">virConnectGetURI</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectGetVersion">virConnectGetVersion</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 unsigned long * hvVer)
int	<a href="#virConnectIsEncrypted">virConnectIsEncrypted</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectIsSecure">virConnectIsSecure</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectListDefinedDomains">virConnectListDefinedDomains</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)
int	<a href="#virConnectListDefinedInterfaces">virConnectListDefinedInterfaces</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)
int	<a href="#virConnectListDefinedNetworks">virConnectListDefinedNetworks</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)
int	<a href="#virConnectListDefinedStoragePools">virConnectListDefinedStoragePools</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 char ** const names, <br />						 int maxnames)
int	<a href="#virConnectListDomains">virConnectListDomains</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 int * ids, <br />					 int maxids)
int	<a href="#virConnectListInterfaces">virConnectListInterfaces</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)
int	<a href="#virConnectListNWFilters">virConnectListNWFilters</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)
int	<a href="#virConnectListNetworks">virConnectListNetworks</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)
int	<a href="#virConnectListSecrets">virConnectListSecrets</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** uuids, <br />					 int maxuuids)
int	<a href="#virConnectListStoragePools">virConnectListStoragePools</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)
int	<a href="#virConnectNumOfDefinedDomains">virConnectNumOfDefinedDomains</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectNumOfDefinedInterfaces">virConnectNumOfDefinedInterfaces</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectNumOfDefinedNetworks">virConnectNumOfDefinedNetworks</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectNumOfDefinedStoragePools">virConnectNumOfDefinedStoragePools</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectNumOfDomains">virConnectNumOfDomains</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectNumOfInterfaces">virConnectNumOfInterfaces</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectNumOfNWFilters">virConnectNumOfNWFilters</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectNumOfNetworks">virConnectNumOfNetworks</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectNumOfSecrets">virConnectNumOfSecrets</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virConnectNumOfStoragePools">virConnectNumOfStoragePools</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virConnectOpen">virConnectOpen</a>		(const char * name)
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virConnectOpenAuth">virConnectOpenAuth</a>	(const char * name, <br />					 <a href="libvirt-libvirt.html#virConnectAuthPtr">virConnectAuthPtr</a> auth, <br />					 int flags)
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virConnectOpenReadOnly">virConnectOpenReadOnly</a>	(const char * name)
int	<a href="#virConnectRef">virConnectRef</a>			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virDomainAbortJob">virDomainAbortJob</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainAttachDevice">virDomainAttachDevice</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * xml)
int	<a href="#virDomainAttachDeviceFlags">virDomainAttachDeviceFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * xml, <br />					 unsigned int flags)
int	<a href="#virDomainBlockPeek">virDomainBlockPeek</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 const char * path, <br />					 unsigned long long offset, <br />					 size_t size, <br />					 void * buffer, <br />					 unsigned int flags)
int	<a href="#virDomainBlockStats">virDomainBlockStats</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 const char * path, <br />					 <a href="libvirt-libvirt.html#virDomainBlockStatsPtr">virDomainBlockStatsPtr</a> stats, <br />					 size_t size)
int	<a href="#virDomainCoreDump">virDomainCoreDump</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * to, <br />					 int flags)
int	<a href="#virDomainCreate">virDomainCreate</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainCreateLinux">virDomainCreateLinux</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xmlDesc, <br />					 unsigned int flags)
int	<a href="#virDomainCreateWithFlags">virDomainCreateWithFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int flags)
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainCreateXML">virDomainCreateXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xmlDesc, <br />					 unsigned int flags)
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainDefineXML">virDomainDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xml)
int	<a href="#virDomainDestroy">virDomainDestroy</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainDetachDevice">virDomainDetachDevice</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * xml)
int	<a href="#virDomainDetachDeviceFlags">virDomainDetachDeviceFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * xml, <br />					 unsigned int flags)
int	<a href="#virDomainFree">virDomainFree</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainGetAutostart">virDomainGetAutostart</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 int * autostart)
int	<a href="#virDomainGetBlockInfo">virDomainGetBlockInfo</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * path, <br />					 <a href="libvirt-libvirt.html#virDomainBlockInfoPtr">virDomainBlockInfoPtr</a> info, <br />					 unsigned int flags)
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virDomainGetConnect">virDomainGetConnect</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)
unsigned int	<a href="#virDomainGetID">virDomainGetID</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainGetInfo">virDomainGetInfo</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virDomainInfoPtr">virDomainInfoPtr</a> info)
int	<a href="#virDomainGetJobInfo">virDomainGetJobInfo</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virDomainJobInfoPtr">virDomainJobInfoPtr</a> info)
unsigned long	<a href="#virDomainGetMaxMemory">virDomainGetMaxMemory</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainGetMaxVcpus">virDomainGetMaxVcpus</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainGetMemoryParameters">virDomainGetMemoryParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virMemoryParameterPtr">virMemoryParameterPtr</a> params, <br />					 int * nparams, <br />					 unsigned int flags)
const char *	<a href="#virDomainGetName">virDomainGetName</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
char *	<a href="#virDomainGetOSType">virDomainGetOSType</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainGetSchedulerParameters">virDomainGetSchedulerParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virSchedParameterPtr">virSchedParameterPtr</a> params, <br />					 int * nparams)
char *	<a href="#virDomainGetSchedulerType">virDomainGetSchedulerType</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 int * nparams)
int	<a href="#virDomainGetSecurityLabel">virDomainGetSecurityLabel</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a> seclabel)
int	<a href="#virDomainGetUUID">virDomainGetUUID</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned char * uuid)
int	<a href="#virDomainGetUUIDString">virDomainGetUUIDString</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 char * buf)
int	<a href="#virDomainGetVcpus">virDomainGetVcpus</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virVcpuInfoPtr">virVcpuInfoPtr</a> info, <br />					 int maxinfo, <br />					 unsigned char * cpumaps, <br />					 int maplen)
int	<a href="#virDomainGetVcpusFlags">virDomainGetVcpusFlags</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int flags)
char *	<a href="#virDomainGetXMLDesc">virDomainGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 int flags)
int	<a href="#virDomainHasCurrentSnapshot">virDomainHasCurrentSnapshot</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int flags)
int	<a href="#virDomainHasManagedSaveImage">virDomainHasManagedSaveImage</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 unsigned int flags)
int	<a href="#virDomainInterfaceStats">virDomainInterfaceStats</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 const char * path, <br />					 <a href="libvirt-libvirt.html#virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a> stats, <br />					 size_t size)
int	<a href="#virDomainIsActive">virDomainIsActive</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)
int	<a href="#virDomainIsPersistent">virDomainIsPersistent</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)
int	<a href="#virDomainIsUpdated">virDomainIsUpdated</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByID">virDomainLookupByID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 int id)
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByName">virDomainLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * name)
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByUUID">virDomainLookupByUUID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const unsigned char * uuid)
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByUUIDString">virDomainLookupByUUIDString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * uuidstr)
int	<a href="#virDomainManagedSave">virDomainManagedSave</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 unsigned int flags)
int	<a href="#virDomainManagedSaveRemove">virDomainManagedSaveRemove</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 unsigned int flags)
int	<a href="#virDomainMemoryPeek">virDomainMemoryPeek</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 unsigned long long start, <br />					 size_t size, <br />					 void * buffer, <br />					 unsigned int flags)
int	<a href="#virDomainMemoryStats">virDomainMemoryStats</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 <a href="libvirt-libvirt.html#virDomainMemoryStatPtr">virDomainMemoryStatPtr</a> stats, <br />					 unsigned int nr_stats, <br />					 unsigned int flags)
<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainMigrate">virDomainMigrate</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> dconn, <br />					 unsigned long flags, <br />					 const char * dname, <br />					 const char * uri, <br />					 unsigned long bandwidth)
int	<a href="#virDomainMigrateSetMaxDowntime">virDomainMigrateSetMaxDowntime</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned long long downtime, <br />					 unsigned int flags)
int	<a href="#virDomainMigrateToURI">virDomainMigrateToURI</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * duri, <br />					 unsigned long flags, <br />					 const char * dname, <br />					 unsigned long bandwidth)
int	<a href="#virDomainOpenConsole">virDomainOpenConsole</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 const char * devname, <br />					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br />					 unsigned int flags)
int	<a href="#virDomainPinVcpu">virDomainPinVcpu</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int vcpu, <br />					 unsigned char * cpumap, <br />					 int maplen)
int	<a href="#virDomainReboot">virDomainReboot</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int flags)
int	<a href="#virDomainRef">virDomainRef</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainRestore">virDomainRestore</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * from)
int	<a href="#virDomainResume">virDomainResume</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainRevertToSnapshot">virDomainRevertToSnapshot</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br />					 unsigned int flags)
int	<a href="#virDomainSave">virDomainSave</a>			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * to)
int	<a href="#virDomainSetAutostart">virDomainSetAutostart</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 int autostart)
int	<a href="#virDomainSetMaxMemory">virDomainSetMaxMemory</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned long memory)
int	<a href="#virDomainSetMemory">virDomainSetMemory</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned long memory)
int	<a href="#virDomainSetMemoryParameters">virDomainSetMemoryParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virMemoryParameterPtr">virMemoryParameterPtr</a> params, <br />					 int nparams, <br />					 unsigned int flags)
int	<a href="#virDomainSetSchedulerParameters">virDomainSetSchedulerParameters</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virSchedParameterPtr">virSchedParameterPtr</a> params, <br />					 int nparams)
int	<a href="#virDomainSetVcpus">virDomainSetVcpus</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int nvcpus)
int	<a href="#virDomainSetVcpusFlags">virDomainSetVcpusFlags</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int nvcpus, <br />					 unsigned int flags)
int	<a href="#virDomainShutdown">virDomainShutdown</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	<a href="#virDomainSnapshotCreateXML">virDomainSnapshotCreateXML</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />							 const char * xmlDesc, <br />							 unsigned int flags)
<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	<a href="#virDomainSnapshotCurrent">virDomainSnapshotCurrent</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />							 unsigned int flags)
int	<a href="#virDomainSnapshotDelete">virDomainSnapshotDelete</a>		(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br />					 unsigned int flags)
int	<a href="#virDomainSnapshotFree">virDomainSnapshotFree</a>		(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot)
char *	<a href="#virDomainSnapshotGetXMLDesc">virDomainSnapshotGetXMLDesc</a>	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br />					 unsigned int flags)
int	<a href="#virDomainSnapshotListNames">virDomainSnapshotListNames</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 char ** names, <br />					 int nameslen, <br />					 unsigned int flags)
<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	<a href="#virDomainSnapshotLookupByName">virDomainSnapshotLookupByName</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />							 const char * name, <br />							 unsigned int flags)
int	<a href="#virDomainSnapshotNum">virDomainSnapshotNum</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int flags)
int	<a href="#virDomainSuspend">virDomainSuspend</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainUndefine">virDomainUndefine</a>		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)
int	<a href="#virDomainUpdateDeviceFlags">virDomainUpdateDeviceFlags</a>	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * xml, <br />					 unsigned int flags)
typedef <a href="#virEventAddHandleFunc">virEventAddHandleFunc</a>
int	<a href="#virEventAddHandleFunc">virEventAddHandleFunc</a>		(int fd, <br />					 int event, <br />					 <a href="libvirt-libvirt.html#virEventHandleCallback">virEventHandleCallback</a> cb, <br />					 void * opaque, <br />					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)

typedef <a href="#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a>
int	<a href="#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a>		(int timeout, <br />					 <a href="libvirt-libvirt.html#virEventTimeoutCallback">virEventTimeoutCallback</a> cb, <br />					 void * opaque, <br />					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)

typedef <a href="#virEventHandleCallback">virEventHandleCallback</a>
void	<a href="#virEventHandleCallback">virEventHandleCallback</a>		(int watch, <br />					 int fd, <br />					 int events, <br />					 void * opaque)

void	<a href="#virEventRegisterImpl">virEventRegisterImpl</a>		(<a href="libvirt-libvirt.html#virEventAddHandleFunc">virEventAddHandleFunc</a> addHandle, <br />					 <a href="libvirt-libvirt.html#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a> updateHandle, <br />					 <a href="libvirt-libvirt.html#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a> removeHandle, <br />					 <a href="libvirt-libvirt.html#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a> addTimeout, <br />					 <a href="libvirt-libvirt.html#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a> updateTimeout, <br />					 <a href="libvirt-libvirt.html#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a> removeTimeout)
typedef <a href="#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a>
int	<a href="#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a>	(int watch)

typedef <a href="#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a>
int	<a href="#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a>	(int timer)

typedef <a href="#virEventTimeoutCallback">virEventTimeoutCallback</a>
void	<a href="#virEventTimeoutCallback">virEventTimeoutCallback</a>		(int timer, <br />					 void * opaque)

typedef <a href="#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a>
void	<a href="#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a>	(int watch, <br />					 int event)

typedef <a href="#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a>
void	<a href="#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a>	(int timer, <br />					 int timeout)

typedef <a href="#virFreeCallback">virFreeCallback</a>
void	<a href="#virFreeCallback">virFreeCallback</a>			(void * opaque)

int	<a href="#virGetVersion">virGetVersion</a>			(unsigned long * libVer, <br />					 const char * type, <br />					 unsigned long * typeVer)
int	<a href="#virInitialize">virInitialize</a>			(void)
int	<a href="#virInterfaceCreate">virInterfaceCreate</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br />					 unsigned int flags)
<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	<a href="#virInterfaceDefineXML">virInterfaceDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xml, <br />					 unsigned int flags)
int	<a href="#virInterfaceDestroy">virInterfaceDestroy</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br />					 unsigned int flags)
int	<a href="#virInterfaceFree">virInterfaceFree</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virInterfaceGetConnect">virInterfaceGetConnect</a>	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)
const char *	<a href="#virInterfaceGetMACString">virInterfaceGetMACString</a>	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)
const char *	<a href="#virInterfaceGetName">virInterfaceGetName</a>	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)
char *	<a href="#virInterfaceGetXMLDesc">virInterfaceGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br />					 unsigned int flags)
int	<a href="#virInterfaceIsActive">virInterfaceIsActive</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)
<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	<a href="#virInterfaceLookupByMACString">virInterfaceLookupByMACString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * macstr)
<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	<a href="#virInterfaceLookupByName">virInterfaceLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * name)
int	<a href="#virInterfaceRef">virInterfaceRef</a>			(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)
int	<a href="#virInterfaceUndefine">virInterfaceUndefine</a>		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)
<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	<a href="#virNWFilterDefineXML">virNWFilterDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xmlDesc)
int	<a href="#virNWFilterFree">virNWFilterFree</a>			(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)
const char *	<a href="#virNWFilterGetName">virNWFilterGetName</a>	(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)
int	<a href="#virNWFilterGetUUID">virNWFilterGetUUID</a>		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br />					 unsigned char * uuid)
int	<a href="#virNWFilterGetUUIDString">virNWFilterGetUUIDString</a>	(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br />					 char * buf)
char *	<a href="#virNWFilterGetXMLDesc">virNWFilterGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br />					 int flags)
<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	<a href="#virNWFilterLookupByName">virNWFilterLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * name)
<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	<a href="#virNWFilterLookupByUUID">virNWFilterLookupByUUID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const unsigned char * uuid)
<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	<a href="#virNWFilterLookupByUUIDString">virNWFilterLookupByUUIDString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * uuidstr)
int	<a href="#virNWFilterRef">virNWFilterRef</a>			(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)
int	<a href="#virNWFilterUndefine">virNWFilterUndefine</a>		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)
int	<a href="#virNetworkCreate">virNetworkCreate</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)
<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	<a href="#virNetworkCreateXML">virNetworkCreateXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xmlDesc)
<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	<a href="#virNetworkDefineXML">virNetworkDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xml)
int	<a href="#virNetworkDestroy">virNetworkDestroy</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)
int	<a href="#virNetworkFree">virNetworkFree</a>			(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)
int	<a href="#virNetworkGetAutostart">virNetworkGetAutostart</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br />					 int * autostart)
char *	<a href="#virNetworkGetBridgeName">virNetworkGetBridgeName</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virNetworkGetConnect">virNetworkGetConnect</a>	(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net)
const char *	<a href="#virNetworkGetName">virNetworkGetName</a>	(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)
int	<a href="#virNetworkGetUUID">virNetworkGetUUID</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br />					 unsigned char * uuid)
int	<a href="#virNetworkGetUUIDString">virNetworkGetUUIDString</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br />					 char * buf)
char *	<a href="#virNetworkGetXMLDesc">virNetworkGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br />					 int flags)
int	<a href="#virNetworkIsActive">virNetworkIsActive</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net)
int	<a href="#virNetworkIsPersistent">virNetworkIsPersistent</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net)
<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	<a href="#virNetworkLookupByName">virNetworkLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * name)
<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	<a href="#virNetworkLookupByUUID">virNetworkLookupByUUID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const unsigned char * uuid)
<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	<a href="#virNetworkLookupByUUIDString">virNetworkLookupByUUIDString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * uuidstr)
int	<a href="#virNetworkRef">virNetworkRef</a>			(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)
int	<a href="#virNetworkSetAutostart">virNetworkSetAutostart</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br />					 int autostart)
int	<a href="#virNetworkUndefine">virNetworkUndefine</a>		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)
<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a>	<a href="#virNodeDeviceCreateXML">virNodeDeviceCreateXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * xmlDesc, <br />						 unsigned int flags)
int	<a href="#virNodeDeviceDestroy">virNodeDeviceDestroy</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)
int	<a href="#virNodeDeviceDettach">virNodeDeviceDettach</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)
int	<a href="#virNodeDeviceFree">virNodeDeviceFree</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)
const char *	<a href="#virNodeDeviceGetName">virNodeDeviceGetName</a>	(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)
const char *	<a href="#virNodeDeviceGetParent">virNodeDeviceGetParent</a>	(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)
char *	<a href="#virNodeDeviceGetXMLDesc">virNodeDeviceGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br />					 unsigned int flags)
int	<a href="#virNodeDeviceListCaps">virNodeDeviceListCaps</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br />					 char ** const names, <br />					 int maxnames)
<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a>	<a href="#virNodeDeviceLookupByName">virNodeDeviceLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const char * name)
int	<a href="#virNodeDeviceNumOfCaps">virNodeDeviceNumOfCaps</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)
int	<a href="#virNodeDeviceReAttach">virNodeDeviceReAttach</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)
int	<a href="#virNodeDeviceRef">virNodeDeviceRef</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)
int	<a href="#virNodeDeviceReset">virNodeDeviceReset</a>		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)
int	<a href="#virNodeGetCellsFreeMemory">virNodeGetCellsFreeMemory</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 unsigned long long * freeMems, <br />					 int startCell, <br />					 int maxCells)
unsigned long long	<a href="#virNodeGetFreeMemory">virNodeGetFreeMemory</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)
int	<a href="#virNodeGetInfo">virNodeGetInfo</a>			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 <a href="libvirt-libvirt.html#virNodeInfoPtr">virNodeInfoPtr</a> info)
int	<a href="#virNodeGetSecurityModel">virNodeGetSecurityModel</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 <a href="libvirt-libvirt.html#virSecurityModelPtr">virSecurityModelPtr</a> secmodel)
int	<a href="#virNodeListDevices">virNodeListDevices</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * cap, <br />					 char ** const names, <br />					 int maxnames, <br />					 unsigned int flags)
int	<a href="#virNodeNumOfDevices">virNodeNumOfDevices</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * cap, <br />					 unsigned int flags)
<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	<a href="#virSecretDefineXML">virSecretDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xml, <br />					 unsigned int flags)
int	<a href="#virSecretFree">virSecretFree</a>			(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virSecretGetConnect">virSecretGetConnect</a>	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)
int	<a href="#virSecretGetUUID">virSecretGetUUID</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br />					 unsigned char * uuid)
int	<a href="#virSecretGetUUIDString">virSecretGetUUIDString</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br />					 char * buf)
const char *	<a href="#virSecretGetUsageID">virSecretGetUsageID</a>	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)
int	<a href="#virSecretGetUsageType">virSecretGetUsageType</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)
unsigned char *	<a href="#virSecretGetValue">virSecretGetValue</a>	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br />					 size_t * value_size, <br />					 unsigned int flags)
char *	<a href="#virSecretGetXMLDesc">virSecretGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br />					 unsigned int flags)
<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	<a href="#virSecretLookupByUUID">virSecretLookupByUUID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const unsigned char * uuid)
<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	<a href="#virSecretLookupByUUIDString">virSecretLookupByUUIDString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * uuidstr)
<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	<a href="#virSecretLookupByUsage">virSecretLookupByUsage</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 int usageType, <br />					 const char * usageID)
int	<a href="#virSecretRef">virSecretRef</a>			(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)
int	<a href="#virSecretSetValue">virSecretSetValue</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br />					 const unsigned char * value, <br />					 size_t value_size, <br />					 unsigned int flags)
int	<a href="#virSecretUndefine">virSecretUndefine</a>		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)
int	<a href="#virStoragePoolBuild">virStoragePoolBuild</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned int flags)
int	<a href="#virStoragePoolCreate">virStoragePoolCreate</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned int flags)
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolCreateXML">virStoragePoolCreateXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * xmlDesc, <br />						 unsigned int flags)
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolDefineXML">virStoragePoolDefineXML</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * xml, <br />						 unsigned int flags)
int	<a href="#virStoragePoolDelete">virStoragePoolDelete</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned int flags)
int	<a href="#virStoragePoolDestroy">virStoragePoolDestroy</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)
int	<a href="#virStoragePoolFree">virStoragePoolFree</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)
int	<a href="#virStoragePoolGetAutostart">virStoragePoolGetAutostart</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 int * autostart)
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virStoragePoolGetConnect">virStoragePoolGetConnect</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)
int	<a href="#virStoragePoolGetInfo">virStoragePoolGetInfo</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 <a href="libvirt-libvirt.html#virStoragePoolInfoPtr">virStoragePoolInfoPtr</a> info)
const char *	<a href="#virStoragePoolGetName">virStoragePoolGetName</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)
int	<a href="#virStoragePoolGetUUID">virStoragePoolGetUUID</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned char * uuid)
int	<a href="#virStoragePoolGetUUIDString">virStoragePoolGetUUIDString</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 char * buf)
char *	<a href="#virStoragePoolGetXMLDesc">virStoragePoolGetXMLDesc</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned int flags)
int	<a href="#virStoragePoolIsActive">virStoragePoolIsActive</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)
int	<a href="#virStoragePoolIsPersistent">virStoragePoolIsPersistent</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)
int	<a href="#virStoragePoolListVolumes">virStoragePoolListVolumes</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 char ** const names, <br />					 int maxnames)
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolLookupByName">virStoragePoolLookupByName</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const char * name)
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolLookupByUUID">virStoragePoolLookupByUUID</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const unsigned char * uuid)
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolLookupByUUIDString">virStoragePoolLookupByUUIDString</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const char * uuidstr)
<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	<a href="#virStoragePoolLookupByVolume">virStoragePoolLookupByVolume</a>	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)
int	<a href="#virStoragePoolNumOfVolumes">virStoragePoolNumOfVolumes</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)
int	<a href="#virStoragePoolRef">virStoragePoolRef</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)
int	<a href="#virStoragePoolRefresh">virStoragePoolRefresh</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned int flags)
int	<a href="#virStoragePoolSetAutostart">virStoragePoolSetAutostart</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 int autostart)
int	<a href="#virStoragePoolUndefine">virStoragePoolUndefine</a>		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)
<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	<a href="#virStorageVolCreateXML">virStorageVolCreateXML</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />						 const char * xmldesc, <br />						 unsigned int flags)
<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	<a href="#virStorageVolCreateXMLFrom">virStorageVolCreateXMLFrom</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />							 const char * xmldesc, <br />							 <a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> clonevol, <br />							 unsigned int flags)
int	<a href="#virStorageVolDelete">virStorageVolDelete</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br />					 unsigned int flags)
int	<a href="#virStorageVolFree">virStorageVolFree</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)
<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	<a href="#virStorageVolGetConnect">virStorageVolGetConnect</a>	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)
int	<a href="#virStorageVolGetInfo">virStorageVolGetInfo</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br />					 <a href="libvirt-libvirt.html#virStorageVolInfoPtr">virStorageVolInfoPtr</a> info)
const char *	<a href="#virStorageVolGetKey">virStorageVolGetKey</a>	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)
const char *	<a href="#virStorageVolGetName">virStorageVolGetName</a>	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)
char *	<a href="#virStorageVolGetPath">virStorageVolGetPath</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)
char *	<a href="#virStorageVolGetXMLDesc">virStorageVolGetXMLDesc</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br />					 unsigned int flags)
<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	<a href="#virStorageVolLookupByKey">virStorageVolLookupByKey</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const char * key)
<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	<a href="#virStorageVolLookupByName">virStorageVolLookupByName</a>	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />							 const char * name)
<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	<a href="#virStorageVolLookupByPath">virStorageVolLookupByPath</a>	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const char * path)
int	<a href="#virStorageVolRef">virStorageVolRef</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)
int	<a href="#virStorageVolWipe">virStorageVolWipe</a>		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br />					 unsigned int flags)
int	<a href="#virStreamAbort">virStreamAbort</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)
int	<a href="#virStreamEventAddCallback">virStreamEventAddCallback</a>	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 int events, <br />					 <a href="libvirt-libvirt.html#virStreamEventCallback">virStreamEventCallback</a> cb, <br />					 void * opaque, <br />					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)
typedef <a href="#virStreamEventCallback">virStreamEventCallback</a>
void	<a href="#virStreamEventCallback">virStreamEventCallback</a>		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 int events, <br />					 void * opaque)

int	<a href="#virStreamEventRemoveCallback">virStreamEventRemoveCallback</a>	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)
int	<a href="#virStreamEventUpdateCallback">virStreamEventUpdateCallback</a>	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 int events)
int	<a href="#virStreamFinish">virStreamFinish</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)
int	<a href="#virStreamFree">virStreamFree</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)
<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a>	<a href="#virStreamNew">virStreamNew</a>		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 unsigned int flags)
int	<a href="#virStreamRecv">virStreamRecv</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 char * data, <br />					 size_t nbytes)
int	<a href="#virStreamRecvAll">virStreamRecvAll</a>		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 <a href="libvirt-libvirt.html#virStreamSinkFunc">virStreamSinkFunc</a> handler, <br />					 void * opaque)
int	<a href="#virStreamRef">virStreamRef</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)
int	<a href="#virStreamSend">virStreamSend</a>			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 const char * data, <br />					 size_t nbytes)
int	<a href="#virStreamSendAll">virStreamSendAll</a>		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 <a href="libvirt-libvirt.html#virStreamSourceFunc">virStreamSourceFunc</a> handler, <br />					 void * opaque)
typedef <a href="#virStreamSinkFunc">virStreamSinkFunc</a>
int	<a href="#virStreamSinkFunc">virStreamSinkFunc</a>		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br />					 const char * data, <br />					 size_t nbytes, <br />					 void * opaque)

typedef <a href="#virStreamSourceFunc">virStreamSourceFunc</a>
int	<a href="#virStreamSourceFunc">virStreamSourceFunc</a>		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br />					 char * data, <br />					 size_t nbytes, <br />					 void * opaque)

</pre><h2>Description</h2><h3><a name="macros" id="macros">Macros</a></h3><h3><a name="LIBVIR_VERSION_NUMBER" id="LIBVIR_VERSION_NUMBER"><code>LIBVIR_VERSION_NUMBER</code></a></h3><pre>#define LIBVIR_VERSION_NUMBER</pre><p>Macro providing the version of the library as version * 1,000,000 + minor * 1000 + micro</p><h3><a name="VIR_COPY_CPUMAP" id="VIR_COPY_CPUMAP"><code>VIR_COPY_CPUMAP</code></a></h3><pre>#define VIR_COPY_CPUMAP</pre><p>This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. <a href="libvirt-libvirt.html#VIR_COPY_CPUMAP">VIR_COPY_CPUMAP</a> macro extract the cpumap of the specified vcpu from cpumaps array and copy it into cpumap to be used later by virDomainPinVcpu() API.</p><h3><a name="VIR_CPU_MAPLEN" id="VIR_CPU_MAPLEN"><code>VIR_CPU_MAPLEN</code></a></h3><pre>#define VIR_CPU_MAPLEN</pre><p>This macro is to be used in conjunction with virDomainPinVcpu() API. It returns the length (in bytes) required to store the complete CPU map between a single virtual &amp; all physical CPUs of a domain.</p><h3><a name="VIR_CPU_USABLE" id="VIR_CPU_USABLE"><code>VIR_CPU_USABLE</code></a></h3><pre>#define VIR_CPU_USABLE</pre><p>This macro is to be used in conjunction with virDomainGetVcpus() API. <a href="libvirt-libvirt.html#VIR_CPU_USABLE">VIR_CPU_USABLE</a> macro returns a non zero value (true) if the cpu is usable by the vcpu, and 0 otherwise.</p><h3><a name="VIR_DOMAIN_EVENT_CALLBACK" id="VIR_DOMAIN_EVENT_CALLBACK"><code>VIR_DOMAIN_EVENT_CALLBACK</code></a></h3><pre>#define VIR_DOMAIN_EVENT_CALLBACK</pre><p>Used to cast the event specific callback into the generic one for use for virDomainEventRegister</p><h3><a name="VIR_DOMAIN_MEMORY_FIELD_LENGTH" id="VIR_DOMAIN_MEMORY_FIELD_LENGTH"><code>VIR_DOMAIN_MEMORY_FIELD_LENGTH</code></a></h3><pre>#define VIR_DOMAIN_MEMORY_FIELD_LENGTH</pre><p>Macro providing the field length of <a href="libvirt-libvirt.html#virMemoryParameter">virMemoryParameter</a></p><h3><a name="VIR_DOMAIN_MEMORY_HARD_LIMIT" id="VIR_DOMAIN_MEMORY_HARD_LIMIT"><code>VIR_DOMAIN_MEMORY_HARD_LIMIT</code></a></h3><pre>#define VIR_DOMAIN_MEMORY_HARD_LIMIT</pre><p>Macro for the memory tunable hard_limit: it represents the maximum memory the guest can use.</p><h3><a name="VIR_DOMAIN_MEMORY_MIN_GUARANTEE" id="VIR_DOMAIN_MEMORY_MIN_GUARANTEE"><code>VIR_DOMAIN_MEMORY_MIN_GUARANTEE</code></a></h3><pre>#define VIR_DOMAIN_MEMORY_MIN_GUARANTEE</pre><p>Macro for the memory tunable min_guarantee: it represents the minimum memory guaranteed to be reserved for the guest.</p><h3><a name="VIR_DOMAIN_MEMORY_PARAM_UNLIMITED" id="VIR_DOMAIN_MEMORY_PARAM_UNLIMITED"><code>VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</code></a></h3><pre>#define VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</pre><p>Macro providing the <a href="libvirt-libvirt.html#virMemoryParameter">virMemoryParameter</a> value that indicates "unlimited"</p><h3><a name="VIR_DOMAIN_MEMORY_SOFT_LIMIT" id="VIR_DOMAIN_MEMORY_SOFT_LIMIT"><code>VIR_DOMAIN_MEMORY_SOFT_LIMIT</code></a></h3><pre>#define VIR_DOMAIN_MEMORY_SOFT_LIMIT</pre><p>Macro for the memory tunable soft_limit: it represents the memory upper limit enforced during memory contention.</p><h3><a name="VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT" id="VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT"><code>VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</code></a></h3><pre>#define VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</pre><p>Macro for the swap tunable swap_hard_limit: it represents the maximum swap the guest can use.</p><h3><a name="VIR_DOMAIN_SCHED_FIELD_LENGTH" id="VIR_DOMAIN_SCHED_FIELD_LENGTH"><code>VIR_DOMAIN_SCHED_FIELD_LENGTH</code></a></h3><pre>#define VIR_DOMAIN_SCHED_FIELD_LENGTH</pre><p>Macro providing the field length of <a href="libvirt-libvirt.html#virSchedParameter">virSchedParameter</a></p><h3><a name="VIR_GET_CPUMAP" id="VIR_GET_CPUMAP"><code>VIR_GET_CPUMAP</code></a></h3><pre>#define VIR_GET_CPUMAP</pre><p>This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. <a href="libvirt-libvirt.html#VIR_GET_CPUMAP">VIR_GET_CPUMAP</a> macro returns a pointer to the cpumap of the specified vcpu from cpumaps array.</p><h3><a name="VIR_NODEINFO_MAXCPUS" id="VIR_NODEINFO_MAXCPUS"><code>VIR_NODEINFO_MAXCPUS</code></a></h3><pre>#define VIR_NODEINFO_MAXCPUS</pre><p>This macro is to calculate the total number of CPUs supported but not necessary active in the host.</p><h3><a name="VIR_SECURITY_DOI_BUFLEN" id="VIR_SECURITY_DOI_BUFLEN"><code>VIR_SECURITY_DOI_BUFLEN</code></a></h3><pre>#define VIR_SECURITY_DOI_BUFLEN</pre><p>Macro providing the maximum length of the <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> doi string.</p><h3><a name="VIR_SECURITY_LABEL_BUFLEN" id="VIR_SECURITY_LABEL_BUFLEN"><code>VIR_SECURITY_LABEL_BUFLEN</code></a></h3><pre>#define VIR_SECURITY_LABEL_BUFLEN</pre><p>Macro providing the maximum length of the <a href="libvirt-libvirt.html#virSecurityLabel">virSecurityLabel</a> label string. Note that this value is based on that used by Labeled NFS.</p><h3><a name="VIR_SECURITY_MODEL_BUFLEN" id="VIR_SECURITY_MODEL_BUFLEN"><code>VIR_SECURITY_MODEL_BUFLEN</code></a></h3><pre>#define VIR_SECURITY_MODEL_BUFLEN</pre><p>Macro providing the maximum length of the <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> model string.</p><h3><a name="VIR_UNUSE_CPU" id="VIR_UNUSE_CPU"><code>VIR_UNUSE_CPU</code></a></h3><pre>#define VIR_UNUSE_CPU</pre><p>This macro is to be used in conjunction with virDomainPinVcpu() API. USE_CPU macro reset the bit (CPU not usable) of the related cpu in cpumap.</p><h3><a name="VIR_USE_CPU" id="VIR_USE_CPU"><code>VIR_USE_CPU</code></a></h3><pre>#define VIR_USE_CPU</pre><p>This macro is to be used in conjunction with virDomainPinVcpu() API. USE_CPU macro set the bit (CPU usable) of the related cpu in cpumap.</p><h3><a name="VIR_UUID_BUFLEN" id="VIR_UUID_BUFLEN"><code>VIR_UUID_BUFLEN</code></a></h3><pre>#define VIR_UUID_BUFLEN</pre><p>This macro provides the length of the buffer required for virDomainGetUUID()</p><h3><a name="VIR_UUID_STRING_BUFLEN" id="VIR_UUID_STRING_BUFLEN"><code>VIR_UUID_STRING_BUFLEN</code></a></h3><pre>#define VIR_UUID_STRING_BUFLEN</pre><p>This macro provides the length of the buffer required for virDomainGetUUIDString()</p><h3><a name="types" id="types">Types</a></h3><h3><a name="virCPUCompareResult" id="virCPUCompareResult"><code>virCPUCompareResult</code></a></h3><div class="api"><pre>enum virCPUCompareResult {
</pre><table><tr><td><a name="VIR_CPU_COMPARE_ERROR" id="VIR_CPU_COMPARE_ERROR">VIR_CPU_COMPARE_ERROR</a></td><td> = </td><td>-1</td></tr><tr><td><a name="VIR_CPU_COMPARE_INCOMPATIBLE" id="VIR_CPU_COMPARE_INCOMPATIBLE">VIR_CPU_COMPARE_INCOMPATIBLE</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_CPU_COMPARE_IDENTICAL" id="VIR_CPU_COMPARE_IDENTICAL">VIR_CPU_COMPARE_IDENTICAL</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_CPU_COMPARE_SUPERSET" id="VIR_CPU_COMPARE_SUPERSET">VIR_CPU_COMPARE_SUPERSET</a></td><td> = </td><td>2</td></tr></table><pre>}
</pre></div><h3><a name="virConnect" id="virConnect"><code>virConnect</code></a></h3><div class="api"><pre>struct virConnect{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virConnectAuth" id="virConnectAuth"><code>virConnectAuth</code></a></h3><div class="api"><pre>struct virConnectAuth{
</pre><table><tr><td>int *</td><td>credtype</td><td> : List of supported <a href="libvirt-libvirt.html#virConnectCredentialType">virConnectCredentialType</a> values</td></tr><tr><td>unsigned int</td><td>ncredtype</td></tr><tr><td><a href="libvirt-libvirt.html#virConnectAuthCallbackPtr">virConnectAuthCallbackPtr</a></td><td>cb</td><td> : Callback used to collect credentials</td></tr><tr><td>void *</td><td>cbdata</td></tr></table><pre>
}
</pre></div><h3><a name="virConnectCredential" id="virConnectCredential"><code>virConnectCredential</code></a></h3><div class="api"><pre>struct virConnectCredential{
</pre><table><tr><td>int</td><td>type</td><td> : One of <a href="libvirt-libvirt.html#virConnectCredentialType">virConnectCredentialType</a> constants</td></tr><tr><td>const char *</td><td>prompt</td><td> : Prompt to show to user</td></tr><tr><td>const char *</td><td>challenge</td><td> : Additional challenge to show</td></tr><tr><td>const char *</td><td>defresult</td><td> : Optional default result</td></tr><tr><td>char *</td><td>result</td><td> : Result to be filled with user response (or defresult)</td></tr><tr><td>unsigned int</td><td>resultlen</td><td> : Length of the result</td></tr></table><pre>
}
</pre></div><h3><a name="virConnectCredentialType" id="virConnectCredentialType"><code>virConnectCredentialType</code></a></h3><div class="api"><pre>enum virConnectCredentialType {
</pre><table><tr><td><a name="VIR_CRED_USERNAME" id="VIR_CRED_USERNAME">VIR_CRED_USERNAME</a></td><td> = </td><td>1</td><td> : Identity to act as</td></tr><tr><td><a name="VIR_CRED_AUTHNAME" id="VIR_CRED_AUTHNAME">VIR_CRED_AUTHNAME</a></td><td> = </td><td>2</td><td> : Identify to authorize as</td></tr><tr><td><a name="VIR_CRED_LANGUAGE" id="VIR_CRED_LANGUAGE">VIR_CRED_LANGUAGE</a></td><td> = </td><td>3</td><td> : RFC 1766 languages, comma separated</td></tr><tr><td><a name="VIR_CRED_CNONCE" id="VIR_CRED_CNONCE">VIR_CRED_CNONCE</a></td><td> = </td><td>4</td><td> : client supplies a nonce</td></tr><tr><td><a name="VIR_CRED_PASSPHRASE" id="VIR_CRED_PASSPHRASE">VIR_CRED_PASSPHRASE</a></td><td> = </td><td>5</td><td> : Passphrase secret</td></tr><tr><td><a name="VIR_CRED_ECHOPROMPT" id="VIR_CRED_ECHOPROMPT">VIR_CRED_ECHOPROMPT</a></td><td> = </td><td>6</td><td> : Challenge response</td></tr><tr><td><a name="VIR_CRED_NOECHOPROMPT" id="VIR_CRED_NOECHOPROMPT">VIR_CRED_NOECHOPROMPT</a></td><td> = </td><td>7</td><td> : Challenge response</td></tr><tr><td><a name="VIR_CRED_REALM" id="VIR_CRED_REALM">VIR_CRED_REALM</a></td><td> = </td><td>8</td><td> : Authentication realm</td></tr><tr><td><a name="VIR_CRED_EXTERNAL" id="VIR_CRED_EXTERNAL">VIR_CRED_EXTERNAL</a></td><td> = </td><td>9</td><td> : Externally managed credential More may be added - expect the unexpected</td></tr></table><pre>}
</pre></div><h3><a name="virConnectFlags" id="virConnectFlags"><code>virConnectFlags</code></a></h3><div class="api"><pre>enum virConnectFlags {
</pre><table><tr><td><a name="VIR_CONNECT_RO" id="VIR_CONNECT_RO">VIR_CONNECT_RO</a></td><td> = </td><td>1</td><td> : A readonly connection</td></tr></table><pre>}
</pre></div><h3><a name="virDomain" id="virDomain"><code>virDomain</code></a></h3><div class="api"><pre>struct virDomain{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainBlockInfo" id="virDomainBlockInfo"><code>virDomainBlockInfo</code></a></h3><div class="api"><pre>struct virDomainBlockInfo{
</pre><table><tr><td>unsigned long long</td><td>capacity</td><td> : logical size in bytes of the block device backing image</td></tr><tr><td>unsigned long long</td><td>allocation</td><td> : highest allocated extent in bytes of the block device backing image</td></tr><tr><td>unsigned long long</td><td>physical</td><td> : physical size in bytes of the container of the backing image</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainBlockStatsStruct" id="virDomainBlockStatsStruct"><code>virDomainBlockStatsStruct</code></a></h3><div class="api"><pre>struct virDomainBlockStatsStruct{
</pre><table><tr><td>long long</td><td>rd_req</td><td> : number of read requests</td></tr><tr><td>long long</td><td>rd_bytes</td><td> : number of read bytes</td></tr><tr><td>long long</td><td>wr_req</td><td> : number of write requests</td></tr><tr><td>long long</td><td>wr_bytes</td><td> : number of written bytes</td></tr><tr><td>long long</td><td>errs</td><td> : In Xen this returns the mysterious 'oo_req'.</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainCoreDumpFlags" id="virDomainCoreDumpFlags"><code>virDomainCoreDumpFlags</code></a></h3><div class="api"><pre>enum virDomainCoreDumpFlags {
</pre><table><tr><td><a name="VIR_DUMP_CRASH" id="VIR_DUMP_CRASH">VIR_DUMP_CRASH</a></td><td> = </td><td>1</td><td> : crash after dump</td></tr><tr><td><a name="VIR_DUMP_LIVE" id="VIR_DUMP_LIVE">VIR_DUMP_LIVE</a></td><td> = </td><td>2</td><td> : live dump</td></tr></table><pre>}
</pre></div><h3><a name="virDomainCreateFlags" id="virDomainCreateFlags"><code>virDomainCreateFlags</code></a></h3><div class="api"><pre>enum virDomainCreateFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_NONE" id="VIR_DOMAIN_NONE">VIR_DOMAIN_NONE</a></td><td> = </td><td>0</td><td> : Default behavior</td></tr><tr><td><a name="VIR_DOMAIN_START_PAUSED" id="VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a></td><td> = </td><td>1</td><td> : Launch guest in paused state</td></tr></table><pre>}
</pre></div><h3><a name="virDomainDeviceModifyFlags" id="virDomainDeviceModifyFlags"><code>virDomainDeviceModifyFlags</code></a></h3><div class="api"><pre>enum virDomainDeviceModifyFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_DEVICE_MODIFY_CURRENT" id="VIR_DOMAIN_DEVICE_MODIFY_CURRENT">VIR_DOMAIN_DEVICE_MODIFY_CURRENT</a></td><td> = </td><td>0</td><td> : Modify device allocation based on current domain state</td></tr><tr><td><a name="VIR_DOMAIN_DEVICE_MODIFY_LIVE" id="VIR_DOMAIN_DEVICE_MODIFY_LIVE">VIR_DOMAIN_DEVICE_MODIFY_LIVE</a></td><td> = </td><td>1</td><td> : Modify live device allocation</td></tr><tr><td><a name="VIR_DOMAIN_DEVICE_MODIFY_CONFIG" id="VIR_DOMAIN_DEVICE_MODIFY_CONFIG">VIR_DOMAIN_DEVICE_MODIFY_CONFIG</a></td><td> = </td><td>2</td><td> : Modify persisted device allocation</td></tr><tr><td><a name="VIR_DOMAIN_DEVICE_MODIFY_FORCE" id="VIR_DOMAIN_DEVICE_MODIFY_FORCE">VIR_DOMAIN_DEVICE_MODIFY_FORCE</a></td><td> = </td><td>4</td><td> : Forcibly modify device (ex. force eject a cdrom)</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventDefinedDetailType" id="virDomainEventDefinedDetailType"><code>virDomainEventDefinedDetailType</code></a></h3><div class="api"><pre>enum virDomainEventDefinedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_DEFINED_ADDED" id="VIR_DOMAIN_EVENT_DEFINED_ADDED">VIR_DOMAIN_EVENT_DEFINED_ADDED</a></td><td> = </td><td>0</td><td> : Newly created config file</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_DEFINED_UPDATED" id="VIR_DOMAIN_EVENT_DEFINED_UPDATED">VIR_DOMAIN_EVENT_DEFINED_UPDATED</a></td><td> = </td><td>1</td><td> : Changed config file</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventGraphicsAddress" id="virDomainEventGraphicsAddress"><code>virDomainEventGraphicsAddress</code></a></h3><div class="api"><pre>struct virDomainEventGraphicsAddress{
</pre><table><tr><td>int</td><td>family</td><td> : Address family, <a href="libvirt-libvirt.html#virDomainEventGraphicsAddressType">virDomainEventGraphicsAddressType</a></td></tr><tr><td>const char *</td><td>node</td><td> : Address of node (eg IP address)</td></tr><tr><td>const char *</td><td>service</td><td> : Service name/number (eg TCP port)</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainEventGraphicsAddressType" id="virDomainEventGraphicsAddressType"><code>virDomainEventGraphicsAddressType</code></a></h3><div class="api"><pre>enum virDomainEventGraphicsAddressType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4" id="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4</a></td><td> = </td><td>1</td><td> : IPv4 address</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6" id="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6</a></td><td> = </td><td>2</td><td> : IPv6 address</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventGraphicsPhase" id="virDomainEventGraphicsPhase"><code>virDomainEventGraphicsPhase</code></a></h3><div class="api"><pre>enum virDomainEventGraphicsPhase {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_CONNECT" id="VIR_DOMAIN_EVENT_GRAPHICS_CONNECT">VIR_DOMAIN_EVENT_GRAPHICS_CONNECT</a></td><td> = </td><td>0</td><td> : Initial socket connection established</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE" id="VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE">VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE</a></td><td> = </td><td>1</td><td> : Authentication &amp; setup completed</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT" id="VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT">VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT</a></td><td> = </td><td>2</td><td> : Final socket disconnection</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventGraphicsSubject" id="virDomainEventGraphicsSubject"><code>virDomainEventGraphicsSubject</code></a></h3><div class="api"><pre>struct virDomainEventGraphicsSubject{
</pre><table><tr><td>int</td><td>nidentity</td><td> : Number of identities in arra</td></tr><tr><td><a href="libvirt-libvirt.html#virDomainEventGraphicsSubjectIdentityPtr">virDomainEventGraphicsSubjectIdentityPtr</a></td><td>identities</td><td> : Array of identities for subject</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainEventGraphicsSubjectIdentity" id="virDomainEventGraphicsSubjectIdentity"><code>virDomainEventGraphicsSubjectIdentity</code></a></h3><div class="api"><pre>struct virDomainEventGraphicsSubjectIdentity{
</pre><table><tr><td>const char *</td><td>type</td><td> : Type of identity</td></tr><tr><td>const char *</td><td>name</td><td> : Identity value</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainEventID" id="virDomainEventID"><code>virDomainEventID</code></a></h3><div class="api"><pre>enum virDomainEventID {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_ID_LIFECYCLE" id="VIR_DOMAIN_EVENT_ID_LIFECYCLE">VIR_DOMAIN_EVENT_ID_LIFECYCLE</a></td><td> = </td><td>0</td><td> : <a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_REBOOT" id="VIR_DOMAIN_EVENT_ID_REBOOT">VIR_DOMAIN_EVENT_ID_REBOOT</a></td><td> = </td><td>1</td><td> : <a href="libvirt-libvirt.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_RTC_CHANGE" id="VIR_DOMAIN_EVENT_ID_RTC_CHANGE">VIR_DOMAIN_EVENT_ID_RTC_CHANGE</a></td><td> = </td><td>2</td><td> : <a href="libvirt-libvirt.html#virConnectDomainEventRTCChangeCallback">virConnectDomainEventRTCChangeCallback</a></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_WATCHDOG" id="VIR_DOMAIN_EVENT_ID_WATCHDOG">VIR_DOMAIN_EVENT_ID_WATCHDOG</a></td><td> = </td><td>3</td><td> : <a href="libvirt-libvirt.html#virConnectDomainEventWatchdogCallback">virConnectDomainEventWatchdogCallback</a></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_IO_ERROR" id="VIR_DOMAIN_EVENT_ID_IO_ERROR">VIR_DOMAIN_EVENT_ID_IO_ERROR</a></td><td> = </td><td>4</td><td> : <a href="libvirt-libvirt.html#virConnectDomainEventIOErrorCallback">virConnectDomainEventIOErrorCallback</a></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_GRAPHICS" id="VIR_DOMAIN_EVENT_ID_GRAPHICS">VIR_DOMAIN_EVENT_ID_GRAPHICS</a></td><td> = </td><td>5</td><td> : <a href="libvirt-libvirt.html#virConnectDomainEventGraphicsCallback">virConnectDomainEventGraphicsCallback</a></td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON" id="VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON">VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON</a></td><td> = </td><td>6</td><td> : * NB: this enum value will increase over time as new events are * added to the libvirt API. It reflects the last event ID supported * by this version of the libvirt API. *</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_ID_LAST" id="VIR_DOMAIN_EVENT_ID_LAST">VIR_DOMAIN_EVENT_ID_LAST</a></td><td> = </td><td>7</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventIOErrorAction" id="virDomainEventIOErrorAction"><code>virDomainEventIOErrorAction</code></a></h3><div class="api"><pre>enum virDomainEventIOErrorAction {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_IO_ERROR_NONE" id="VIR_DOMAIN_EVENT_IO_ERROR_NONE">VIR_DOMAIN_EVENT_IO_ERROR_NONE</a></td><td> = </td><td>0</td><td> : No action, IO error ignored</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_IO_ERROR_PAUSE" id="VIR_DOMAIN_EVENT_IO_ERROR_PAUSE">VIR_DOMAIN_EVENT_IO_ERROR_PAUSE</a></td><td> = </td><td>1</td><td> : Guest CPUs are pausde</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_IO_ERROR_REPORT" id="VIR_DOMAIN_EVENT_IO_ERROR_REPORT">VIR_DOMAIN_EVENT_IO_ERROR_REPORT</a></td><td> = </td><td>2</td><td> : IO error reported to guest OS</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventResumedDetailType" id="virDomainEventResumedDetailType"><code>virDomainEventResumedDetailType</code></a></h3><div class="api"><pre>enum virDomainEventResumedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_RESUMED_UNPAUSED" id="VIR_DOMAIN_EVENT_RESUMED_UNPAUSED">VIR_DOMAIN_EVENT_RESUMED_UNPAUSED</a></td><td> = </td><td>0</td><td> : Normal resume due to admin unpause</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_RESUMED_MIGRATED" id="VIR_DOMAIN_EVENT_RESUMED_MIGRATED">VIR_DOMAIN_EVENT_RESUMED_MIGRATED</a></td><td> = </td><td>1</td><td> : Resumed for completion of migration</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventStartedDetailType" id="virDomainEventStartedDetailType"><code>virDomainEventStartedDetailType</code></a></h3><div class="api"><pre>enum virDomainEventStartedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_STARTED_BOOTED" id="VIR_DOMAIN_EVENT_STARTED_BOOTED">VIR_DOMAIN_EVENT_STARTED_BOOTED</a></td><td> = </td><td>0</td><td> : Normal startup from boot</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STARTED_MIGRATED" id="VIR_DOMAIN_EVENT_STARTED_MIGRATED">VIR_DOMAIN_EVENT_STARTED_MIGRATED</a></td><td> = </td><td>1</td><td> : Incoming migration from another host</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STARTED_RESTORED" id="VIR_DOMAIN_EVENT_STARTED_RESTORED">VIR_DOMAIN_EVENT_STARTED_RESTORED</a></td><td> = </td><td>2</td><td> : Restored from a state file</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT" id="VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT</a></td><td> = </td><td>3</td><td> : Restored from snapshot</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventStoppedDetailType" id="virDomainEventStoppedDetailType"><code>virDomainEventStoppedDetailType</code></a></h3><div class="api"><pre>enum virDomainEventStoppedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN" id="VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN">VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN</a></td><td> = </td><td>0</td><td> : Normal shutdown</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_DESTROYED" id="VIR_DOMAIN_EVENT_STOPPED_DESTROYED">VIR_DOMAIN_EVENT_STOPPED_DESTROYED</a></td><td> = </td><td>1</td><td> : Forced poweroff from host</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_CRASHED" id="VIR_DOMAIN_EVENT_STOPPED_CRASHED">VIR_DOMAIN_EVENT_STOPPED_CRASHED</a></td><td> = </td><td>2</td><td> : Guest crashed</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_MIGRATED" id="VIR_DOMAIN_EVENT_STOPPED_MIGRATED">VIR_DOMAIN_EVENT_STOPPED_MIGRATED</a></td><td> = </td><td>3</td><td> : Migrated off to another host</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_SAVED" id="VIR_DOMAIN_EVENT_STOPPED_SAVED">VIR_DOMAIN_EVENT_STOPPED_SAVED</a></td><td> = </td><td>4</td><td> : Saved to a state file</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_FAILED" id="VIR_DOMAIN_EVENT_STOPPED_FAILED">VIR_DOMAIN_EVENT_STOPPED_FAILED</a></td><td> = </td><td>5</td><td> : Host emulator/mgmt failed</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT" id="VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT</a></td><td> = </td><td>6</td><td> : offline snapshot loaded</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventSuspendedDetailType" id="virDomainEventSuspendedDetailType"><code>virDomainEventSuspendedDetailType</code></a></h3><div class="api"><pre>enum virDomainEventSuspendedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_PAUSED" id="VIR_DOMAIN_EVENT_SUSPENDED_PAUSED">VIR_DOMAIN_EVENT_SUSPENDED_PAUSED</a></td><td> = </td><td>0</td><td> : Normal suspend due to admin pause</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED" id="VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED">VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED</a></td><td> = </td><td>1</td><td> : Suspended for offline migration</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_IOERROR" id="VIR_DOMAIN_EVENT_SUSPENDED_IOERROR">VIR_DOMAIN_EVENT_SUSPENDED_IOERROR</a></td><td> = </td><td>2</td><td> : Suspended due to a disk I/O error</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG" id="VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG">VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG</a></td><td> = </td><td>3</td><td> : Suspended due to a watchdog firing</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventType" id="virDomainEventType"><code>virDomainEventType</code></a></h3><div class="api"><pre>enum virDomainEventType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_DEFINED" id="VIR_DOMAIN_EVENT_DEFINED">VIR_DOMAIN_EVENT_DEFINED</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_UNDEFINED" id="VIR_DOMAIN_EVENT_UNDEFINED">VIR_DOMAIN_EVENT_UNDEFINED</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STARTED" id="VIR_DOMAIN_EVENT_STARTED">VIR_DOMAIN_EVENT_STARTED</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_SUSPENDED" id="VIR_DOMAIN_EVENT_SUSPENDED">VIR_DOMAIN_EVENT_SUSPENDED</a></td><td> = </td><td>3</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_RESUMED" id="VIR_DOMAIN_EVENT_RESUMED">VIR_DOMAIN_EVENT_RESUMED</a></td><td> = </td><td>4</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_STOPPED" id="VIR_DOMAIN_EVENT_STOPPED">VIR_DOMAIN_EVENT_STOPPED</a></td><td> = </td><td>5</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventUndefinedDetailType" id="virDomainEventUndefinedDetailType"><code>virDomainEventUndefinedDetailType</code></a></h3><div class="api"><pre>enum virDomainEventUndefinedDetailType {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_UNDEFINED_REMOVED" id="VIR_DOMAIN_EVENT_UNDEFINED_REMOVED">VIR_DOMAIN_EVENT_UNDEFINED_REMOVED</a></td><td> = </td><td>0</td><td> : Deleted the config file</td></tr></table><pre>}
</pre></div><h3><a name="virDomainEventWatchdogAction" id="virDomainEventWatchdogAction"><code>virDomainEventWatchdogAction</code></a></h3><div class="api"><pre>enum virDomainEventWatchdogAction {
</pre><table><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_NONE" id="VIR_DOMAIN_EVENT_WATCHDOG_NONE">VIR_DOMAIN_EVENT_WATCHDOG_NONE</a></td><td> = </td><td>0</td><td> : No action, watchdog ignored</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_PAUSE" id="VIR_DOMAIN_EVENT_WATCHDOG_PAUSE">VIR_DOMAIN_EVENT_WATCHDOG_PAUSE</a></td><td> = </td><td>1</td><td> : Guest CPUs are paused</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_RESET" id="VIR_DOMAIN_EVENT_WATCHDOG_RESET">VIR_DOMAIN_EVENT_WATCHDOG_RESET</a></td><td> = </td><td>2</td><td> : Guest CPUs are reset</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF" id="VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF">VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF</a></td><td> = </td><td>3</td><td> : Guest is forcably powered off</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN" id="VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN">VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN</a></td><td> = </td><td>4</td><td> : Guest is requested to gracefully shutdown</td></tr><tr><td><a name="VIR_DOMAIN_EVENT_WATCHDOG_DEBUG" id="VIR_DOMAIN_EVENT_WATCHDOG_DEBUG">VIR_DOMAIN_EVENT_WATCHDOG_DEBUG</a></td><td> = </td><td>5</td><td> : No action, a debug message logged</td></tr></table><pre>}
</pre></div><h3><a name="virDomainInfo" id="virDomainInfo"><code>virDomainInfo</code></a></h3><div class="api"><pre>struct virDomainInfo{
</pre><table><tr><td>unsigned char</td><td>state</td><td> : the running state, one of <a href="libvirt-libvirt.html#virDomainState">virDomainState</a></td></tr><tr><td>unsigned long</td><td>maxMem</td><td> : the maximum memory in KBytes allowed</td></tr><tr><td>unsigned long</td><td>memory</td><td> : the memory in KBytes used by the domain</td></tr><tr><td>unsigned short</td><td>nrVirtCpu</td><td> : the number of virtual CPUs for the domain</td></tr><tr><td>unsigned long long</td><td>cpuTime</td><td> : the CPU time used in nanoseconds</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainInterfaceStatsStruct" id="virDomainInterfaceStatsStruct"><code>virDomainInterfaceStatsStruct</code></a></h3><div class="api"><pre>struct virDomainInterfaceStatsStruct{
</pre><table><tr><td>long long</td><td>rx_bytes</td></tr><tr><td>long long</td><td>rx_packets</td></tr><tr><td>long long</td><td>rx_errs</td></tr><tr><td>long long</td><td>rx_drop</td></tr><tr><td>long long</td><td>tx_bytes</td></tr><tr><td>long long</td><td>tx_packets</td></tr><tr><td>long long</td><td>tx_errs</td></tr><tr><td>long long</td><td>tx_drop</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainJobInfo" id="virDomainJobInfo"><code>virDomainJobInfo</code></a></h3><div class="api"><pre>struct virDomainJobInfo{
</pre><table><tr><td>int</td><td>type</td><td> : Time is measured in mill-seconds</td></tr><tr><td>unsigned long long</td><td>timeElapsed</td><td> : Always set</td></tr><tr><td>unsigned long long</td><td>timeRemaining</td><td> : Only for <a href="libvirt-libvirt.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> Data is measured in bytes unless otherwise specified * and is measuring the job as a whole * * For VIR_DOMAIN_JOB_UNBOUNDED, dataTotal may be less * than the final sum of dataProcessed + dataRemaining * in the event that the hypervisor has to repeat some * data eg due to dirtied pages during migration * * For VIR_DOMAIN_JOB_BOUNDED, dataTotal shall always * equal sum of dataProcessed + dataRemaining *</td></tr><tr><td>unsigned long long</td><td>dataTotal</td></tr><tr><td>unsigned long long</td><td>dataProcessed</td></tr><tr><td>unsigned long long</td><td>dataRemaining</td><td> : As above, but only tracking guest memory progress</td></tr><tr><td>unsigned long long</td><td>memTotal</td></tr><tr><td>unsigned long long</td><td>memProcessed</td></tr><tr><td>unsigned long long</td><td>memRemaining</td><td> : As above, but only tracking guest disk file progress</td></tr><tr><td>unsigned long long</td><td>fileTotal</td></tr><tr><td>unsigned long long</td><td>fileProcessed</td></tr><tr><td>unsigned long long</td><td>fileRemaining</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainJobType" id="virDomainJobType"><code>virDomainJobType</code></a></h3><div class="api"><pre>enum virDomainJobType {
</pre><table><tr><td><a name="VIR_DOMAIN_JOB_NONE" id="VIR_DOMAIN_JOB_NONE">VIR_DOMAIN_JOB_NONE</a></td><td> = </td><td>0</td><td> : No job is active</td></tr><tr><td><a name="VIR_DOMAIN_JOB_BOUNDED" id="VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a></td><td> = </td><td>1</td><td> : Job with a finite completion time</td></tr><tr><td><a name="VIR_DOMAIN_JOB_UNBOUNDED" id="VIR_DOMAIN_JOB_UNBOUNDED">VIR_DOMAIN_JOB_UNBOUNDED</a></td><td> = </td><td>2</td><td> : Job without a finite completion time</td></tr><tr><td><a name="VIR_DOMAIN_JOB_COMPLETED" id="VIR_DOMAIN_JOB_COMPLETED">VIR_DOMAIN_JOB_COMPLETED</a></td><td> = </td><td>3</td><td> : Job has finished, but isn't cleaned up</td></tr><tr><td><a name="VIR_DOMAIN_JOB_FAILED" id="VIR_DOMAIN_JOB_FAILED">VIR_DOMAIN_JOB_FAILED</a></td><td> = </td><td>4</td><td> : Job hit error, but isn't cleaned up</td></tr><tr><td><a name="VIR_DOMAIN_JOB_CANCELLED" id="VIR_DOMAIN_JOB_CANCELLED">VIR_DOMAIN_JOB_CANCELLED</a></td><td> = </td><td>5</td><td> : Job was aborted, but isn't cleaned up</td></tr></table><pre>}
</pre></div><h3><a name="virDomainMemoryFlags" id="virDomainMemoryFlags"><code>virDomainMemoryFlags</code></a></h3><div class="api"><pre>enum virDomainMemoryFlags {
</pre><table><tr><td><a name="VIR_MEMORY_VIRTUAL" id="VIR_MEMORY_VIRTUAL">VIR_MEMORY_VIRTUAL</a></td><td> = </td><td>1</td><td> : addresses are virtual addresses</td></tr><tr><td><a name="VIR_MEMORY_PHYSICAL" id="VIR_MEMORY_PHYSICAL">VIR_MEMORY_PHYSICAL</a></td><td> = </td><td>2</td><td> : addresses are physical addresses</td></tr></table><pre>}
</pre></div><h3><a name="virDomainMemoryStatStruct" id="virDomainMemoryStatStruct"><code>virDomainMemoryStatStruct</code></a></h3><div class="api"><pre>struct virDomainMemoryStatStruct{
</pre><table><tr><td>int</td><td>tag</td></tr><tr><td>unsigned long long</td><td>val</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainMemoryStatTags" id="virDomainMemoryStatTags"><code>virDomainMemoryStatTags</code></a></h3><div class="api"><pre>enum virDomainMemoryStatTags {
</pre><table><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_SWAP_IN" id="VIR_DOMAIN_MEMORY_STAT_SWAP_IN">VIR_DOMAIN_MEMORY_STAT_SWAP_IN</a></td><td> = </td><td>0</td><td> : The total amount of memory written out to swap space (in kB).</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_SWAP_OUT" id="VIR_DOMAIN_MEMORY_STAT_SWAP_OUT">VIR_DOMAIN_MEMORY_STAT_SWAP_OUT</a></td><td> = </td><td>1</td><td> : * Page faults occur when a process makes a valid access to virtual memory * that is not available. When servicing the page fault, if disk IO is * required, it is considered a major fault. If not, it is a minor fault. * These are expressed as the number of faults that have occurred. *</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT" id="VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT">VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT" id="VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT">VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT</a></td><td> = </td><td>3</td><td> : * The amount of memory left completely unused by the system. Memory that * is available but used for reclaimable caches should NOT be reported as * free. This value is expressed in kB. *</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_UNUSED" id="VIR_DOMAIN_MEMORY_STAT_UNUSED">VIR_DOMAIN_MEMORY_STAT_UNUSED</a></td><td> = </td><td>4</td><td> : * The total amount of usable memory as seen by the domain. This value * may be less than the amount of memory assigned to the domain if a * balloon driver is in use or if the guest OS does not initialize all * assigned pages. This value is expressed in kB. *</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_AVAILABLE" id="VIR_DOMAIN_MEMORY_STAT_AVAILABLE">VIR_DOMAIN_MEMORY_STAT_AVAILABLE</a></td><td> = </td><td>5</td><td> : * The number of statistics supported by this version of the interface. * To add new statistics, add them to the enum and increase this value. *</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_STAT_NR" id="VIR_DOMAIN_MEMORY_STAT_NR">VIR_DOMAIN_MEMORY_STAT_NR</a></td><td> = </td><td>6</td></tr></table><pre>}
</pre></div><h3><a name="virDomainMigrateFlags" id="virDomainMigrateFlags"><code>virDomainMigrateFlags</code></a></h3><div class="api"><pre>enum virDomainMigrateFlags {
</pre><table><tr><td><a name="VIR_MIGRATE_LIVE" id="VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a></td><td> = </td><td>1</td><td> : live migration</td></tr><tr><td><a name="VIR_MIGRATE_PEER2PEER" id="VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a></td><td> = </td><td>2</td><td> : direct source -&gt; dest host control channel Note the less-common spelling that we're stuck with: <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> should be VIR_MIGRATE_TUNNELED</td></tr><tr><td><a name="VIR_MIGRATE_TUNNELLED" id="VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a></td><td> = </td><td>4</td><td> : tunnel migration data over libvirtd connection</td></tr><tr><td><a name="VIR_MIGRATE_PERSIST_DEST" id="VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a></td><td> = </td><td>8</td><td> : persist the VM on the destination</td></tr><tr><td><a name="VIR_MIGRATE_UNDEFINE_SOURCE" id="VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a></td><td> = </td><td>16</td><td> : undefine the VM on the source</td></tr><tr><td><a name="VIR_MIGRATE_PAUSED" id="VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a></td><td> = </td><td>32</td><td> : pause on remote side</td></tr><tr><td><a name="VIR_MIGRATE_NON_SHARED_DISK" id="VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a></td><td> = </td><td>64</td><td> : migration with non-shared storage with full disk copy</td></tr><tr><td><a name="VIR_MIGRATE_NON_SHARED_INC" id="VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a></td><td> = </td><td>128</td><td> : migration with non-shared storage with incremental copy (same base image shared between source and destination)</td></tr></table><pre>}
</pre></div><h3><a name="virDomainSnapshot" id="virDomainSnapshot"><code>virDomainSnapshot</code></a></h3><div class="api"><pre>struct virDomainSnapshot{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virDomainSnapshotDeleteFlags" id="virDomainSnapshotDeleteFlags"><code>virDomainSnapshotDeleteFlags</code></a></h3><div class="api"><pre>enum virDomainSnapshotDeleteFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN" id="VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN">VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virDomainState" id="virDomainState"><code>virDomainState</code></a></h3><div class="api"><pre>enum virDomainState {
</pre><table><tr><td><a name="VIR_DOMAIN_NOSTATE" id="VIR_DOMAIN_NOSTATE">VIR_DOMAIN_NOSTATE</a></td><td> = </td><td>0</td><td> : no state</td></tr><tr><td><a name="VIR_DOMAIN_RUNNING" id="VIR_DOMAIN_RUNNING">VIR_DOMAIN_RUNNING</a></td><td> = </td><td>1</td><td> : the domain is running</td></tr><tr><td><a name="VIR_DOMAIN_BLOCKED" id="VIR_DOMAIN_BLOCKED">VIR_DOMAIN_BLOCKED</a></td><td> = </td><td>2</td><td> : the domain is blocked on resource</td></tr><tr><td><a name="VIR_DOMAIN_PAUSED" id="VIR_DOMAIN_PAUSED">VIR_DOMAIN_PAUSED</a></td><td> = </td><td>3</td><td> : the domain is paused by user</td></tr><tr><td><a name="VIR_DOMAIN_SHUTDOWN" id="VIR_DOMAIN_SHUTDOWN">VIR_DOMAIN_SHUTDOWN</a></td><td> = </td><td>4</td><td> : the domain is being shut down</td></tr><tr><td><a name="VIR_DOMAIN_SHUTOFF" id="VIR_DOMAIN_SHUTOFF">VIR_DOMAIN_SHUTOFF</a></td><td> = </td><td>5</td><td> : the domain is shut off</td></tr><tr><td><a name="VIR_DOMAIN_CRASHED" id="VIR_DOMAIN_CRASHED">VIR_DOMAIN_CRASHED</a></td><td> = </td><td>6</td><td> : the domain is crashed</td></tr></table><pre>}
</pre></div><h3><a name="virDomainVcpuFlags" id="virDomainVcpuFlags"><code>virDomainVcpuFlags</code></a></h3><div class="api"><pre>enum virDomainVcpuFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_VCPU_LIVE" id="VIR_DOMAIN_VCPU_LIVE">VIR_DOMAIN_VCPU_LIVE</a></td><td> = </td><td>1</td><td> : Affect active domain</td></tr><tr><td><a name="VIR_DOMAIN_VCPU_CONFIG" id="VIR_DOMAIN_VCPU_CONFIG">VIR_DOMAIN_VCPU_CONFIG</a></td><td> = </td><td>2</td><td> : Affect next boot Additional flags to be bit-wise OR'd in</td></tr><tr><td><a name="VIR_DOMAIN_VCPU_MAXIMUM" id="VIR_DOMAIN_VCPU_MAXIMUM">VIR_DOMAIN_VCPU_MAXIMUM</a></td><td> = </td><td>4</td><td> : Max rather than current count</td></tr></table><pre>}
</pre></div><h3><a name="virDomainXMLFlags" id="virDomainXMLFlags"><code>virDomainXMLFlags</code></a></h3><div class="api"><pre>enum virDomainXMLFlags {
</pre><table><tr><td><a name="VIR_DOMAIN_XML_SECURE" id="VIR_DOMAIN_XML_SECURE">VIR_DOMAIN_XML_SECURE</a></td><td> = </td><td>1</td><td> : dump security sensitive information too</td></tr><tr><td><a name="VIR_DOMAIN_XML_INACTIVE" id="VIR_DOMAIN_XML_INACTIVE">VIR_DOMAIN_XML_INACTIVE</a></td><td> = </td><td>2</td><td> : dump inactive domain information</td></tr><tr><td><a name="VIR_DOMAIN_XML_UPDATE_CPU" id="VIR_DOMAIN_XML_UPDATE_CPU">VIR_DOMAIN_XML_UPDATE_CPU</a></td><td> = </td><td>4</td><td> : update guest CPU requirements according to host CPU</td></tr></table><pre>}
</pre></div><h3><a name="virEventHandleType" id="virEventHandleType"><code>virEventHandleType</code></a></h3><div class="api"><pre>enum virEventHandleType {
</pre><table><tr><td><a name="VIR_EVENT_HANDLE_READABLE" id="VIR_EVENT_HANDLE_READABLE">VIR_EVENT_HANDLE_READABLE</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_EVENT_HANDLE_WRITABLE" id="VIR_EVENT_HANDLE_WRITABLE">VIR_EVENT_HANDLE_WRITABLE</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_EVENT_HANDLE_ERROR" id="VIR_EVENT_HANDLE_ERROR">VIR_EVENT_HANDLE_ERROR</a></td><td> = </td><td>4</td></tr><tr><td><a name="VIR_EVENT_HANDLE_HANGUP" id="VIR_EVENT_HANDLE_HANGUP">VIR_EVENT_HANDLE_HANGUP</a></td><td> = </td><td>8</td></tr></table><pre>}
</pre></div><h3><a name="virInterface" id="virInterface"><code>virInterface</code></a></h3><div class="api"><pre>struct virInterface{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virInterfaceXMLFlags" id="virInterfaceXMLFlags"><code>virInterfaceXMLFlags</code></a></h3><div class="api"><pre>enum virInterfaceXMLFlags {
</pre><table><tr><td><a name="VIR_INTERFACE_XML_INACTIVE" id="VIR_INTERFACE_XML_INACTIVE">VIR_INTERFACE_XML_INACTIVE</a></td><td> = </td><td>1</td><td> : dump inactive interface information</td></tr></table><pre>}
</pre></div><h3><a name="virMemoryParameter" id="virMemoryParameter"><code>virMemoryParameter</code></a></h3><div class="api"><pre>struct virMemoryParameter{
</pre><table><tr><td>charfield[VIR_DOMAIN_MEMORY_FIELD_LENGTH]</td><td>field</td><td> : parameter name</td></tr><tr><td>int</td><td>type</td><td> : parameter type</td></tr></table><pre>
}
</pre></div><h3><a name="virMemoryParameterType" id="virMemoryParameterType"><code>virMemoryParameterType</code></a></h3><div class="api"><pre>enum virMemoryParameterType {
</pre><table><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_INT" id="VIR_DOMAIN_MEMORY_PARAM_INT">VIR_DOMAIN_MEMORY_PARAM_INT</a></td><td> = </td><td>1</td><td> : integer case</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_UINT" id="VIR_DOMAIN_MEMORY_PARAM_UINT">VIR_DOMAIN_MEMORY_PARAM_UINT</a></td><td> = </td><td>2</td><td> : unsigned integer case</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_LLONG" id="VIR_DOMAIN_MEMORY_PARAM_LLONG">VIR_DOMAIN_MEMORY_PARAM_LLONG</a></td><td> = </td><td>3</td><td> : long long case</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_ULLONG" id="VIR_DOMAIN_MEMORY_PARAM_ULLONG">VIR_DOMAIN_MEMORY_PARAM_ULLONG</a></td><td> = </td><td>4</td><td> : unsigned long long case</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_DOUBLE" id="VIR_DOMAIN_MEMORY_PARAM_DOUBLE">VIR_DOMAIN_MEMORY_PARAM_DOUBLE</a></td><td> = </td><td>5</td><td> : double case</td></tr><tr><td><a name="VIR_DOMAIN_MEMORY_PARAM_BOOLEAN" id="VIR_DOMAIN_MEMORY_PARAM_BOOLEAN">VIR_DOMAIN_MEMORY_PARAM_BOOLEAN</a></td><td> = </td><td>6</td><td> : boolean(character) case</td></tr></table><pre>}
</pre></div><h3><a name="virNWFilter" id="virNWFilter"><code>virNWFilter</code></a></h3><div class="api"><pre>struct virNWFilter{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virNetwork" id="virNetwork"><code>virNetwork</code></a></h3><div class="api"><pre>struct virNetwork{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virNodeDevice" id="virNodeDevice"><code>virNodeDevice</code></a></h3><div class="api"><pre>struct virNodeDevice{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virNodeInfo" id="virNodeInfo"><code>virNodeInfo</code></a></h3><div class="api"><pre>struct virNodeInfo{
</pre><table><tr><td>charmodel[32]</td><td>model</td><td> : string indicating the CPU model</td></tr><tr><td>unsigned long</td><td>memory</td><td> : memory size in kilobytes</td></tr><tr><td>unsigned int</td><td>cpus</td><td> : the number of active CPUs</td></tr><tr><td>unsigned int</td><td>mhz</td><td> : expected CPU frequency</td></tr><tr><td>unsigned int</td><td>nodes</td><td> : the number of NUMA cell, 1 for unusual NUMA topologies or uniform memory access; check capabilities XML for the actual NUMA topology</td></tr><tr><td>unsigned int</td><td>sockets</td><td> : number of CPU sockets per node if nodes &gt; 1, total number of CPU sockets otherwise</td></tr><tr><td>unsigned int</td><td>cores</td><td> : number of cores per socket</td></tr><tr><td>unsigned int</td><td>threads</td><td> : number of threads per core</td></tr></table><pre>
}
</pre></div><h3><a name="virSchedParameter" id="virSchedParameter"><code>virSchedParameter</code></a></h3><div class="api"><pre>struct virSchedParameter{
</pre><table><tr><td>charfield[VIR_DOMAIN_SCHED_FIELD_LENGTH]</td><td>field</td><td> : parameter name</td></tr><tr><td>int</td><td>type</td><td> : parameter type</td></tr></table><pre>
}
</pre></div><h3><a name="virSchedParameterType" id="virSchedParameterType"><code>virSchedParameterType</code></a></h3><div class="api"><pre>enum virSchedParameterType {
</pre><table><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_INT" id="VIR_DOMAIN_SCHED_FIELD_INT">VIR_DOMAIN_SCHED_FIELD_INT</a></td><td> = </td><td>1</td><td> : integer case</td></tr><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_UINT" id="VIR_DOMAIN_SCHED_FIELD_UINT">VIR_DOMAIN_SCHED_FIELD_UINT</a></td><td> = </td><td>2</td><td> : unsigned integer case</td></tr><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_LLONG" id="VIR_DOMAIN_SCHED_FIELD_LLONG">VIR_DOMAIN_SCHED_FIELD_LLONG</a></td><td> = </td><td>3</td><td> : long long case</td></tr><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_ULLONG" id="VIR_DOMAIN_SCHED_FIELD_ULLONG">VIR_DOMAIN_SCHED_FIELD_ULLONG</a></td><td> = </td><td>4</td><td> : unsigned long long case</td></tr><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_DOUBLE" id="VIR_DOMAIN_SCHED_FIELD_DOUBLE">VIR_DOMAIN_SCHED_FIELD_DOUBLE</a></td><td> = </td><td>5</td><td> : double case</td></tr><tr><td><a name="VIR_DOMAIN_SCHED_FIELD_BOOLEAN" id="VIR_DOMAIN_SCHED_FIELD_BOOLEAN">VIR_DOMAIN_SCHED_FIELD_BOOLEAN</a></td><td> = </td><td>6</td><td> : boolean(character) case</td></tr></table><pre>}
</pre></div><h3><a name="virSecret" id="virSecret"><code>virSecret</code></a></h3><div class="api"><pre>struct virSecret{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virSecretUsageType" id="virSecretUsageType"><code>virSecretUsageType</code></a></h3><div class="api"><pre>enum virSecretUsageType {
</pre><table><tr><td><a name="VIR_SECRET_USAGE_TYPE_NONE" id="VIR_SECRET_USAGE_TYPE_NONE">VIR_SECRET_USAGE_TYPE_NONE</a></td><td> = </td><td>0</td></tr><tr><td><a name="VIR_SECRET_USAGE_TYPE_VOLUME" id="VIR_SECRET_USAGE_TYPE_VOLUME">VIR_SECRET_USAGE_TYPE_VOLUME</a></td><td> = </td><td>1</td><td> : Expect more owner types later...</td></tr></table><pre>}
</pre></div><h3><a name="virSecurityLabel" id="virSecurityLabel"><code>virSecurityLabel</code></a></h3><div class="api"><pre>struct virSecurityLabel{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virSecurityModel" id="virSecurityModel"><code>virSecurityModel</code></a></h3><div class="api"><pre>struct virSecurityModel{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virStoragePool" id="virStoragePool"><code>virStoragePool</code></a></h3><div class="api"><pre>struct virStoragePool{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virStoragePoolBuildFlags" id="virStoragePoolBuildFlags"><code>virStoragePoolBuildFlags</code></a></h3><div class="api"><pre>enum virStoragePoolBuildFlags {
</pre><table><tr><td><a name="VIR_STORAGE_POOL_BUILD_NEW" id="VIR_STORAGE_POOL_BUILD_NEW">VIR_STORAGE_POOL_BUILD_NEW</a></td><td> = </td><td>0</td><td> : Regular build from scratch</td></tr><tr><td><a name="VIR_STORAGE_POOL_BUILD_REPAIR" id="VIR_STORAGE_POOL_BUILD_REPAIR">VIR_STORAGE_POOL_BUILD_REPAIR</a></td><td> = </td><td>1</td><td> : Repair / reinitialize</td></tr><tr><td><a name="VIR_STORAGE_POOL_BUILD_RESIZE" id="VIR_STORAGE_POOL_BUILD_RESIZE">VIR_STORAGE_POOL_BUILD_RESIZE</a></td><td> = </td><td>2</td><td> : Extend existing pool</td></tr></table><pre>}
</pre></div><h3><a name="virStoragePoolDeleteFlags" id="virStoragePoolDeleteFlags"><code>virStoragePoolDeleteFlags</code></a></h3><div class="api"><pre>enum virStoragePoolDeleteFlags {
</pre><table><tr><td><a name="VIR_STORAGE_POOL_DELETE_NORMAL" id="VIR_STORAGE_POOL_DELETE_NORMAL">VIR_STORAGE_POOL_DELETE_NORMAL</a></td><td> = </td><td>0</td><td> : Delete metadata only (fast)</td></tr><tr><td><a name="VIR_STORAGE_POOL_DELETE_ZEROED" id="VIR_STORAGE_POOL_DELETE_ZEROED">VIR_STORAGE_POOL_DELETE_ZEROED</a></td><td> = </td><td>1</td><td> : Clear all data to zeros (slow)</td></tr></table><pre>}
</pre></div><h3><a name="virStoragePoolInfo" id="virStoragePoolInfo"><code>virStoragePoolInfo</code></a></h3><div class="api"><pre>struct virStoragePoolInfo{
</pre><table><tr><td>int</td><td>state</td><td> : <a href="libvirt-libvirt.html#virStoragePoolState">virStoragePoolState</a> flags</td></tr><tr><td>unsigned long long</td><td>capacity</td><td> : Logical size bytes</td></tr><tr><td>unsigned long long</td><td>allocation</td><td> : Current allocation bytes</td></tr><tr><td>unsigned long long</td><td>available</td><td> : Remaining free space bytes</td></tr></table><pre>
}
</pre></div><h3><a name="virStoragePoolState" id="virStoragePoolState"><code>virStoragePoolState</code></a></h3><div class="api"><pre>enum virStoragePoolState {
</pre><table><tr><td><a name="VIR_STORAGE_POOL_INACTIVE" id="VIR_STORAGE_POOL_INACTIVE">VIR_STORAGE_POOL_INACTIVE</a></td><td> = </td><td>0</td><td> : Not running</td></tr><tr><td><a name="VIR_STORAGE_POOL_BUILDING" id="VIR_STORAGE_POOL_BUILDING">VIR_STORAGE_POOL_BUILDING</a></td><td> = </td><td>1</td><td> : Initializing pool, not available</td></tr><tr><td><a name="VIR_STORAGE_POOL_RUNNING" id="VIR_STORAGE_POOL_RUNNING">VIR_STORAGE_POOL_RUNNING</a></td><td> = </td><td>2</td><td> : Running normally</td></tr><tr><td><a name="VIR_STORAGE_POOL_DEGRADED" id="VIR_STORAGE_POOL_DEGRADED">VIR_STORAGE_POOL_DEGRADED</a></td><td> = </td><td>3</td><td> : Running degraded</td></tr><tr><td><a name="VIR_STORAGE_POOL_INACCESSIBLE" id="VIR_STORAGE_POOL_INACCESSIBLE">VIR_STORAGE_POOL_INACCESSIBLE</a></td><td> = </td><td>4</td><td> : Running, but not accessible</td></tr></table><pre>}
</pre></div><h3><a name="virStorageVol" id="virStorageVol"><code>virStorageVol</code></a></h3><div class="api"><pre>struct virStorageVol{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virStorageVolDeleteFlags" id="virStorageVolDeleteFlags"><code>virStorageVolDeleteFlags</code></a></h3><div class="api"><pre>enum virStorageVolDeleteFlags {
</pre><table><tr><td><a name="VIR_STORAGE_VOL_DELETE_NORMAL" id="VIR_STORAGE_VOL_DELETE_NORMAL">VIR_STORAGE_VOL_DELETE_NORMAL</a></td><td> = </td><td>0</td><td> : Delete metadata only (fast)</td></tr><tr><td><a name="VIR_STORAGE_VOL_DELETE_ZEROED" id="VIR_STORAGE_VOL_DELETE_ZEROED">VIR_STORAGE_VOL_DELETE_ZEROED</a></td><td> = </td><td>1</td><td> : Clear all data to zeros (slow)</td></tr></table><pre>}
</pre></div><h3><a name="virStorageVolInfo" id="virStorageVolInfo"><code>virStorageVolInfo</code></a></h3><div class="api"><pre>struct virStorageVolInfo{
</pre><table><tr><td>int</td><td>type</td><td> : <a href="libvirt-libvirt.html#virStorageVolType">virStorageVolType</a> flags</td></tr><tr><td>unsigned long long</td><td>capacity</td><td> : Logical size bytes</td></tr><tr><td>unsigned long long</td><td>allocation</td><td> : Current allocation bytes</td></tr></table><pre>
}
</pre></div><h3><a name="virStorageVolType" id="virStorageVolType"><code>virStorageVolType</code></a></h3><div class="api"><pre>enum virStorageVolType {
</pre><table><tr><td><a name="VIR_STORAGE_VOL_FILE" id="VIR_STORAGE_VOL_FILE">VIR_STORAGE_VOL_FILE</a></td><td> = </td><td>0</td><td> : Regular file based volumes</td></tr><tr><td><a name="VIR_STORAGE_VOL_BLOCK" id="VIR_STORAGE_VOL_BLOCK">VIR_STORAGE_VOL_BLOCK</a></td><td> = </td><td>1</td><td> : Block based volumes</td></tr></table><pre>}
</pre></div><h3><a name="virStream" id="virStream"><code>virStream</code></a></h3><div class="api"><pre>struct virStream{
</pre><table><tr><td colspan="3">The content of this structure is not made public by the API</td></tr></table><pre>
}
</pre></div><h3><a name="virStreamEventType" id="virStreamEventType"><code>virStreamEventType</code></a></h3><div class="api"><pre>enum virStreamEventType {
</pre><table><tr><td><a name="VIR_STREAM_EVENT_READABLE" id="VIR_STREAM_EVENT_READABLE">VIR_STREAM_EVENT_READABLE</a></td><td> = </td><td>1</td></tr><tr><td><a name="VIR_STREAM_EVENT_WRITABLE" id="VIR_STREAM_EVENT_WRITABLE">VIR_STREAM_EVENT_WRITABLE</a></td><td> = </td><td>2</td></tr><tr><td><a name="VIR_STREAM_EVENT_ERROR" id="VIR_STREAM_EVENT_ERROR">VIR_STREAM_EVENT_ERROR</a></td><td> = </td><td>4</td></tr><tr><td><a name="VIR_STREAM_EVENT_HANGUP" id="VIR_STREAM_EVENT_HANGUP">VIR_STREAM_EVENT_HANGUP</a></td><td> = </td><td>8</td></tr></table><pre>}
</pre></div><h3><a name="virStreamFlags" id="virStreamFlags"><code>virStreamFlags</code></a></h3><div class="api"><pre>enum virStreamFlags {
</pre><table><tr><td><a name="VIR_STREAM_NONBLOCK" id="VIR_STREAM_NONBLOCK">VIR_STREAM_NONBLOCK</a></td><td> = </td><td>1</td></tr></table><pre>}
</pre></div><h3><a name="virVcpuInfo" id="virVcpuInfo"><code>virVcpuInfo</code></a></h3><div class="api"><pre>struct virVcpuInfo{
</pre><table><tr><td>unsigned int</td><td>number</td><td> : virtual CPU number</td></tr><tr><td>int</td><td>state</td><td> : value from <a href="libvirt-libvirt.html#virVcpuState">virVcpuState</a></td></tr><tr><td>unsigned long long</td><td>cpuTime</td><td> : CPU time used, in nanoseconds</td></tr><tr><td>int</td><td>cpu</td><td> : real CPU number, or -1 if offline</td></tr></table><pre>
}
</pre></div><h3><a name="virVcpuState" id="virVcpuState"><code>virVcpuState</code></a></h3><div class="api"><pre>enum virVcpuState {
</pre><table><tr><td><a name="VIR_VCPU_OFFLINE" id="VIR_VCPU_OFFLINE">VIR_VCPU_OFFLINE</a></td><td> = </td><td>0</td><td> : the virtual CPU is offline</td></tr><tr><td><a name="VIR_VCPU_RUNNING" id="VIR_VCPU_RUNNING">VIR_VCPU_RUNNING</a></td><td> = </td><td>1</td><td> : the virtual CPU is running</td></tr><tr><td><a name="VIR_VCPU_BLOCKED" id="VIR_VCPU_BLOCKED">VIR_VCPU_BLOCKED</a></td><td> = </td><td>2</td><td> : the virtual CPU is blocked on resource</td></tr></table><pre>}
</pre></div><h3><a name="functions" id="functions">Functions</a></h3><h3><a name="virConnectAuthCallbackPtr" id="virConnectAuthCallbackPtr"><code>virConnectAuthCallbackPtr</code></a></h3><pre class="programlisting">typedef int	(*virConnectAuthCallbackPtr)	(<a href="libvirt-libvirt.html#virConnectCredentialPtr">virConnectCredentialPtr</a> cred, <br />					 unsigned int ncred, <br />					 void * cbdata)
</pre><p>When authentication requires one or more interactions, this callback
is invoked. For each interaction supplied, data must be gathered
from the user and filled in to the 'result' and 'resultlen' fields.
If an interaction can not be filled, fill in NULL and 0.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cred</tt></i>:</span></td><td>list of <a href="libvirt-libvirt.html#virConnectCredential">virConnectCredential</a> object to fetch from user</td></tr><tr><td><span class="term"><i><tt>ncred</tt></i>:</span></td><td>size of cred list</td></tr><tr><td><span class="term"><i><tt>cbdata</tt></i>:</span></td><td>opaque data passed to <a href="libvirt-libvirt.html#virConnectOpenAuth">virConnectOpenAuth</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if all interactions were filled, or -1 upon error</td></tr></tbody></table></div><br /><h3><a name="virConnectBaselineCPU" id="virConnectBaselineCPU"><code>virConnectBaselineCPU</code></a></h3><pre class="programlisting">char *	virConnectBaselineCPU		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char ** xmlCPUs, <br />					 unsigned int ncpus, <br />					 unsigned int flags)<br />
</pre><p>Computes the most feature-rich CPU which is compatible with all given
host CPUs.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>xmlCPUs</tt></i>:</span></td><td>array of XML descriptions of host CPUs</td></tr><tr><td><span class="term"><i><tt>ncpus</tt></i>:</span></td><td>number of CPUs in xmlCPUs</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>fine-tuning flags, currently unused, pass 0.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>XML description of the computed CPU or NULL on error.</td></tr></tbody></table></div><h3><a name="virConnectClose" id="virConnectClose"><code>virConnectClose</code></a></h3><pre class="programlisting">int	virConnectClose			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>This function closes the connection to the Hypervisor. This should
not be called if further interaction with the Hypervisor are needed
especially if there is running domain which need further monitoring by
the application.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of error.</td></tr></tbody></table></div><h3><a name="virConnectCompareCPU" id="virConnectCompareCPU"><code>virConnectCompareCPU</code></a></h3><pre class="programlisting">int	virConnectCompareCPU		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xmlDesc, <br />					 unsigned int flags)<br />
</pre><p>Compares the given CPU description with the host CPU</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>XML describing the CPU to compare with host CPU</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>comparison result according to enum <a href="libvirt-libvirt.html#virCPUCompareResult">virCPUCompareResult</a></td></tr></tbody></table></div><h3><a name="virConnectDomainEventCallback" id="virConnectDomainEventCallback"><code>virConnectDomainEventCallback</code></a></h3><pre class="programlisting">typedef int	(*virConnectDomainEventCallback)	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 int event, <br />					 int detail, <br />					 void * opaque)
</pre><p>A callback function to be registered, and called when a domain event occurs</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>The domain on which the event occured</td></tr><tr><td><span class="term"><i><tt>event</tt></i>:</span></td><td>The specfic <a href="libvirt-libvirt.html#virDomainEventType">virDomainEventType</a> which occured</td></tr><tr><td><span class="term"><i><tt>detail</tt></i>:</span></td><td>event specific detail information</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque user data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td></td></tr></tbody></table></div><br /><h3><a name="virConnectDomainEventDeregister" id="virConnectDomainEventDeregister"><code>virConnectDomainEventDeregister</code></a></h3><pre class="programlisting">int	virConnectDomainEventDeregister	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 <a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb)<br />
</pre><p>Removes a callback previously registered with the virConnectDomainEventRegister
funtion.

Use of this method is no longer recommended. Instead applications
should try virConnectDomainEventUnregisterAny which has a more flexible
API contract</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to the function handling domain events</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div><h3><a name="virConnectDomainEventDeregisterAny" id="virConnectDomainEventDeregisterAny"><code>virConnectDomainEventDeregisterAny</code></a></h3><pre class="programlisting">int	virConnectDomainEventDeregisterAny	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 int callbackID)<br />
</pre><p>Removes an event callback. The callbackID parameter should be the
vaule obtained from a previous virDomainEventRegisterAny method.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>callbackID</tt></i>:</span></td><td>the callback identifier</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div><h3><a name="virConnectDomainEventGenericCallback" id="virConnectDomainEventGenericCallback"><code>virConnectDomainEventGenericCallback</code></a></h3><pre class="programlisting">typedef void	(*virConnectDomainEventGenericCallback)	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 void * opaque)
</pre><p>A generic domain event callback handler. Specific events usually
have a customization with extra parameters</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>the connection pointer</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>the domain pointer</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div><br /><h3><a name="virConnectDomainEventGraphicsCallback" id="virConnectDomainEventGraphicsCallback"><code>virConnectDomainEventGraphicsCallback</code></a></h3><pre class="programlisting">typedef void	(*virConnectDomainEventGraphicsCallback)	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 int phase, <br />						 <a href="libvirt-libvirt.html#virDomainEventGraphicsAddressPtr">virDomainEventGraphicsAddressPtr</a> local, <br />						 <a href="libvirt-libvirt.html#virDomainEventGraphicsAddressPtr">virDomainEventGraphicsAddressPtr</a> remote, <br />						 const char * authScheme, <br />						 <a href="libvirt-libvirt.html#virDomainEventGraphicsSubjectPtr">virDomainEventGraphicsSubjectPtr</a> subject, <br />						 void * opaque)
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_GRAPHICS with virConnectDomainEventRegisterAny()</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>phase</tt></i>:</span></td><td>the phase of the connection</td></tr><tr><td><span class="term"><i><tt>local</tt></i>:</span></td><td>the local server address</td></tr><tr><td><span class="term"><i><tt>remote</tt></i>:</span></td><td>the remote client address</td></tr><tr><td><span class="term"><i><tt>authScheme</tt></i>:</span></td><td>the authentication scheme activated</td></tr><tr><td><span class="term"><i><tt>subject</tt></i>:</span></td><td>the authenticated subject (user)</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div><br /><h3><a name="virConnectDomainEventIOErrorCallback" id="virConnectDomainEventIOErrorCallback"><code>virConnectDomainEventIOErrorCallback</code></a></h3><pre class="programlisting">typedef void	(*virConnectDomainEventIOErrorCallback)	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 const char * srcPath, <br />						 const char * devAlias, <br />						 int action, <br />						 void * opaque)
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_IO_ERROR with virConnectDomainEventRegisterAny()</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>srcPath</tt></i>:</span></td><td>The host file on which the IO error occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>The guest device alias associated with the path</td></tr><tr><td><span class="term"><i><tt>action</tt></i>:</span></td><td>action that is to be taken due to the IO error</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div><br /><h3><a name="virConnectDomainEventIOErrorReasonCallback" id="virConnectDomainEventIOErrorReasonCallback"><code>virConnectDomainEventIOErrorReasonCallback</code></a></h3><pre class="programlisting">typedef void	(*virConnectDomainEventIOErrorReasonCallback)	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />							 const char * srcPath, <br />							 const char * devAlias, <br />							 int action, <br />							 const char * reason, <br />							 void * opaque)
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_IO_ERROR with virConnectDomainEventRegisterAny()</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>srcPath</tt></i>:</span></td><td>The host file on which the IO error occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>The guest device alias associated with the path</td></tr><tr><td><span class="term"><i><tt>action</tt></i>:</span></td><td>action that is to be taken due to the IO error</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>the cause of the IO error</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div><br /><h3><a name="virConnectDomainEventRTCChangeCallback" id="virConnectDomainEventRTCChangeCallback"><code>virConnectDomainEventRTCChangeCallback</code></a></h3><pre class="programlisting">typedef void	(*virConnectDomainEventRTCChangeCallback)	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 long long utcoffset, <br />						 void * opaque)
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_RTC_CHANGE with virConnectDomainEventRegisterAny()</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>utcoffset</tt></i>:</span></td><td>the new RTC offset from UTC, measured in seconds</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div><br /><h3><a name="virConnectDomainEventRegister" id="virConnectDomainEventRegister"><code>virConnectDomainEventRegister</code></a></h3><pre class="programlisting">int	virConnectDomainEventRegister	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 <a href="libvirt-libvirt.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb, <br />					 void * opaque, <br />					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> freecb)<br />
</pre><p>Adds a callback to receive notifications of domain lifecycle events
occurring on a connection

Use of this method is no longer recommended. Instead applications
should try <a href="libvirt-libvirt.html#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a> which has a more flexible
API contract

The <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the domain object after the callback</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to the function handling domain events</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque data to pass on to the callback</td></tr><tr><td><span class="term"><i><tt>freecb</tt></i>:</span></td><td>optional function to deallocate opaque when not used anymore</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>it shall take a reference to it, by calling virDomainRef. The reference can be released once the object is no longer required by calling virDomainFree. Returns 0 on success, -1 on failure</td></tr></tbody></table></div><h3><a name="virConnectDomainEventRegisterAny" id="virConnectDomainEventRegisterAny"><code>virConnectDomainEventRegisterAny</code></a></h3><pre class="programlisting">int	virConnectDomainEventRegisterAny	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 int eventID, <br />						 <a href="libvirt-libvirt.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a> cb, <br />						 void * opaque, <br />						 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> freecb)<br />
</pre><p>Adds a callback to receive notifications of arbitrary domain events
occurring on a domain.

If dom is NULL, then events will be monitored for any domain. If dom
is non-NULL, then only the specific domain will be monitored

Most types of event have a callback providing a custom set of parameters
for the event. When registering an event, it is thus neccessary to use
the VIR_DOMAIN_EVENT_CALLBACK() macro to cast the supplied function pointer
to match the signature of this method.

The <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the domain object after the callback</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>eventID</tt></i>:</span></td><td>the event type to receive</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to the function handling domain events</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque data to pass on to the callback</td></tr><tr><td><span class="term"><i><tt>freecb</tt></i>:</span></td><td>optional function to deallocate opaque when not used anymore</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>it shall take a reference to it, by calling virDomainRef. The reference can be released once the object is no longer required by calling virDomainFree. The return value from this method is a positive integer identifier for the callback. To unregister a callback, this callback ID should be passed to the virDomainEventUnregisterAny method Returns a callback identifier on success, -1 on failure</td></tr></tbody></table></div><h3><a name="virConnectDomainEventWatchdogCallback" id="virConnectDomainEventWatchdogCallback"><code>virConnectDomainEventWatchdogCallback</code></a></h3><pre class="programlisting">typedef void	(*virConnectDomainEventWatchdogCallback)	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />						 int action, <br />						 void * opaque)
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_WATCHDOG with virConnectDomainEventRegisterAny()</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>action</tt></i>:</span></td><td>action that is to be taken due to watchdog firing</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div><br /><h3><a name="virConnectDomainXMLFromNative" id="virConnectDomainXMLFromNative"><code>virConnectDomainXMLFromNative</code></a></h3><pre class="programlisting">char *	virConnectDomainXMLFromNative	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * nativeFormat, <br />					 const char * nativeConfig, <br />					 unsigned int flags)<br />
</pre><p>Reads native configuration data describing a domain, and
generates libvirt domain XML. The format of the native
data is hypervisor dependant.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>a connection object</td></tr><tr><td><span class="term"><i><tt>nativeFormat</tt></i>:</span></td><td>configuration format importing from</td></tr><tr><td><span class="term"><i><tt>nativeConfig</tt></i>:</span></td><td>the configuration data to import</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div><h3><a name="virConnectDomainXMLToNative" id="virConnectDomainXMLToNative"><code>virConnectDomainXMLToNative</code></a></h3><pre class="programlisting">char *	virConnectDomainXMLToNative	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * nativeFormat, <br />					 const char * domainXml, <br />					 unsigned int flags)<br />
</pre><p>Reads a domain XML configuration document, and generates
a native configuration file describing the domain.
The format of the native data is hypervisor dependant.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>a connection object</td></tr><tr><td><span class="term"><i><tt>nativeFormat</tt></i>:</span></td><td>configuration format exporting to</td></tr><tr><td><span class="term"><i><tt>domainXml</tt></i>:</span></td><td>the domain configuration to export</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded native config datafile, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div><h3><a name="virConnectFindStoragePoolSources" id="virConnectFindStoragePoolSources"><code>virConnectFindStoragePoolSources</code></a></h3><pre class="programlisting">char *	virConnectFindStoragePoolSources	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * type, <br />						 const char * srcSpec, <br />						 unsigned int flags)<br />
</pre><p>Talks to a storage backend and attempts to auto-discover the set of
available storage pool sources. e.g. For iSCSI this would be a set of
iSCSI targets. For NFS this would be a list of exported paths. The
srcSpec (optional for some storage pool types, e.g. local ones) is
an instance of the storage pool's source element specifying where
to look for the pools.

srcSpec is not required for some types (e.g., those querying
local storage resources only)</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>type of storage pool sources to discover</td></tr><tr><td><span class="term"><i><tt>srcSpec</tt></i>:</span></td><td>XML document specifying discovery source</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags for discovery (unused, pass 0)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>an xml document consisting of a SourceList element containing a source document appropriate to the given pool type for each discovered source.</td></tr></tbody></table></div><h3><a name="virConnectGetCapabilities" id="virConnectGetCapabilities"><code>virConnectGetCapabilities</code></a></h3><pre class="programlisting">char *	virConnectGetCapabilities	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Provides capabilities of the hypervisor / driver.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, or an XML string defining the capabilities. The client must free the returned string after use.</td></tr></tbody></table></div><h3><a name="virConnectGetHostname" id="virConnectGetHostname"><code>virConnectGetHostname</code></a></h3><pre class="programlisting">char *	virConnectGetHostname		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>This returns the system hostname on which the hypervisor is
running (the result of the gethostname system call). If
we are connected to a remote system, then this returns the
hostname of the remote system.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to a hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the hostname which must be freed by the caller, or NULL if there was an error.</td></tr></tbody></table></div><h3><a name="virConnectGetLibVersion" id="virConnectGetLibVersion"><code>virConnectGetLibVersion</code></a></h3><pre class="programlisting">int	virConnectGetLibVersion		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 unsigned long * libVer)<br />
</pre><p>Provides @libVer, which is the version of libvirt used by the
 daemon running on the @conn host</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>libVer</tt></i>:</span></td><td>returns the libvirt library version used on the connection (OUT)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 otherwise, and values for @libVer have the format major * 1,000,000 + minor * 1,000 + release.</td></tr></tbody></table></div><h3><a name="virConnectGetMaxVcpus" id="virConnectGetMaxVcpus"><code>virConnectGetMaxVcpus</code></a></h3><pre class="programlisting">int	virConnectGetMaxVcpus		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * type)<br />
</pre><p>Provides the maximum number of virtual CPUs supported for a guest VM of a
specific type. The 'type' parameter here corresponds to the 'type'
attribute in the &lt;domain&gt; element of the XML.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>value of the 'type' attribute in the &lt;domain&gt; element</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the maximum of virtual CPU or -1 in case of error.</td></tr></tbody></table></div><h3><a name="virConnectGetSysinfo" id="virConnectGetSysinfo"><code>virConnectGetSysinfo</code></a></h3><pre class="programlisting">char *	virConnectGetSysinfo		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 unsigned int flags)<br />
</pre><p>This returns the XML description of the sysinfo details for the
host on which the hypervisor is running, in the same format as the
&lt;sysinfo&gt; element of a domain XML. This information is generally
available only for hypervisors running with root privileges.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to a hypervisor connection</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the XML string which must be freed by the caller, or NULL if there was an error.</td></tr></tbody></table></div><h3><a name="virConnectGetType" id="virConnectGetType"><code>virConnectGetType</code></a></h3><pre class="programlisting">const char *	virConnectGetType	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Get the name of the Hypervisor software used.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, a static zero terminated string otherwise. See also: http://www.redhat.com/archives/libvir-list/2007-February/msg00096.html</td></tr></tbody></table></div><h3><a name="virConnectGetURI" id="virConnectGetURI"><code>virConnectGetURI</code></a></h3><pre class="programlisting">char *	virConnectGetURI		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>This returns the URI (name) of the hypervisor connection.
Normally this is the same as or similar to the string passed
to the virConnectOpen/virConnectOpenReadOnly call, but
the driver may make the URI canonical. If name == NULL
was passed to virConnectOpen, then the driver will return
a non-NULL URI which can be used to connect to the same
hypervisor later.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to a hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the URI string which must be freed by the caller, or NULL if there was an error.</td></tr></tbody></table></div><h3><a name="virConnectGetVersion" id="virConnectGetVersion"><code>virConnectGetVersion</code></a></h3><pre class="programlisting">int	virConnectGetVersion		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 unsigned long * hvVer)<br />
</pre><p>Get the version level of the Hypervisor running. This may work only with
hypervisor call, i.e. with privileged access to the hypervisor, not
with a Read-Only connection.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>hvVer</tt></i>:</span></td><td>return value for the version of the running hypervisor (OUT)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 otherwise. if the version can't be extracted by lack of capacities returns 0 and @hvVer is 0, otherwise @hvVer value is major * 1,000,000 + minor * 1,000 + release</td></tr></tbody></table></div><h3><a name="virConnectIsEncrypted" id="virConnectIsEncrypted"><code>virConnectIsEncrypted</code></a></h3><pre class="programlisting">int	virConnectIsEncrypted		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Determine if the connection to the hypervisor is encrypted</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if encrypted, 0 if not encrypted, -1 on error</td></tr></tbody></table></div><h3><a name="virConnectIsSecure" id="virConnectIsSecure"><code>virConnectIsSecure</code></a></h3><pre class="programlisting">int	virConnectIsSecure		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Determine if the connection to the hypervisor is secure

A connection will be classed as secure if it is either
encrypted, or running over a channel which is not exposed
to eavesdropping (eg a UNIX domain socket, or pipe)</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if secure, 0 if secure, -1 on error</td></tr></tbody></table></div><h3><a name="virConnectListDefinedDomains" id="virConnectListDefinedDomains"><code>virConnectListDefinedDomains</code></a></h3><pre class="programlisting">int	virConnectListDefinedDomains	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)<br />
</pre><p>list the defined but inactive domains, stores the pointers to the names
in @names</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>pointer to an array to store the names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of the array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of names provided in the array or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectListDefinedInterfaces" id="virConnectListDefinedInterfaces"><code>virConnectListDefinedInterfaces</code></a></h3><pre class="programlisting">int	virConnectListDefinedInterfaces	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)<br />
</pre><p>Collect the list of defined (inactive) physical host interfaces,
and store their names in @names.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of interfaces</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of interfaces found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectListDefinedNetworks" id="virConnectListDefinedNetworks"><code>virConnectListDefinedNetworks</code></a></h3><pre class="programlisting">int	virConnectListDefinedNetworks	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)<br />
</pre><p>list the inactive networks, stores the pointers to the names in @names</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>pointer to an array to store the names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of the array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of names provided in the array or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectListDefinedStoragePools" id="virConnectListDefinedStoragePools"><code>virConnectListDefinedStoragePools</code></a></h3><pre class="programlisting">int	virConnectListDefinedStoragePools	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 char ** const names, <br />						 int maxnames)<br />
</pre><p>Provides the list of names of inactive storage pools
upto maxnames. If there are more than maxnames, the
remaining names will be silently ignored.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array of char * to fill with pool names (allocated by caller)</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of the names array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error</td></tr></tbody></table></div><h3><a name="virConnectListDomains" id="virConnectListDomains"><code>virConnectListDomains</code></a></h3><pre class="programlisting">int	virConnectListDomains		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 int * ids, <br />					 int maxids)<br />
</pre><p>Collect the list of active domains, and store their ID in @maxids</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>ids</tt></i>:</span></td><td>array to collect the list of IDs of active domains</td></tr><tr><td><span class="term"><i><tt>maxids</tt></i>:</span></td><td>size of @ids</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectListInterfaces" id="virConnectListInterfaces"><code>virConnectListInterfaces</code></a></h3><pre class="programlisting">int	virConnectListInterfaces	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)<br />
</pre><p>Collect the list of active physical host interfaces,
and store their names in @names</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of interfaces</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of interfaces found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectListNWFilters" id="virConnectListNWFilters"><code>virConnectListNWFilters</code></a></h3><pre class="programlisting">int	virConnectListNWFilters		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)<br />
</pre><p>Collect the list of network filters, and store their names in @names</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of network filters</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of network filters found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectListNetworks" id="virConnectListNetworks"><code>virConnectListNetworks</code></a></h3><pre class="programlisting">int	virConnectListNetworks		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)<br />
</pre><p>Collect the list of active networks, and store their names in @names</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of active networks</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of networks found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectListSecrets" id="virConnectListSecrets"><code>virConnectListSecrets</code></a></h3><pre class="programlisting">int	virConnectListSecrets		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** uuids, <br />					 int maxuuids)<br />
</pre><p>List UUIDs of defined secrets, store pointers to names in uuids.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>uuids</tt></i>:</span></td><td>Pointer to an array to store the UUIDs</td></tr><tr><td><span class="term"><i><tt>maxuuids</tt></i>:</span></td><td>size of the array.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of UUIDs provided in the array, or -1 on failure.</td></tr></tbody></table></div><h3><a name="virConnectListStoragePools" id="virConnectListStoragePools"><code>virConnectListStoragePools</code></a></h3><pre class="programlisting">int	virConnectListStoragePools	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 char ** const names, <br />					 int maxnames)<br />
</pre><p>Provides the list of names of active storage pools
upto maxnames. If there are more than maxnames, the
remaining names will be silently ignored.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array of char * to fill with pool names (allocated by caller)</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of the names array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error</td></tr></tbody></table></div><h3><a name="virConnectNumOfDefinedDomains" id="virConnectNumOfDefinedDomains"><code>virConnectNumOfDefinedDomains</code></a></h3><pre class="programlisting">int	virConnectNumOfDefinedDomains	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Provides the number of defined but inactive domains.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectNumOfDefinedInterfaces" id="virConnectNumOfDefinedInterfaces"><code>virConnectNumOfDefinedInterfaces</code></a></h3><pre class="programlisting">int	virConnectNumOfDefinedInterfaces	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Provides the number of defined (inactive) interfaces on the physical host.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of defined interface found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectNumOfDefinedNetworks" id="virConnectNumOfDefinedNetworks"><code>virConnectNumOfDefinedNetworks</code></a></h3><pre class="programlisting">int	virConnectNumOfDefinedNetworks	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Provides the number of inactive networks.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of networks found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectNumOfDefinedStoragePools" id="virConnectNumOfDefinedStoragePools"><code>virConnectNumOfDefinedStoragePools</code></a></h3><pre class="programlisting">int	virConnectNumOfDefinedStoragePools	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Provides the number of inactive storage pools</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of pools found, or -1 on error</td></tr></tbody></table></div><h3><a name="virConnectNumOfDomains" id="virConnectNumOfDomains"><code>virConnectNumOfDomains</code></a></h3><pre class="programlisting">int	virConnectNumOfDomains		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Provides the number of active domains.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectNumOfInterfaces" id="virConnectNumOfInterfaces"><code>virConnectNumOfInterfaces</code></a></h3><pre class="programlisting">int	virConnectNumOfInterfaces	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Provides the number of active interfaces on the physical host.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of active interfaces found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectNumOfNWFilters" id="virConnectNumOfNWFilters"><code>virConnectNumOfNWFilters</code></a></h3><pre class="programlisting">int	virConnectNumOfNWFilters	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Provides the number of nwfilters.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of nwfilters found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectNumOfNetworks" id="virConnectNumOfNetworks"><code>virConnectNumOfNetworks</code></a></h3><pre class="programlisting">int	virConnectNumOfNetworks		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Provides the number of active networks.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of network found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virConnectNumOfSecrets" id="virConnectNumOfSecrets"><code>virConnectNumOfSecrets</code></a></h3><pre class="programlisting">int	virConnectNumOfSecrets		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Fetch number of currently defined secrets.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number currently defined secrets.</td></tr></tbody></table></div><h3><a name="virConnectNumOfStoragePools" id="virConnectNumOfStoragePools"><code>virConnectNumOfStoragePools</code></a></h3><pre class="programlisting">int	virConnectNumOfStoragePools	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Provides the number of active storage pools</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of pools found, or -1 on error</td></tr></tbody></table></div><h3><a name="virConnectOpen" id="virConnectOpen"><code>virConnectOpen</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virConnectOpen		(const char * name)<br />
</pre><p>This function should be called first to get a connection to the
Hypervisor and xen store</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>URI of the hypervisor</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the hypervisor connection or NULL in case of error If @name is NULL then probing will be done to determine a suitable default driver to activate. This involves trying each hypervisor in turn until one successfully opens. If the LIBVIRT_DEFAULT_URI environment variable is set, then it will be used in preference to probing for a driver. If connecting to an unprivileged hypervisor driver which requires the libvirtd daemon to be active, it will automatically be launched if not already running. This can be prevented by setting the environment variable LIBVIRT_AUTOSTART=0 URIs are documented at http://libvirt.org/uri.html</td></tr></tbody></table></div><h3><a name="virConnectOpenAuth" id="virConnectOpenAuth"><code>virConnectOpenAuth</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virConnectOpenAuth	(const char * name, <br />					 <a href="libvirt-libvirt.html#virConnectAuthPtr">virConnectAuthPtr</a> auth, <br />					 int flags)<br />
</pre><p>This function should be called first to get a connection to the
Hypervisor. If necessary, authentication will be performed fetching
credentials via the callback

See <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a> for notes about environment variables which can
have an effect on opening drivers</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>URI of the hypervisor</td></tr><tr><td><span class="term"><i><tt>auth</tt></i>:</span></td><td>Authenticate callback parameters</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>Open flags</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the hypervisor connection or NULL in case of error URIs are documented at http://libvirt.org/uri.html</td></tr></tbody></table></div><h3><a name="virConnectOpenReadOnly" id="virConnectOpenReadOnly"><code>virConnectOpenReadOnly</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virConnectOpenReadOnly	(const char * name)<br />
</pre><p>This function should be called first to get a restricted connection to the
library functionalities. The set of APIs usable are then restricted
on the available methods to control the domains.

See <a href="libvirt-libvirt.html#virConnectOpen">virConnectOpen</a> for notes about environment variables which can
have an effect on opening drivers</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>URI of the hypervisor</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the hypervisor connection or NULL in case of error URIs are documented at http://libvirt.org/uri.html</td></tr></tbody></table></div><h3><a name="virConnectRef" id="virConnectRef"><code>virConnectRef</code></a></h3><pre class="programlisting">int	virConnectRef			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>Increment the reference count on the connection. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virConnectClose">virConnectClose</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a connection would increment
the reference count.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>the connection to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure</td></tr></tbody></table></div><h3><a name="virDomainAbortJob" id="virDomainAbortJob"><code>virDomainAbortJob</code></a></h3><pre class="programlisting">int	virDomainAbortJob		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Requests that the current background job be aborted at the
soonest opportunity. This will block until the job has
either completed, or aborted.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainAttachDevice" id="virDomainAttachDevice"><code>virDomainAttachDevice</code></a></h3><pre class="programlisting">int	virDomainAttachDevice		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * xml)<br />
</pre><p>Create a virtual device attachment to backend. This function,
having hotplug semantics, is only allowed on an active domain.

For compatibility, this method can also be used to change the media
in an existing CDROM/Floppy device, however, applications are
recommended to use the virDomainUpdateDeviceFlag method instead.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainAttachDeviceFlags" id="virDomainAttachDeviceFlags"><code>virDomainAttachDeviceFlags</code></a></h3><pre class="programlisting">int	virDomainAttachDeviceFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * xml, <br />					 unsigned int flags)<br />
</pre><p>Attach a virtual device to a domain, using the flags parameter
to control how the device is attached. VIR_DOMAIN_DEVICE_MODIFY_CURRENT
specifies that the device allocation is made based on current domain
state. <a href="libvirt-libvirt.html#VIR_DOMAIN_DEVICE_MODIFY_LIVE">VIR_DOMAIN_DEVICE_MODIFY_LIVE</a> specifies that the device shall be
allocated to the active domain instance only and is not added to the
persisted domain configuration. VIR_DOMAIN_DEVICE_MODIFY_CONFIG
specifies that the device shall be allocated to the persisted domain
configuration only. Note that the target hypervisor must return an
error if unable to satisfy flags. E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports modifying the
persisted device allocation.

For compatibility, this method can also be used to change the media
in an existing CDROM/Floppy device, however, applications are
recommended to use the virDomainUpdateDeviceFlag method instead.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>an OR'ed set of <a href="libvirt-libvirt.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainBlockPeek" id="virDomainBlockPeek"><code>virDomainBlockPeek</code></a></h3><pre class="programlisting">int	virDomainBlockPeek		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 const char * path, <br />					 unsigned long long offset, <br />					 size_t size, <br />					 void * buffer, <br />					 unsigned int flags)<br />
</pre><p>This function allows you to read the contents of a domain's
disk device.

Typical uses for this are to determine if the domain has
written a Master Boot Record (indicating that the domain
has completed installation), or to try to work out the state
of the domain's filesystems.

(Note that in the local case you might try to open the
block device or file directly, but that won't work in the
remote case, nor if you don't have sufficient permission.
Hence the need for this call).

'path' must be a device or file corresponding to the domain.
In other words it must be the precise string returned in
a &lt;disk&gt;&lt;source dev='...'/&gt;&lt;/disk&gt; from
virDomainGetXMLDesc.

'offset' and 'size' represent an area which must lie entirely
within the device or file. 'size' may be 0 to test if the
call would succeed.

'buffer' is the return buffer and must be at least 'size' bytes.

NB. The remote driver imposes a 64K byte limit on 'size'.
For your program to be able to work reliably over a remote
connection you should split large requests to &lt;= 65536 bytes.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>path</tt></i>:</span></td><td>path to the block device</td></tr><tr><td><span class="term"><i><tt>offset</tt></i>:</span></td><td>offset within block device</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size to read</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>return buffer (must be at least size bytes)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused, always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure. really 64 bits</td></tr></tbody></table></div><h3><a name="virDomainBlockStats" id="virDomainBlockStats"><code>virDomainBlockStats</code></a></h3><pre class="programlisting">int	virDomainBlockStats		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 const char * path, <br />					 <a href="libvirt-libvirt.html#virDomainBlockStatsPtr">virDomainBlockStatsPtr</a> stats, <br />					 size_t size)<br />
</pre><p>This function returns block device (disk) stats for block
devices attached to the domain.

The path parameter is the name of the block device. Get this
by calling <a href="libvirt-libvirt.html#virDomainGetXMLDesc">virDomainGetXMLDesc</a> and finding the &lt;target dev='...'&gt;
attribute within //domain/devices/disk. (For example, "xvda").

Domains may have more than one block device. To get stats for
each you should make multiple calls to this function.

Individual fields within the stats structure may be returned
as -1, which indicates that the hypervisor does not support
that particular statistic.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>path</tt></i>:</span></td><td>path to the block device</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>block device stats (returned)</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size of stats structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainCoreDump" id="virDomainCoreDump"><code>virDomainCoreDump</code></a></h3><pre class="programlisting">int	virDomainCoreDump		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * to, <br />					 int flags)<br />
</pre><p>This method will dump the core of a domain on a given file for analysis.
Note that for remote Xen Daemon the file path will be interpreted in
the remote host.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>to</tt></i>:</span></td><td>path for the core file</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags, currently unused</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainCreate" id="virDomainCreate"><code>virDomainCreate</code></a></h3><pre class="programlisting">int	virDomainCreate			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div><h3><a name="virDomainCreateLinux" id="virDomainCreateLinux"><code>virDomainCreateLinux</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainCreateLinux	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xmlDesc, <br />					 unsigned int flags)<br />
</pre><p>Deprecated after 0.4.6.
Renamed to virDomainCreateXML() providing identical functionality.
This existing name will left indefinitely for API compatibility.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure</td></tr></tbody></table></div><h3><a name="virDomainCreateWithFlags" id="virDomainCreateWithFlags"><code>virDomainCreateWithFlags</code></a></h3><pre class="programlisting">int	virDomainCreateWithFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int flags)<br />
</pre><p>Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-or of supported <a href="libvirt-libvirt.html#virDomainCreateFlags">virDomainCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div><h3><a name="virDomainCreateXML" id="virDomainCreateXML"><code>virDomainCreateXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainCreateXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xmlDesc, <br />					 unsigned int flags)<br />
</pre><p>Launch a new guest domain, based on an XML description similar
to the one returned by virDomainGetXMLDesc()
This function may requires privileged access to the hypervisor.
The domain is not persistent, so its definition will disappear when it
is destroyed, or if the host is restarted (see virDomainDefineXML() to
define persistent domains).</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-or of supported <a href="libvirt-libvirt.html#virDomainCreateFlags">virDomainCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure</td></tr></tbody></table></div><h3><a name="virDomainDefineXML" id="virDomainDefineXML"><code>virDomainDefineXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xml)<br />
</pre><p>Define a domain, but does not start it.
This definition is persistent, until explicitly undefined with
virDomainUndefine(). A previous definition for this domain would be
overriden if it already exists.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>the XML description for the domain, preferably in UTF-8</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, a pointer to the domain otherwise</td></tr></tbody></table></div><h3><a name="virDomainDestroy" id="virDomainDestroy"><code>virDomainDestroy</code></a></h3><pre class="programlisting">int	virDomainDestroy		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Destroy the domain object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor. This
does not free the associated <a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> object.
This function may require privileged access</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainDetachDevice" id="virDomainDetachDevice"><code>virDomainDetachDevice</code></a></h3><pre class="programlisting">int	virDomainDetachDevice		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * xml)<br />
</pre><p>Destroy a virtual device attachment to backend. This function,
having hot-unplug semantics, is only allowed on an active domain.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainDetachDeviceFlags" id="virDomainDetachDeviceFlags"><code>virDomainDetachDeviceFlags</code></a></h3><pre class="programlisting">int	virDomainDetachDeviceFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * xml, <br />					 unsigned int flags)<br />
</pre><p>Detach a virtual device from a domain, using the flags parameter
to control how the device is detached. VIR_DOMAIN_DEVICE_MODIFY_CURRENT
specifies that the device allocation is removed based on current domain
state. <a href="libvirt-libvirt.html#VIR_DOMAIN_DEVICE_MODIFY_LIVE">VIR_DOMAIN_DEVICE_MODIFY_LIVE</a> specifies that the device shall be
deallocated from the active domain instance only and is not from the
persisted domain configuration. VIR_DOMAIN_DEVICE_MODIFY_CONFIG
specifies that the device shall be deallocated from the persisted domain
configuration only. Note that the target hypervisor must return an
error if unable to satisfy flags. E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports removing the
persisted device allocation.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>an OR'ed set of <a href="libvirt-libvirt.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainFree" id="virDomainFree"><code>virDomainFree</code></a></h3><pre class="programlisting">int	virDomainFree			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Free the domain object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainGetAutostart" id="virDomainGetAutostart"><code>virDomainGetAutostart</code></a></h3><pre class="programlisting">int	virDomainGetAutostart		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 int * autostart)<br />
</pre><p>Provides a boolean value indicating whether the domain
configured to be automatically started when the host
machine boots.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>the value returned</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virDomainGetBlockInfo" id="virDomainGetBlockInfo"><code>virDomainGetBlockInfo</code></a></h3><pre class="programlisting">int	virDomainGetBlockInfo		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * path, <br />					 <a href="libvirt-libvirt.html#virDomainBlockInfoPtr">virDomainBlockInfoPtr</a> info, <br />					 unsigned int flags)<br />
</pre><p>Extract information about a domain's block device.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>path</tt></i>:</span></td><td>path to the block device or file</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virDomainBlockInfo">virDomainBlockInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, pass zero</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainGetConnect" id="virDomainGetConnect"><code>virDomainGetConnect</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virDomainGetConnect	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)<br />
</pre><p>Provides the connection pointer associated with a domain. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function. Instead, store the connection and
the domain object together.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to a domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainGetID" id="virDomainGetID"><code>virDomainGetID</code></a></h3><pre class="programlisting">unsigned int	virDomainGetID		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Get the hypervisor ID number for the domain</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the domain ID number or (unsigned int) -1 in case of error</td></tr></tbody></table></div><h3><a name="virDomainGetInfo" id="virDomainGetInfo"><code>virDomainGetInfo</code></a></h3><pre class="programlisting">int	virDomainGetInfo		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virDomainInfoPtr">virDomainInfoPtr</a> info)<br />
</pre><p>Extract information about a domain. Note that if the connection
used to get the domain is limited only a partial set of the information
can be extracted.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virDomainInfo">virDomainInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainGetJobInfo" id="virDomainGetJobInfo"><code>virDomainGetJobInfo</code></a></h3><pre class="programlisting">int	virDomainGetJobInfo		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virDomainJobInfoPtr">virDomainJobInfoPtr</a> info)<br />
</pre><p>Extract information about progress of a background job on a domain.
Will return an error if the domain is not active.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virDomainJobInfo">virDomainJobInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainGetMaxMemory" id="virDomainGetMaxMemory"><code>virDomainGetMaxMemory</code></a></h3><pre class="programlisting">unsigned long	virDomainGetMaxMemory	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Retrieve the maximum amount of physical memory allocated to a
domain. If domain is NULL, then this get the amount of memory reserved
to Domain0 i.e. the domain where the application runs.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the memory size in kilobytes or 0 in case of error.</td></tr></tbody></table></div><h3><a name="virDomainGetMaxVcpus" id="virDomainGetMaxVcpus"><code>virDomainGetMaxVcpus</code></a></h3><pre class="programlisting">int	virDomainGetMaxVcpus		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Provides the maximum number of virtual CPUs supported for
the guest VM. If the guest is inactive, this is basically
the same as virConnectGetMaxVcpus(). If the guest is running
this will reflect the maximum number of virtual CPUs the
guest was booted with. For more details, see virDomainGetVcpusFlags().</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the maximum of virtual CPU or -1 in case of error.</td></tr></tbody></table></div><h3><a name="virDomainGetMemoryParameters" id="virDomainGetMemoryParameters"><code>virDomainGetMemoryParameters</code></a></h3><pre class="programlisting">int	virDomainGetMemoryParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virMemoryParameterPtr">virMemoryParameterPtr</a> params, <br />					 int * nparams, <br />					 unsigned int flags)<br />
</pre><p>Get the memory parameters, the @params array will be filled with the values
equal to the number of parameters suggested by @nparams

As the value of @nparams is dynamic, call the API setting @nparams to 0 and
@params as NULL, the API returns the number of parameters supported by the
HV by updating @nparams on SUCCESS. The caller should then allocate @params
array, i.e. (sizeof(@virMemoryParameter) * @nparams) bytes and call the API
again.

Here is the sample code snippet:

if ((virDomainGetMemoryParameters(dom, NULL, &amp;nparams, 0) == 0) &amp;&amp;
 (nparams != 0)) {
 params = vshMalloc(ctl, sizeof(virMemoryParameter) * nparams);
 memset(params, 0, sizeof(virMemoryParameter) * nparams);
 if (virDomainGetMemoryParameters(dom, params, &amp;nparams, 0)) {
 vshError(ctl, "%s", _("Unable to get memory parameters"));
 goto error;
 }
}

This function requires privileged access to the hypervisor. This function
expects the caller to allocate the @params.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to memory parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of memory parameters</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, for future extension</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div><h3><a name="virDomainGetName" id="virDomainGetName"><code>virDomainGetName</code></a></h3><pre class="programlisting">const char *	virDomainGetName	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Get the public name for that domain</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the domain object.</td></tr></tbody></table></div><h3><a name="virDomainGetOSType" id="virDomainGetOSType"><code>virDomainGetOSType</code></a></h3><pre class="programlisting">char *	virDomainGetOSType		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Get the type of domain operation system.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new string or NULL in case of error, the string must be freed by the caller.</td></tr></tbody></table></div><h3><a name="virDomainGetSchedulerParameters" id="virDomainGetSchedulerParameters"><code>virDomainGetSchedulerParameters</code></a></h3><pre class="programlisting">int	virDomainGetSchedulerParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virSchedParameterPtr">virSchedParameterPtr</a> params, <br />					 int * nparams)<br />
</pre><p>Get the scheduler parameters, the @params array will be filled with the
values.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter object (return value)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of scheduler parameter (this value should be same than the returned value nparams of virDomainGetSchedulerType)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div><h3><a name="virDomainGetSchedulerType" id="virDomainGetSchedulerType"><code>virDomainGetSchedulerType</code></a></h3><pre class="programlisting">char *	virDomainGetSchedulerType	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 int * nparams)<br />
</pre><p>Get the scheduler type.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of scheduler parameters(return value)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error. The caller must free the returned string.</td></tr></tbody></table></div><h3><a name="virDomainGetSecurityLabel" id="virDomainGetSecurityLabel"><code>virDomainGetSecurityLabel</code></a></h3><pre class="programlisting">int	virDomainGetSecurityLabel	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virSecurityLabelPtr">virSecurityLabelPtr</a> seclabel)<br />
</pre><p>Extract security label of an active domain. The 'label' field
in the @seclabel argument will be initialized to the empty
string if the domain is not running under a security model.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>seclabel</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virSecurityLabel">virSecurityLabel</a> structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure</td></tr></tbody></table></div><h3><a name="virDomainGetUUID" id="virDomainGetUUID"><code>virDomainGetUUID</code></a></h3><pre class="programlisting">int	virDomainGetUUID		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned char * uuid)<br />
</pre><p>Get the UUID for a domain</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virDomainGetUUIDString" id="virDomainGetUUIDString"><code>virDomainGetUUIDString</code></a></h3><pre class="programlisting">int	virDomainGetUUIDString		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 char * buf)<br />
</pre><p>Get the UUID for a domain as string. For more information about
UUID see RFC4122.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virDomainGetVcpus" id="virDomainGetVcpus"><code>virDomainGetVcpus</code></a></h3><pre class="programlisting">int	virDomainGetVcpus		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virVcpuInfoPtr">virVcpuInfoPtr</a> info, <br />					 int maxinfo, <br />					 unsigned char * cpumaps, <br />					 int maplen)<br />
</pre><p>Extract information about virtual CPUs of domain, store it in info array
and also in cpumaps if this pointer isn't NULL.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to an array of <a href="libvirt-libvirt.html#virVcpuInfo">virVcpuInfo</a> structures (OUT)</td></tr><tr><td><span class="term"><i><tt>maxinfo</tt></i>:</span></td><td>number of structures in info array</td></tr><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) If cpumaps is NULL, then no cpumap information is returned by the API. It's assumed there is &lt;maxinfo&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (maxinfo * maplen) bytes (ie: calloc(maxinfo, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in one cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). Must be zero when cpumaps is NULL and positive when it is non-NULL.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of info filled in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainGetVcpusFlags" id="virDomainGetVcpusFlags"><code>virDomainGetVcpusFlags</code></a></h3><pre class="programlisting">int	virDomainGetVcpusFlags		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int flags)<br />
</pre><p>Query the number of virtual CPUs used by the domain. Note that
this call may fail if the underlying virtualization hypervisor does
not support it. This function requires privileged access to the
hypervisor.

@flags must include either VIR_DOMAIN_VCPU_ACTIVE to query a
running domain (which will fail if domain is not active), or
VIR_DOMAIN_VCPU_PERSISTENT to query the XML description of the
domain. It is an error to set both flags.

If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then the maximum
virtual CPU limit is queried. Otherwise, this call queries the
current virtual CPU limit.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>an OR'ed set of <a href="libvirt-libvirt.html#virDomainVcpuFlags">virDomainVcpuFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainGetXMLDesc" id="virDomainGetXMLDesc"><code>virDomainGetXMLDesc</code></a></h3><pre class="programlisting">char *	virDomainGetXMLDesc		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 int flags)<br />
</pre><p>Provide an XML description of the domain. The description may be reused
later to relaunch the domain with virDomainCreateXML().</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>an OR'ed set of <a href="libvirt-libvirt.html#virDomainXMLFlags">virDomainXMLFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div><h3><a name="virDomainHasCurrentSnapshot" id="virDomainHasCurrentSnapshot"><code>virDomainHasCurrentSnapshot</code></a></h3><pre class="programlisting">int	virDomainHasCurrentSnapshot	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int flags)<br />
</pre><p>Determine if the domain has a current snapshot.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused flag parameters; callers should pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if such snapshot exists, 0 if it doesn't, -1 on error.</td></tr></tbody></table></div><h3><a name="virDomainHasManagedSaveImage" id="virDomainHasManagedSaveImage"><code>virDomainHasManagedSaveImage</code></a></h3><pre class="programlisting">int	virDomainHasManagedSaveImage	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 unsigned int flags)<br />
</pre><p>Check if a domain has a managed save image as created by
virDomainManagedSave(). Note that any running domain should not have
such an image, as it should have been removed on restart.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>optional flags currently unused</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if no image is present, 1 if an image is present, and -1 in case of error</td></tr></tbody></table></div><h3><a name="virDomainInterfaceStats" id="virDomainInterfaceStats"><code>virDomainInterfaceStats</code></a></h3><pre class="programlisting">int	virDomainInterfaceStats		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 const char * path, <br />					 <a href="libvirt-libvirt.html#virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a> stats, <br />					 size_t size)<br />
</pre><p>This function returns network interface stats for interfaces
attached to the domain.

The path parameter is the name of the network interface.

Domains may have more than one network interface. To get stats for
each you should make multiple calls to this function.

Individual fields within the stats structure may be returned
as -1, which indicates that the hypervisor does not support
that particular statistic.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>path</tt></i>:</span></td><td>path to the interface</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>network interface stats (returned)</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size of stats structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainIsActive" id="virDomainIsActive"><code>virDomainIsActive</code></a></h3><pre class="programlisting">int	virDomainIsActive		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)<br />
</pre><p>Determine if the domain is currently running</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if running, 0 if inactive, -1 on error</td></tr></tbody></table></div><h3><a name="virDomainIsPersistent" id="virDomainIsPersistent"><code>virDomainIsPersistent</code></a></h3><pre class="programlisting">int	virDomainIsPersistent		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)<br />
</pre><p>Determine if the domain has a persistent configuration
which means it will still exist after shutting down</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if persistent, 0 if transient, -1 on error</td></tr></tbody></table></div><h3><a name="virDomainIsUpdated" id="virDomainIsUpdated"><code>virDomainIsUpdated</code></a></h3><pre class="programlisting">int	virDomainIsUpdated		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom)<br />
</pre><p>Determine if the domain has been updated.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if updated, 0 if not, -1 on error</td></tr></tbody></table></div><h3><a name="virDomainLookupByID" id="virDomainLookupByID"><code>virDomainLookupByID</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 int id)<br />
</pre><p>Try to find a domain based on the hypervisor ID number
Note that this won't work for inactive domains which have an ID of -1,
in that case a lookup based on the Name or UUId need to be done instead.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>id</tt></i>:</span></td><td>the domain ID number</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div><h3><a name="virDomainLookupByName" id="virDomainLookupByName"><code>virDomainLookupByName</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * name)<br />
</pre><p>Try to lookup a domain on the given hypervisor based on its name.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div><h3><a name="virDomainLookupByUUID" id="virDomainLookupByUUID"><code>virDomainLookupByUUID</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByUUID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const unsigned char * uuid)<br />
</pre><p>Try to lookup a domain on the given hypervisor based on its UUID.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>the raw UUID for the domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div><h3><a name="virDomainLookupByUUIDString" id="virDomainLookupByUUIDString"><code>virDomainLookupByUUIDString</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByUUIDString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * uuidstr)<br />
</pre><p>Try to lookup a domain on the given hypervisor based on its UUID.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>the string UUID for the domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div><h3><a name="virDomainManagedSave" id="virDomainManagedSave"><code>virDomainManagedSave</code></a></h3><pre class="programlisting">int	virDomainManagedSave		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 unsigned int flags)<br />
</pre><p>This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore.
The difference from virDomainSave() is that libvirt is keeping track of
the saved state itself, and will reuse it once the domain is being
restarted (automatically or via an explicit libvirt call).
As a result any running domain is sure to not have a managed saved image.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>optional flags currently unused</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure</td></tr></tbody></table></div><h3><a name="virDomainManagedSaveRemove" id="virDomainManagedSaveRemove"><code>virDomainManagedSaveRemove</code></a></h3><pre class="programlisting">int	virDomainManagedSaveRemove	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 unsigned int flags)<br />
</pre><p>Remove any managed save image for this domain.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>optional flags currently unused</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, and -1 in case of error</td></tr></tbody></table></div><h3><a name="virDomainMemoryPeek" id="virDomainMemoryPeek"><code>virDomainMemoryPeek</code></a></h3><pre class="programlisting">int	virDomainMemoryPeek		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 unsigned long long start, <br />					 size_t size, <br />					 void * buffer, <br />					 unsigned int flags)<br />
</pre><p>This function allows you to read the contents of a domain's
memory.

The memory which is read is controlled by the 'start', 'size'
and 'flags' parameters.

If 'flags' is <a href="libvirt-libvirt.html#VIR_MEMORY_VIRTUAL">VIR_MEMORY_VIRTUAL</a> then the 'start' and 'size'
parameters are interpreted as virtual memory addresses for
whichever task happens to be running on the domain at the
moment. Although this sounds haphazard it is in fact what
you want in order to read Linux kernel state, because it
ensures that pointers in the kernel image can be interpreted
coherently.

'buffer' is the return buffer and must be at least 'size' bytes.
'size' may be 0 to test if the call would succeed.

NB. The remote driver imposes a 64K byte limit on 'size'.
For your program to be able to work reliably over a remote
connection you should split large requests to &lt;= 65536 bytes.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>start</tt></i>:</span></td><td>start of memory to peek</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size of memory to peek</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>return buffer (must be at least size bytes)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags, see below</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure. really 64 bits</td></tr></tbody></table></div><h3><a name="virDomainMemoryStats" id="virDomainMemoryStats"><code>virDomainMemoryStats</code></a></h3><pre class="programlisting">int	virDomainMemoryStats		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 <a href="libvirt-libvirt.html#virDomainMemoryStatPtr">virDomainMemoryStatPtr</a> stats, <br />					 unsigned int nr_stats, <br />					 unsigned int flags)<br />
</pre><p>This function provides memory statistics for the domain.

Up to 'nr_stats' elements of 'stats' will be populated with memory statistics
from the domain. Only statistics supported by the domain, the driver, and
this version of libvirt will be returned.

Memory Statistics:

VIR_DOMAIN_MEMORY_STAT_SWAP_IN:
 The total amount of data read from swap space (in kb).
VIR_DOMAIN_MEMORY_STAT_SWAP_OUT:
 The total amount of memory written out to swap space (in kb).
VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT:
 The number of page faults that required disk IO to service.
VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT:
 The number of page faults serviced without disk IO.
VIR_DOMAIN_MEMORY_STAT_UNUSED:
 The amount of memory which is not being used for any purpose (in kb).
VIR_DOMAIN_MEMORY_STAT_AVAILABLE:
 The total amount of memory available to the domain's OS (in kb).</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>nr_stats-sized array of stat structures (returned)</td></tr><tr><td><span class="term"><i><tt>nr_stats</tt></i>:</span></td><td>number of memory statistics requested</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused, always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>The number of stats provided or -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainMigrate" id="virDomainMigrate"><code>virDomainMigrate</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a>	virDomainMigrate	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> dconn, <br />					 unsigned long flags, <br />					 const char * dname, <br />					 const char * uri, <br />					 unsigned long bandwidth)<br />
</pre><p>Migrate the domain object from its current host to the destination
host given by dconn (a connection to the destination host).

Flags may be one of more of the following:
 <a href="libvirt-libvirt.html#VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> Do not pause the VM during migration
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> Direct connection between source &amp; destination hosts
 <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> Tunnel migration data over the libvirt RPC channel
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> If the migration is successful, persist the domain
 on the destination host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> If the migration is successful, undefine the
 domain on the source host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> Leave the domain suspended on the remote side.

VIR_MIGRATE_TUNNELLED requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set.
Applications using the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag will probably
prefer to invoke virDomainMigrateToURI, avoiding the need to
open connection to the destination host themselves.

If a hypervisor supports renaming domains during migration,
then you may set the dname parameter to the new name (otherwise
it keeps the same name). If this is not supported by the
hypervisor, dname must be NULL or else you will get an error.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is set, the uri parameter
must be a valid libvirt connection URI, by which the source
libvirt driver can connect to the destination libvirt. If
omitted, the dconn connection object will be queried for its
current URI.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, the URI parameter
takes a hypervisor specific format. The hypervisor capabilities
XML includes details of the support URI schemes. If omitted
the dconn will be asked for a default URI.

In either case it is typically only necessary to specify a
URI if the destination host has multiple interfaces and a
specific interface is required to transmit migration data.

The maximum bandwidth (in Mbps) that will be used to do migration
can be specified with the bandwidth parameter. If set to 0,
libvirt will choose a suitable default. Some hypervisors do
not support this feature and will return an error if bandwidth
is not 0.

To see which features are supported by the current hypervisor,
see virConnectGetCapabilities, /capabilities/host/migration_features.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconn</tt></i>:</span></td><td>destination host (a connection object)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags</td></tr><tr><td><span class="term"><i><tt>dname</tt></i>:</span></td><td>(optional) rename domain to this at destination</td></tr><tr><td><span class="term"><i><tt>uri</tt></i>:</span></td><td>(optional) dest hostname/URI as seen from the source host</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify migration bandwidth limit in Mbps</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new domain object if the migration was successful, or NULL in case of error. Note that the new domain object exists in the scope of the destination connection (dconn).</td></tr></tbody></table></div><h3><a name="virDomainMigrateSetMaxDowntime" id="virDomainMigrateSetMaxDowntime"><code>virDomainMigrateSetMaxDowntime</code></a></h3><pre class="programlisting">int	virDomainMigrateSetMaxDowntime	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned long long downtime, <br />					 unsigned int flags)<br />
</pre><p>Sets maximum tolerable time for which the domain is allowed to be paused
at the end of live migration. It's supposed to be called while the domain is
being live-migrated as a reaction to migration progress.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>downtime</tt></i>:</span></td><td>maximum tolerable downtime for live migration, in milliseconds</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>fine-tuning flags, currently unused, use 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div><h3><a name="virDomainMigrateToURI" id="virDomainMigrateToURI"><code>virDomainMigrateToURI</code></a></h3><pre class="programlisting">int	virDomainMigrateToURI		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * duri, <br />					 unsigned long flags, <br />					 const char * dname, <br />					 unsigned long bandwidth)<br />
</pre><p>Migrate the domain object from its current host to the destination
host given by duri.

Flags may be one of more of the following:
 <a href="libvirt-libvirt.html#VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> Do not pause the VM during migration
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> Direct connection between source &amp; destination hosts
 <a href="libvirt-libvirt.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> Tunnel migration data over the libvirt RPC channel
 <a href="libvirt-libvirt.html#VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> If the migration is successful, persist the domain
 on the destination host.
 <a href="libvirt-libvirt.html#VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> If the migration is successful, undefine the
 domain on the source host.

The operation of this API hinges on the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag.
If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, the duri parameter
takes a hypervisor specific format. The uri_transports element of the
hypervisor capabilities XML includes details of the supported URI
schemes. Not all hypervisors will support this mode of migration, so
if the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is not set, then it may be necessary
to use the alternative <a href="libvirt-libvirt.html#virDomainMigrate">virDomainMigrate</a> API providing and explicit
virConnectPtr for the destination host.

If the <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag IS set, the duri parameter
must be a valid libvirt connection URI, by which the source
libvirt driver can connect to the destination libvirt.

VIR_MIGRATE_TUNNELLED requires that <a href="libvirt-libvirt.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> be set.

If a hypervisor supports renaming domains during migration,
the dname parameter specifies the new name for the domain.
Setting dname to NULL keeps the domain name the same. If domain
renaming is not supported by the hypervisor, dname must be NULL or
else an error will be returned.

The maximum bandwidth (in Mbps) that will be used to do migration
can be specified with the bandwidth parameter. If set to 0,
libvirt will choose a suitable default. Some hypervisors do
not support this feature and will return an error if bandwidth
is not 0.

To see which features are supported by the current hypervisor,
see virConnectGetCapabilities, /capabilities/host/migration_features.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>duri</tt></i>:</span></td><td>mandatory URI for the destination host</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags</td></tr><tr><td><span class="term"><i><tt>dname</tt></i>:</span></td><td>(optional) rename domain to this at destination</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify migration bandwidth limit in Mbps</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the migration succeeded, -1 upon error.</td></tr></tbody></table></div><h3><a name="virDomainOpenConsole" id="virDomainOpenConsole"><code>virDomainOpenConsole</code></a></h3><pre class="programlisting">int	virDomainOpenConsole		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> dom, <br />					 const char * devname, <br />					 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br />					 unsigned int flags)<br />
</pre><p>This opens the backend associated with a console, serial or
parallel port device on a guest, if the backend is supported.
If the @devname is omitted, then the first console or serial
device is opened. The console is associated with the passed
in @st stream, which should have been opened in non-blocking
mode for bi-directional I/O.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>devname</tt></i>:</span></td><td>the console, serial or parallel port device alias, or NULL</td></tr><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>a stream to associate with the console</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused, pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the console was opened, -1 on error</td></tr></tbody></table></div><h3><a name="virDomainPinVcpu" id="virDomainPinVcpu"><code>virDomainPinVcpu</code></a></h3><pre class="programlisting">int	virDomainPinVcpu		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int vcpu, <br />					 unsigned char * cpumap, <br />					 int maplen)<br />
</pre><p>Dynamically change the real CPUs which can be allocated to a virtual CPU.
This function requires privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>virtual CPU number</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainReboot" id="virDomainReboot"><code>virDomainReboot</code></a></h3><pre class="programlisting">int	virDomainReboot			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int flags)<br />
</pre><p>Reboot a domain, the domain object is still usable there after but
the domain OS is being stopped for a restart.
Note that the guest OS may ignore the request.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags for the reboot operation, not used yet</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainRef" id="virDomainRef"><code>virDomainRef</code></a></h3><pre class="programlisting">int	virDomainRef			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Increment the reference count on the domain. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virDomainFree">virDomainFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a domain would increment
the reference count.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>the domain to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainRestore" id="virDomainRestore"><code>virDomainRestore</code></a></h3><pre class="programlisting">int	virDomainRestore		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * from)<br />
</pre><p>This method will restore a domain saved to disk by virDomainSave().</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>from</tt></i>:</span></td><td>path to the</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainResume" id="virDomainResume"><code>virDomainResume</code></a></h3><pre class="programlisting">int	virDomainResume			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Resume a suspended domain, the process is restarted from the state where
it was frozen by calling virSuspendDomain().
This function may requires privileged access</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainRevertToSnapshot" id="virDomainRevertToSnapshot"><code>virDomainRevertToSnapshot</code></a></h3><pre class="programlisting">int	virDomainRevertToSnapshot	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br />					 unsigned int flags)<br />
</pre><p>Revert the domain to a given snapshot.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused flag parameters; callers should pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the creation is successful, -1 on error.</td></tr></tbody></table></div><h3><a name="virDomainSave" id="virDomainSave"><code>virDomainSave</code></a></h3><pre class="programlisting">int	virDomainSave			(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * to)<br />
</pre><p>This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore (this may be a problem).
Use virDomainRestore() to restore a domain after saving.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>to</tt></i>:</span></td><td>path for the output file</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainSetAutostart" id="virDomainSetAutostart"><code>virDomainSetAutostart</code></a></h3><pre class="programlisting">int	virDomainSetAutostart		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 int autostart)<br />
</pre><p>Configure the domain to be automatically started
when the host machine boots.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>whether the domain should be automatically started 0 or 1</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virDomainSetMaxMemory" id="virDomainSetMaxMemory"><code>virDomainSetMaxMemory</code></a></h3><pre class="programlisting">int	virDomainSetMaxMemory		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned long memory)<br />
</pre><p>Dynamically change the maximum amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function requires privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>memory</tt></i>:</span></td><td>the memory size in kilobytes</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainSetMemory" id="virDomainSetMemory"><code>virDomainSetMemory</code></a></h3><pre class="programlisting">int	virDomainSetMemory		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned long memory)<br />
</pre><p>Dynamically change the target amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may requires privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>memory</tt></i>:</span></td><td>the memory size in kilobytes</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainSetMemoryParameters" id="virDomainSetMemoryParameters"><code>virDomainSetMemoryParameters</code></a></h3><pre class="programlisting">int	virDomainSetMemoryParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virMemoryParameterPtr">virMemoryParameterPtr</a> params, <br />					 int nparams, <br />					 unsigned int flags)<br />
</pre><p>Change the memory tunables
This function requires privileged access to the hypervisor.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to memory parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of memory parameter (this value should be same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, for future extension</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div><h3><a name="virDomainSetSchedulerParameters" id="virDomainSetSchedulerParameters"><code>virDomainSetSchedulerParameters</code></a></h3><pre class="programlisting">int	virDomainSetSchedulerParameters	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 <a href="libvirt-libvirt.html#virSchedParameterPtr">virSchedParameterPtr</a> params, <br />					 int nparams)<br />
</pre><p>Change the scheduler parameters</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of scheduler parameter (this value should be same or less than the returned value nparams of virDomainGetSchedulerType)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div><h3><a name="virDomainSetVcpus" id="virDomainSetVcpus"><code>virDomainSetVcpus</code></a></h3><pre class="programlisting">int	virDomainSetVcpus		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int nvcpus)<br />
</pre><p>Dynamically change the number of virtual CPUs used by the domain.
Note that this call may fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrary limited.
This function requires privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain. It is hypervisor-dependent
whether it also affects persistent configuration; for more control,
use virDomainSetVcpusFlags().</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>nvcpus</tt></i>:</span></td><td>the new number of virtual CPUs for this domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainSetVcpusFlags" id="virDomainSetVcpusFlags"><code>virDomainSetVcpusFlags</code></a></h3><pre class="programlisting">int	virDomainSetVcpusFlags		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int nvcpus, <br />					 unsigned int flags)<br />
</pre><p>Dynamically change the number of virtual CPUs used by the domain.
Note that this call may fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrary limited.
This function requires privileged access to the hypervisor.

@flags must include <a href="libvirt-libvirt.html#VIR_DOMAIN_VCPU_LIVE">VIR_DOMAIN_VCPU_LIVE</a> to affect a running
domain (which may fail if domain is not active), or
VIR_DOMAIN_VCPU_CONFIG to affect the next boot via the XML
description of the domain. Both flags may be set.

If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then
VIR_DOMAIN_VCPU_LIVE must be clear, and only the maximum virtual
CPU limit is altered; generally, this value must be less than or
equal to virConnectGetMaxVcpus(). Otherwise, this call affects the
current virtual CPU limit, which must be less than or equal to the
maximum limit.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>nvcpus</tt></i>:</span></td><td>the new number of virtual CPUs for this domain, must be at least 1</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>an OR'ed set of <a href="libvirt-libvirt.html#virDomainVcpuFlags">virDomainVcpuFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainShutdown" id="virDomainShutdown"><code>virDomainShutdown</code></a></h3><pre class="programlisting">int	virDomainShutdown		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Shutdown a domain, the domain object is still usable there after but
the domain OS is being stopped. Note that the guest OS may ignore the
request.

TODO: should we add an option for reboot, knowing it may not be doable
 in the general case ?</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainSnapshotCreateXML" id="virDomainSnapshotCreateXML"><code>virDomainSnapshotCreateXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	virDomainSnapshotCreateXML	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />							 const char * xmlDesc, <br />							 unsigned int flags)<br />
</pre><p>Creates a new snapshot of a domain based on the snapshot xml
contained in xmlDesc.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused flag parameters; callers should pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>an (opaque) <a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> on success, NULL on failure.</td></tr></tbody></table></div><h3><a name="virDomainSnapshotCurrent" id="virDomainSnapshotCurrent"><code>virDomainSnapshotCurrent</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	virDomainSnapshotCurrent	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />							 unsigned int flags)<br />
</pre><p>Get the current snapshot for a domain, if any.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused flag parameters; callers should pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a domain snapshot object or NULL in case of failure. If the current domain snapshot cannot be found, then the <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN_SNAPSHOT">VIR_ERR_NO_DOMAIN_SNAPSHOT</a> error is raised.</td></tr></tbody></table></div><h3><a name="virDomainSnapshotDelete" id="virDomainSnapshotDelete"><code>virDomainSnapshotDelete</code></a></h3><pre class="programlisting">int	virDomainSnapshotDelete		(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br />					 unsigned int flags)<br />
</pre><p>Delete the snapshot.

If @flags is 0, then just this snapshot is deleted, and changes from
this snapshot are automatically merged into children snapshots. If
flags is VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN, then this snapshot
and any children snapshots are deleted.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flag parameters</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the snapshot was successfully deleted, -1 on error.</td></tr></tbody></table></div><h3><a name="virDomainSnapshotFree" id="virDomainSnapshotFree"><code>virDomainSnapshotFree</code></a></h3><pre class="programlisting">int	virDomainSnapshotFree		(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot)<br />
</pre><p>Free the domain snapshot object. The snapshot itself is not modified.
The data structure is freed and should not be used thereafter.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainSnapshotGetXMLDesc" id="virDomainSnapshotGetXMLDesc"><code>virDomainSnapshotGetXMLDesc</code></a></h3><pre class="programlisting">char *	virDomainSnapshotGetXMLDesc	(<a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a> snapshot, <br />					 unsigned int flags)<br />
</pre><p>Provide an XML description of the domain snapshot.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>snapshot</tt></i>:</span></td><td>a domain snapshot object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused flag parameters; callers should pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div><h3><a name="virDomainSnapshotListNames" id="virDomainSnapshotListNames"><code>virDomainSnapshotListNames</code></a></h3><pre class="programlisting">int	virDomainSnapshotListNames	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 char ** names, <br />					 int nameslen, <br />					 unsigned int flags)<br />
</pre><p>Collect the list of domain snapshots for the given domain, and store
their names in @names. Caller is responsible for freeing each member
of the array.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of names of snapshots</td></tr><tr><td><span class="term"><i><tt>nameslen</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused flag parameters; callers should pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain snapshots found or -1 in case of error.</td></tr></tbody></table></div><h3><a name="virDomainSnapshotLookupByName" id="virDomainSnapshotLookupByName"><code>virDomainSnapshotLookupByName</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virDomainSnapshotPtr">virDomainSnapshotPtr</a>	virDomainSnapshotLookupByName	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />							 const char * name, <br />							 unsigned int flags)<br />
</pre><p>Try to lookup a domain snapshot based on its name.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the domain snapshot</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused flag parameters; callers should pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a domain snapshot object or NULL in case of failure. If the domain snapshot cannot be found, then the <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN_SNAPSHOT">VIR_ERR_NO_DOMAIN_SNAPSHOT</a> error is raised.</td></tr></tbody></table></div><h3><a name="virDomainSnapshotNum" id="virDomainSnapshotNum"><code>virDomainSnapshotNum</code></a></h3><pre class="programlisting">int	virDomainSnapshotNum		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 unsigned int flags)<br />
</pre><p>Provides the number of domain snapshots for this domain..</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>unused flag parameters; callers should pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain snapshost found or -1 in case of error.</td></tr></tbody></table></div><h3><a name="virDomainSuspend" id="virDomainSuspend"><code>virDomainSuspend</code></a></h3><pre class="programlisting">int	virDomainSuspend		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Suspends an active domain, the process is frozen without further access
to CPU resources and I/O but the memory used by the domain at the
hypervisor level will stay allocated. Use virDomainResume() to reactivate
the domain.
This function may requires privileged access.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virDomainUndefine" id="virDomainUndefine"><code>virDomainUndefine</code></a></h3><pre class="programlisting">int	virDomainUndefine		(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain)<br />
</pre><p>Undefine a domain but does not stop it if it is running</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div><h3><a name="virDomainUpdateDeviceFlags" id="virDomainUpdateDeviceFlags"><code>virDomainUpdateDeviceFlags</code></a></h3><pre class="programlisting">int	virDomainUpdateDeviceFlags	(<a href="libvirt-libvirt.html#virDomainPtr">virDomainPtr</a> domain, <br />					 const char * xml, <br />					 unsigned int flags)<br />
</pre><p>Change a virtual device on a domain, using the flags parameter
to control how the device is changed. VIR_DOMAIN_DEVICE_MODIFY_CURRENT
specifies that the device change is made based on current domain
state. <a href="libvirt-libvirt.html#VIR_DOMAIN_DEVICE_MODIFY_LIVE">VIR_DOMAIN_DEVICE_MODIFY_LIVE</a> specifies that the device shall be
changed on the active domain instance only and is not added to the
persisted domain configuration. VIR_DOMAIN_DEVICE_MODIFY_CONFIG
specifies that the device shall be changed on the persisted domain
configuration only. Note that the target hypervisor must return an
error if unable to satisfy flags. E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports modifying the
persisted device allocation.

This method is used for actions such changing CDROM/Floppy device
media, altering the graphics configuration such as password,
reconfiguring the NIC device backend connectivity, etc.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>an OR'ed set of <a href="libvirt-libvirt.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virEventAddHandleFunc" id="virEventAddHandleFunc"><code>virEventAddHandleFunc</code></a></h3><pre class="programlisting">typedef int	(*virEventAddHandleFunc	)	(int fd, <br />					 int event, <br />					 <a href="libvirt-libvirt.html#virEventHandleCallback">virEventHandleCallback</a> cb, <br />					 void * opaque, <br />					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)
</pre><p>Part of the EventImpl, this callback Adds a file handle callback to
listen for specific events. The same file handle can be registered
multiple times provided the requested event sets are non-overlapping

If the opaque user data requires free'ing when the handle
is unregistered, then a 2nd callback can be supplied for
this purpose.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>fd</tt></i>:</span></td><td>file descriptor to listen on</td></tr><tr><td><span class="term"><i><tt>event</tt></i>:</span></td><td>bitset of events on which to fire the callback</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>the callback to be called when an event occurrs</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data to pass to the callback</td></tr><tr><td><span class="term"><i><tt>ff</tt></i>:</span></td><td>the callback invoked to free opaque data blob</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a handle watch number to be used for updating and unregistering for events</td></tr></tbody></table></div><br /><h3><a name="virEventAddTimeoutFunc" id="virEventAddTimeoutFunc"><code>virEventAddTimeoutFunc</code></a></h3><pre class="programlisting">typedef int	(*virEventAddTimeoutFunc	)	(int timeout, <br />					 <a href="libvirt-libvirt.html#virEventTimeoutCallback">virEventTimeoutCallback</a> cb, <br />					 void * opaque, <br />					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)
</pre><p>Part of the EventImpl, this user-defined callback handles adding an
event timeout.

If the opaque user data requires free'ing when the handle
is unregistered, then a 2nd callback can be supplied for
this purpose.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>timeout</tt></i>:</span></td><td>The timeout to monitor</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>the callback to call when timeout has expired</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data to pass to the callback</td></tr><tr><td><span class="term"><i><tt>ff</tt></i>:</span></td><td>the callback invoked to free opaque data blob</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a timer value</td></tr></tbody></table></div><br /><h3><a name="virEventHandleCallback" id="virEventHandleCallback"><code>virEventHandleCallback</code></a></h3><pre class="programlisting">typedef void	(*virEventHandleCallback	)	(int watch, <br />					 int fd, <br />					 int events, <br />					 void * opaque)
</pre><p>Callback for receiving file handle events. The callback will
be invoked once for each event which is pending.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>watch</tt></i>:</span></td><td>watch on which the event occurred</td></tr><tr><td><span class="term"><i><tt>fd</tt></i>:</span></td><td>file handle on which the event occurred</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>bitset of events from <a href="libvirt-libvirt.html#virEventHandleType">virEventHandleType</a> constants</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data registered with handle</td></tr></tbody></table></div><br /><h3><a name="virEventRegisterImpl" id="virEventRegisterImpl"><code>virEventRegisterImpl</code></a></h3><pre class="programlisting">void	virEventRegisterImpl		(<a href="libvirt-libvirt.html#virEventAddHandleFunc">virEventAddHandleFunc</a> addHandle, <br />					 <a href="libvirt-libvirt.html#virEventUpdateHandleFunc">virEventUpdateHandleFunc</a> updateHandle, <br />					 <a href="libvirt-libvirt.html#virEventRemoveHandleFunc">virEventRemoveHandleFunc</a> removeHandle, <br />					 <a href="libvirt-libvirt.html#virEventAddTimeoutFunc">virEventAddTimeoutFunc</a> addTimeout, <br />					 <a href="libvirt-libvirt.html#virEventUpdateTimeoutFunc">virEventUpdateTimeoutFunc</a> updateTimeout, <br />					 <a href="libvirt-libvirt.html#virEventRemoveTimeoutFunc">virEventRemoveTimeoutFunc</a> removeTimeout)<br />
</pre><p>Registers an event implementation</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>addHandle</tt></i>:</span></td><td>the callback to add fd handles</td></tr><tr><td><span class="term"><i><tt>updateHandle</tt></i>:</span></td><td>the callback to update fd handles</td></tr><tr><td><span class="term"><i><tt>removeHandle</tt></i>:</span></td><td>the callback to remove fd handles</td></tr><tr><td><span class="term"><i><tt>addTimeout</tt></i>:</span></td><td>the callback to add a timeout</td></tr><tr><td><span class="term"><i><tt>updateTimeout</tt></i>:</span></td><td>the callback to update a timeout</td></tr><tr><td><span class="term"><i><tt>removeTimeout</tt></i>:</span></td><td>the callback to remove a timeout</td></tr></tbody></table></div><h3><a name="virEventRemoveHandleFunc" id="virEventRemoveHandleFunc"><code>virEventRemoveHandleFunc</code></a></h3><pre class="programlisting">typedef int	(*virEventRemoveHandleFunc)	(int watch)
</pre><p>Part of the EventImpl, this user-provided callback is notified when
an fd is no longer being listened on.

If a virEventHandleFreeFunc was supplied when the handle was
registered, it will be invoked some time during, or after this
function call, when it is safe to release the user data.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>watch</tt></i>:</span></td><td>file descriptor watch to stop listening on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td></td></tr></tbody></table></div><br /><h3><a name="virEventRemoveTimeoutFunc" id="virEventRemoveTimeoutFunc"><code>virEventRemoveTimeoutFunc</code></a></h3><pre class="programlisting">typedef int	(*virEventRemoveTimeoutFunc)	(int timer)
</pre><p>Part of the EventImpl, this user-defined callback removes a timer

If a virEventTimeoutFreeFunc was supplied when the handle was
registered, it will be invoked some time during, or after this
function call, when it is safe to release the user data.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>timer</tt></i>:</span></td><td>the timer to remove</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div><br /><h3><a name="virEventTimeoutCallback" id="virEventTimeoutCallback"><code>virEventTimeoutCallback</code></a></h3><pre class="programlisting">typedef void	(*virEventTimeoutCallback	)	(int timer, <br />					 void * opaque)
</pre><p>callback for receiving timer events</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>timer</tt></i>:</span></td><td>timer id emitting the event</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data registered with handle</td></tr></tbody></table></div><br /><h3><a name="virEventUpdateHandleFunc" id="virEventUpdateHandleFunc"><code>virEventUpdateHandleFunc</code></a></h3><pre class="programlisting">typedef void	(*virEventUpdateHandleFunc)	(int watch, <br />					 int event)
</pre><p>Part of the EventImpl, this user-provided callback is notified when
events to listen on change</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>watch</tt></i>:</span></td><td>file descriptor watch to modify</td></tr><tr><td><span class="term"><i><tt>event</tt></i>:</span></td><td>new events to listen on</td></tr></tbody></table></div><br /><h3><a name="virEventUpdateTimeoutFunc" id="virEventUpdateTimeoutFunc"><code>virEventUpdateTimeoutFunc</code></a></h3><pre class="programlisting">typedef void	(*virEventUpdateTimeoutFunc)	(int timer, <br />					 int timeout)
</pre><p>Part of the EventImpl, this user-defined callback updates an
event timeout.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>timer</tt></i>:</span></td><td>the timer to modify</td></tr><tr><td><span class="term"><i><tt>timeout</tt></i>:</span></td><td>the new timeout value</td></tr></tbody></table></div><br /><h3><a name="virFreeCallback" id="virFreeCallback"><code>virFreeCallback</code></a></h3><pre class="programlisting">typedef void	(*virFreeCallback		)	(void * opaque)
</pre><p>Type for a domain event callback when the event is deregistered and
need to be freed, @opaque is provided along with the callback at
registration time</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque user data provided at registration</td></tr></tbody></table></div><br /><h3><a name="virGetVersion" id="virGetVersion"><code>virGetVersion</code></a></h3><pre class="programlisting">int	virGetVersion			(unsigned long * libVer, <br />					 const char * type, <br />					 unsigned long * typeVer)<br />
</pre><p>Provides two information back, @libVer is the version of the library
while @typeVer will be the version of the hypervisor type @type against
which the library was compiled. If @type is NULL, "Xen" is assumed, if
@type is unknown or not available, an error code will be returned and
@typeVer will be 0.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>libVer</tt></i>:</span></td><td>return value for the library version (OUT)</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>the type of connection/driver looked at</td></tr><tr><td><span class="term"><i><tt>typeVer</tt></i>:</span></td><td>return value for the version of the hypervisor (OUT)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 otherwise, and values for @libVer and @typeVer have the format major * 1,000,000 + minor * 1,000 + release.</td></tr></tbody></table></div><h3><a name="virInitialize" id="virInitialize"><code>virInitialize</code></a></h3><pre class="programlisting">int	virInitialize			(void)<br />
</pre><p>Initialize the library. It's better to call this routine at startup
in multithreaded applications to avoid potential race when initializing
the library.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div><h3><a name="virInterfaceCreate" id="virInterfaceCreate"><code>virInterfaceCreate</code></a></h3><pre class="programlisting">int	virInterfaceCreate		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br />					 unsigned int flags)<br />
</pre><p>Activate an interface (ie call "ifup")</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>pointer to a defined interface</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>and OR'ed set of extraction flags, not used yet</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div><h3><a name="virInterfaceDefineXML" id="virInterfaceDefineXML"><code>virInterfaceDefineXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	virInterfaceDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xml, <br />					 unsigned int flags)<br />
</pre><p>Define an interface (or modify existing interface configuration)</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>the XML description for the interface, preferably in UTF-8</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>and OR'ed set of extraction flags, not used yet</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, a pointer to the interface otherwise</td></tr></tbody></table></div><h3><a name="virInterfaceDestroy" id="virInterfaceDestroy"><code>virInterfaceDestroy</code></a></h3><pre class="programlisting">int	virInterfaceDestroy		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br />					 unsigned int flags)<br />
</pre><p>deactivate an interface (ie call "ifdown")
This does not remove the interface from the config, and
does not free the associated <a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> object.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>and OR'ed set of extraction flags, not used yet</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virInterfaceFree" id="virInterfaceFree"><code>virInterfaceFree</code></a></h3><pre class="programlisting">int	virInterfaceFree		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br />
</pre><p>Free the interface object. The interface itself is unaltered.
The data structure is freed and should not be used thereafter.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virInterfaceGetConnect" id="virInterfaceGetConnect"><code>virInterfaceGetConnect</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virInterfaceGetConnect	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br />
</pre><p>Provides the connection pointer associated with an interface. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function. Instead, store the connection and
the interface object together.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>pointer to an interface</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div><h3><a name="virInterfaceGetMACString" id="virInterfaceGetMACString"><code>virInterfaceGetMACString</code></a></h3><pre class="programlisting">const char *	virInterfaceGetMACString	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br />
</pre><p>Get the MAC for an interface as string. For more information about
MAC see RFC4122.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the MAC address (in null-terminated ASCII format) or NULL, the string need not be deallocated its lifetime will be the same as the interface object.</td></tr></tbody></table></div><h3><a name="virInterfaceGetName" id="virInterfaceGetName"><code>virInterfaceGetName</code></a></h3><pre class="programlisting">const char *	virInterfaceGetName	(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br />
</pre><p>Get the public name for that interface</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the interface object.</td></tr></tbody></table></div><h3><a name="virInterfaceGetXMLDesc" id="virInterfaceGetXMLDesc"><code>virInterfaceGetXMLDesc</code></a></h3><pre class="programlisting">char *	virInterfaceGetXMLDesc		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface, <br />					 unsigned int flags)<br />
</pre><p><a href="libvirt-libvirt.html#VIR_INTERFACE_XML_INACTIVE">VIR_INTERFACE_XML_INACTIVE</a> - return the static configuration,
 suitable for use redefining the
 interface via virInterfaceDefineXML()

Provide an XML description of the interface. If
VIR_INTERFACE_XML_INACTIVE is set, the description may be reused
later to redefine the interface with virInterfaceDefineXML(). If it
is not set, the ip address and netmask will be the current live
setting of the interface, not the settings from the config files.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>an OR'ed set of extraction flags. Current valid bits:</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div><h3><a name="virInterfaceIsActive" id="virInterfaceIsActive"><code>virInterfaceIsActive</code></a></h3><pre class="programlisting">int	virInterfaceIsActive		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br />
</pre><p>Determine if the interface is currently running</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>pointer to the interface object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if running, 0 if inactive, -1 on error</td></tr></tbody></table></div><h3><a name="virInterfaceLookupByMACString" id="virInterfaceLookupByMACString"><code>virInterfaceLookupByMACString</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	virInterfaceLookupByMACString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * macstr)<br />
</pre><p>Try to lookup an interface on the given hypervisor based on its MAC.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>macstr</tt></i>:</span></td><td>the MAC for the interface (null-terminated ASCII format)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new interface object or NULL in case of failure. If the interface cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_INTERFACE">VIR_ERR_NO_INTERFACE</a> error is raised.</td></tr></tbody></table></div><h3><a name="virInterfaceLookupByName" id="virInterfaceLookupByName"><code>virInterfaceLookupByName</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a>	virInterfaceLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * name)<br />
</pre><p>Try to lookup an interface on the given hypervisor based on its name.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the interface</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new interface object or NULL in case of failure. If the interface cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_INTERFACE">VIR_ERR_NO_INTERFACE</a> error is raised.</td></tr></tbody></table></div><h3><a name="virInterfaceRef" id="virInterfaceRef"><code>virInterfaceRef</code></a></h3><pre class="programlisting">int	virInterfaceRef			(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br />
</pre><p>Increment the reference count on the interface. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virInterfaceFree">virInterfaceFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using an interface would increment
the reference count.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>the interface to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virInterfaceUndefine" id="virInterfaceUndefine"><code>virInterfaceUndefine</code></a></h3><pre class="programlisting">int	virInterfaceUndefine		(<a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> iface)<br />
</pre><p>Undefine an interface, ie remove it from the config.
This does not free the associated <a href="libvirt-libvirt.html#virInterfacePtr">virInterfacePtr</a> object.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>pointer to a defined interface</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div><h3><a name="virNWFilterDefineXML" id="virNWFilterDefineXML"><code>virNWFilterDefineXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	virNWFilterDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xmlDesc)<br />
</pre><p>Define a new network filter, based on an XML description
similar to the one returned by virNWFilterGetXMLDesc()</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>an XML description of the nwfilter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new nwfilter object or NULL in case of failure</td></tr></tbody></table></div><h3><a name="virNWFilterFree" id="virNWFilterFree"><code>virNWFilterFree</code></a></h3><pre class="programlisting">int	virNWFilterFree			(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)<br />
</pre><p>Free the nwfilter object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNWFilterGetName" id="virNWFilterGetName"><code>virNWFilterGetName</code></a></h3><pre class="programlisting">const char *	virNWFilterGetName	(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)<br />
</pre><p>Get the public name for the network filter</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the nwfilter object.</td></tr></tbody></table></div><h3><a name="virNWFilterGetUUID" id="virNWFilterGetUUID"><code>virNWFilterGetUUID</code></a></h3><pre class="programlisting">int	virNWFilterGetUUID		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br />					 unsigned char * uuid)<br />
</pre><p>Get the UUID for a network filter</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virNWFilterGetUUIDString" id="virNWFilterGetUUIDString"><code>virNWFilterGetUUIDString</code></a></h3><pre class="programlisting">int	virNWFilterGetUUIDString	(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br />					 char * buf)<br />
</pre><p>Get the UUID for a network filter as string. For more information about
UUID see RFC4122.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virNWFilterGetXMLDesc" id="virNWFilterGetXMLDesc"><code>virNWFilterGetXMLDesc</code></a></h3><pre class="programlisting">char *	virNWFilterGetXMLDesc		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter, <br />					 int flags)<br />
</pre><p>Provide an XML description of the network filter. The description may be
reused later to redefine the network filter with virNWFilterCreateXML().</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>an OR'ed set of extraction flags, not used yet</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div><h3><a name="virNWFilterLookupByName" id="virNWFilterLookupByName"><code>virNWFilterLookupByName</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	virNWFilterLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * name)<br />
</pre><p>Try to lookup a network filter on the given hypervisor based on its name.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the network filter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new nwfilter object or NULL in case of failure. If the network filter cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NWFILTER">VIR_ERR_NO_NWFILTER</a> error is raised.</td></tr></tbody></table></div><h3><a name="virNWFilterLookupByUUID" id="virNWFilterLookupByUUID"><code>virNWFilterLookupByUUID</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	virNWFilterLookupByUUID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const unsigned char * uuid)<br />
</pre><p>Try to lookup a network filter on the given hypervisor based on its UUID.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>the raw UUID for the network filter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new nwfilter object or NULL in case of failure. If the nwfdilter cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NWFILTER">VIR_ERR_NO_NWFILTER</a> error is raised.</td></tr></tbody></table></div><h3><a name="virNWFilterLookupByUUIDString" id="virNWFilterLookupByUUIDString"><code>virNWFilterLookupByUUIDString</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a>	virNWFilterLookupByUUIDString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * uuidstr)<br />
</pre><p>Try to lookup an nwfilter on the given hypervisor based on its UUID.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>the string UUID for the nwfilter</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new nwfilter object or NULL in case of failure. If the nwfilter cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NWFILTER">VIR_ERR_NO_NWFILTER</a> error is raised.</td></tr></tbody></table></div><h3><a name="virNWFilterRef" id="virNWFilterRef"><code>virNWFilterRef</code></a></h3><pre class="programlisting">int	virNWFilterRef			(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)<br />
</pre><p>Increment the reference count on the nwfilter. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virNWFilterFree">virNWFilterFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using an nwfilter would increment
the reference count.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>the nwfilter to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNWFilterUndefine" id="virNWFilterUndefine"><code>virNWFilterUndefine</code></a></h3><pre class="programlisting">int	virNWFilterUndefine		(<a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> nwfilter)<br />
</pre><p>Undefine the nwfilter object. This call will not succeed if
a running VM is referencing the filter. This does not free the
associated <a href="libvirt-libvirt.html#virNWFilterPtr">virNWFilterPtr</a> object.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>nwfilter</tt></i>:</span></td><td>a nwfilter object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNetworkCreate" id="virNetworkCreate"><code>virNetworkCreate</code></a></h3><pre class="programlisting">int	virNetworkCreate		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br />
</pre><p>Create and start a defined network. If the call succeed the network
moves from the defined to the running networks pools.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>pointer to a defined network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div><h3><a name="virNetworkCreateXML" id="virNetworkCreateXML"><code>virNetworkCreateXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	virNetworkCreateXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xmlDesc)<br />
</pre><p>Create and start a new virtual network, based on an XML description
similar to the one returned by virNetworkGetXMLDesc()</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>an XML description of the network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new network object or NULL in case of failure</td></tr></tbody></table></div><h3><a name="virNetworkDefineXML" id="virNetworkDefineXML"><code>virNetworkDefineXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	virNetworkDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xml)<br />
</pre><p>Define a network, but does not create it</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>the XML description for the network, preferably in UTF-8</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, a pointer to the network otherwise</td></tr></tbody></table></div><h3><a name="virNetworkDestroy" id="virNetworkDestroy"><code>virNetworkDestroy</code></a></h3><pre class="programlisting">int	virNetworkDestroy		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br />
</pre><p>Destroy the network object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor. This
does not free the associated <a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> object.
This function may require privileged access</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNetworkFree" id="virNetworkFree"><code>virNetworkFree</code></a></h3><pre class="programlisting">int	virNetworkFree			(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br />
</pre><p>Free the network object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNetworkGetAutostart" id="virNetworkGetAutostart"><code>virNetworkGetAutostart</code></a></h3><pre class="programlisting">int	virNetworkGetAutostart		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br />					 int * autostart)<br />
</pre><p>Provides a boolean value indicating whether the network
configured to be automatically started when the host
machine boots.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>the value returned</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virNetworkGetBridgeName" id="virNetworkGetBridgeName"><code>virNetworkGetBridgeName</code></a></h3><pre class="programlisting">char *	virNetworkGetBridgeName		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br />
</pre><p>Provides a bridge interface name to which a domain may connect
a network interface in order to join the network.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated interface name, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div><h3><a name="virNetworkGetConnect" id="virNetworkGetConnect"><code>virNetworkGetConnect</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virNetworkGetConnect	(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net)<br />
</pre><p>Provides the connection pointer associated with a network. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function. Instead, store the connection and
the network object together.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>net</tt></i>:</span></td><td>pointer to a network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div><h3><a name="virNetworkGetName" id="virNetworkGetName"><code>virNetworkGetName</code></a></h3><pre class="programlisting">const char *	virNetworkGetName	(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br />
</pre><p>Get the public name for that network</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the network object.</td></tr></tbody></table></div><h3><a name="virNetworkGetUUID" id="virNetworkGetUUID"><code>virNetworkGetUUID</code></a></h3><pre class="programlisting">int	virNetworkGetUUID		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br />					 unsigned char * uuid)<br />
</pre><p>Get the UUID for a network</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virNetworkGetUUIDString" id="virNetworkGetUUIDString"><code>virNetworkGetUUIDString</code></a></h3><pre class="programlisting">int	virNetworkGetUUIDString		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br />					 char * buf)<br />
</pre><p>Get the UUID for a network as string. For more information about
UUID see RFC4122.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virNetworkGetXMLDesc" id="virNetworkGetXMLDesc"><code>virNetworkGetXMLDesc</code></a></h3><pre class="programlisting">char *	virNetworkGetXMLDesc		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br />					 int flags)<br />
</pre><p>Provide an XML description of the network. The description may be reused
later to relaunch the network with virNetworkCreateXML().</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>an OR'ed set of extraction flags, not used yet</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.</td></tr></tbody></table></div><h3><a name="virNetworkIsActive" id="virNetworkIsActive"><code>virNetworkIsActive</code></a></h3><pre class="programlisting">int	virNetworkIsActive		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net)<br />
</pre><p>Determine if the network is currently running</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>net</tt></i>:</span></td><td>pointer to the network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if running, 0 if inactive, -1 on error</td></tr></tbody></table></div><h3><a name="virNetworkIsPersistent" id="virNetworkIsPersistent"><code>virNetworkIsPersistent</code></a></h3><pre class="programlisting">int	virNetworkIsPersistent		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> net)<br />
</pre><p>Determine if the network has a persistent configuration
which means it will still exist after shutting down</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>net</tt></i>:</span></td><td>pointer to the network object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if persistent, 0 if transient, -1 on error</td></tr></tbody></table></div><h3><a name="virNetworkLookupByName" id="virNetworkLookupByName"><code>virNetworkLookupByName</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	virNetworkLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * name)<br />
</pre><p>Try to lookup a network on the given hypervisor based on its name.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new network object or NULL in case of failure. If the network cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NETWORK">VIR_ERR_NO_NETWORK</a> error is raised.</td></tr></tbody></table></div><h3><a name="virNetworkLookupByUUID" id="virNetworkLookupByUUID"><code>virNetworkLookupByUUID</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	virNetworkLookupByUUID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const unsigned char * uuid)<br />
</pre><p>Try to lookup a network on the given hypervisor based on its UUID.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>the raw UUID for the network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new network object or NULL in case of failure. If the network cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NETWORK">VIR_ERR_NO_NETWORK</a> error is raised.</td></tr></tbody></table></div><h3><a name="virNetworkLookupByUUIDString" id="virNetworkLookupByUUIDString"><code>virNetworkLookupByUUIDString</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a>	virNetworkLookupByUUIDString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * uuidstr)<br />
</pre><p>Try to lookup a network on the given hypervisor based on its UUID.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>the string UUID for the network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new network object or NULL in case of failure. If the network cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_NETWORK">VIR_ERR_NO_NETWORK</a> error is raised.</td></tr></tbody></table></div><h3><a name="virNetworkRef" id="virNetworkRef"><code>virNetworkRef</code></a></h3><pre class="programlisting">int	virNetworkRef			(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br />
</pre><p>Increment the reference count on the network. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virNetworkFree">virNetworkFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a network would increment
the reference count.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>the network to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNetworkSetAutostart" id="virNetworkSetAutostart"><code>virNetworkSetAutostart</code></a></h3><pre class="programlisting">int	virNetworkSetAutostart		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network, <br />					 int autostart)<br />
</pre><p>Configure the network to be automatically started
when the host machine boots.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>a network object</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>whether the network should be automatically started 0 or 1</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virNetworkUndefine" id="virNetworkUndefine"><code>virNetworkUndefine</code></a></h3><pre class="programlisting">int	virNetworkUndefine		(<a href="libvirt-libvirt.html#virNetworkPtr">virNetworkPtr</a> network)<br />
</pre><p>Undefine a network but does not stop it if it is running</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>network</tt></i>:</span></td><td>pointer to a defined network</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div><h3><a name="virNodeDeviceCreateXML" id="virNodeDeviceCreateXML"><code>virNodeDeviceCreateXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a>	virNodeDeviceCreateXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * xmlDesc, <br />						 unsigned int flags)<br />
</pre><p>Create a new device on the VM host machine, for example, virtual
HBAs created using vport_create.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the device to be created</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a node device object if successful, NULL in case of failure</td></tr></tbody></table></div><h3><a name="virNodeDeviceDestroy" id="virNodeDeviceDestroy"><code>virNodeDeviceDestroy</code></a></h3><pre class="programlisting">int	virNodeDeviceDestroy		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br />
</pre><p>Destroy the device object. The virtual device is removed from the host operating system.
This function may require privileged access</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>a device object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNodeDeviceDettach" id="virNodeDeviceDettach"><code>virNodeDeviceDettach</code></a></h3><pre class="programlisting">int	virNodeDeviceDettach		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br />
</pre><p>Dettach the node device from the node itself so that it may be
assigned to a guest domain.

Depending on the hypervisor, this may involve operations such
as unbinding any device drivers from the device, binding the
device to a dummy device driver and resetting the device.

If the device is currently in use by the node, this method may
fail.

Once the device is not assigned to any guest, it may be re-attached
to the node using the virNodeDeviceReattach() method.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNodeDeviceFree" id="virNodeDeviceFree"><code>virNodeDeviceFree</code></a></h3><pre class="programlisting">int	virNodeDeviceFree		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br />
</pre><p>Drops a reference to the node device, freeing it if
this was the last reference.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the 0 for success, -1 for error.</td></tr></tbody></table></div><h3><a name="virNodeDeviceGetName" id="virNodeDeviceGetName"><code>virNodeDeviceGetName</code></a></h3><pre class="programlisting">const char *	virNodeDeviceGetName	(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br />
</pre><p>Just return the device name</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the device name or NULL in case of error</td></tr></tbody></table></div><h3><a name="virNodeDeviceGetParent" id="virNodeDeviceGetParent"><code>virNodeDeviceGetParent</code></a></h3><pre class="programlisting">const char *	virNodeDeviceGetParent	(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br />
</pre><p>Accessor for the parent of the device</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the name of the device's parent, or NULL if the device has no parent.</td></tr></tbody></table></div><h3><a name="virNodeDeviceGetXMLDesc" id="virNodeDeviceGetXMLDesc"><code>virNodeDeviceGetXMLDesc</code></a></h3><pre class="programlisting">char *	virNodeDeviceGetXMLDesc		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br />					 unsigned int flags)<br />
</pre><p>Fetch an XML document describing all aspects of
the device.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags for XML generation (unused, pass 0)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the XML document, or NULL on error</td></tr></tbody></table></div><h3><a name="virNodeDeviceListCaps" id="virNodeDeviceListCaps"><code>virNodeDeviceListCaps</code></a></h3><pre class="programlisting">int	virNodeDeviceListCaps		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br />					 char ** const names, <br />					 int maxnames)<br />
</pre><p>Lists the names of the capabilities supported by the device.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of capability names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of capability names listed in @names.</td></tr></tbody></table></div><h3><a name="virNodeDeviceLookupByName" id="virNodeDeviceLookupByName"><code>virNodeDeviceLookupByName</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a>	virNodeDeviceLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const char * name)<br />
</pre><p>Lookup a node device by its name.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>unique device name</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> if found, NULL otherwise.</td></tr></tbody></table></div><h3><a name="virNodeDeviceNumOfCaps" id="virNodeDeviceNumOfCaps"><code>virNodeDeviceNumOfCaps</code></a></h3><pre class="programlisting">int	virNodeDeviceNumOfCaps		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br />
</pre><p>Accessor for the number of capabilities supported by the device.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of capabilities supported by the device.</td></tr></tbody></table></div><h3><a name="virNodeDeviceReAttach" id="virNodeDeviceReAttach"><code>virNodeDeviceReAttach</code></a></h3><pre class="programlisting">int	virNodeDeviceReAttach		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br />
</pre><p>Re-attach a previously dettached node device to the node so that it
may be used by the node again.

Depending on the hypervisor, this may involve operations such
as resetting the device, unbinding it from a dummy device driver
and binding it to its appropriate driver.

If the device is currently in use by a guest, this method may fail.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNodeDeviceRef" id="virNodeDeviceRef"><code>virNodeDeviceRef</code></a></h3><pre class="programlisting">int	virNodeDeviceRef		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br />
</pre><p>Increment the reference count on the dev. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virNodeDeviceFree">virNodeDeviceFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a dev would increment
the reference count.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the dev to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNodeDeviceReset" id="virNodeDeviceReset"><code>virNodeDeviceReset</code></a></h3><pre class="programlisting">int	virNodeDeviceReset		(<a href="libvirt-libvirt.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br />
</pre><p>Reset a previously dettached node device to the node before or
after assigning it to a guest.

The exact reset semantics depends on the hypervisor and device
type but, for example, KVM will attempt to reset PCI devices with
a Function Level Reset, Secondary Bus Reset or a Power Management
D-State reset.

If the reset will affect other devices which are currently in use,
this function may fail.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNodeGetCellsFreeMemory" id="virNodeGetCellsFreeMemory"><code>virNodeGetCellsFreeMemory</code></a></h3><pre class="programlisting">int	virNodeGetCellsFreeMemory	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 unsigned long long * freeMems, <br />					 int startCell, <br />					 int maxCells)<br />
</pre><p>This call returns the amount of free memory in one or more NUMA cells.
The @freeMems array must be allocated by the caller and will be filled
with the amount of free memory in bytes for each cell requested,
starting with startCell (in freeMems[0]), up to either
(startCell + maxCells), or the number of additional cells in the node,
whichever is smaller.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>freeMems</tt></i>:</span></td><td>pointer to the array of unsigned long long</td></tr><tr><td><span class="term"><i><tt>startCell</tt></i>:</span></td><td>index of first cell to return freeMems info on.</td></tr><tr><td><span class="term"><i><tt>maxCells</tt></i>:</span></td><td>Maximum number of cells for which freeMems information can be returned.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of entries filled in freeMems, or -1 in case of error.</td></tr></tbody></table></div><h3><a name="virNodeGetFreeMemory" id="virNodeGetFreeMemory"><code>virNodeGetFreeMemory</code></a></h3><pre class="programlisting">unsigned long long	virNodeGetFreeMemory	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn)<br />
</pre><p>provides the free memory available on the Node
Note: most libvirt APIs provide memory sizes in kilobytes, but in this
function the returned value is in bytes. Divide by 1024 as necessary.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the available free memory in bytes or 0 in case of error</td></tr></tbody></table></div><h3><a name="virNodeGetInfo" id="virNodeGetInfo"><code>virNodeGetInfo</code></a></h3><pre class="programlisting">int	virNodeGetInfo			(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 <a href="libvirt-libvirt.html#virNodeInfoPtr">virNodeInfoPtr</a> info)<br />
</pre><p>Extract hardware information about the node.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virNodeInfo">virNodeInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virNodeGetSecurityModel" id="virNodeGetSecurityModel"><code>virNodeGetSecurityModel</code></a></h3><pre class="programlisting">int	virNodeGetSecurityModel		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 <a href="libvirt-libvirt.html#virSecurityModelPtr">virSecurityModelPtr</a> secmodel)<br />
</pre><p>Extract the security model of a hypervisor. The 'model' field
in the @secmodel argument may be initialized to the empty
string if the driver has not activated a security model.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>a connection object</td></tr><tr><td><span class="term"><i><tt>secmodel</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#virSecurityModel">virSecurityModel</a> structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure</td></tr></tbody></table></div><h3><a name="virNodeListDevices" id="virNodeListDevices"><code>virNodeListDevices</code></a></h3><pre class="programlisting">int	virNodeListDevices		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * cap, <br />					 char ** const names, <br />					 int maxnames, <br />					 unsigned int flags)<br />
</pre><p>Collect the list of node devices, and store their names in @names

If the optional 'cap' argument is non-NULL, then the count
will be restricted to devices with the specified capability</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>cap</tt></i>:</span></td><td>capability name</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of node device names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags (unused, pass 0)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of node devices found or -1 in case of error</td></tr></tbody></table></div><h3><a name="virNodeNumOfDevices" id="virNodeNumOfDevices"><code>virNodeNumOfDevices</code></a></h3><pre class="programlisting">int	virNodeNumOfDevices		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * cap, <br />					 unsigned int flags)<br />
</pre><p>Provides the number of node devices.

If the optional 'cap' argument is non-NULL, then the count
will be restricted to devices with the specified capability</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>cap</tt></i>:</span></td><td>capability name</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags (unused, pass 0)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of node devices or -1 in case of error</td></tr></tbody></table></div><h3><a name="virSecretDefineXML" id="virSecretDefineXML"><code>virSecretDefineXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	virSecretDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const char * xml, <br />					 unsigned int flags)<br />
</pre><p>If XML specifies a UUID, locates the specified secret and replaces all
attributes of the secret specified by UUID by attributes specified in xml
(any attributes not specified in xml are discarded).

Otherwise, creates a new secret with an automatically chosen UUID, and
initializes its attributes from xml.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>XML describing the secret.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a the secret on success, NULL on failure.</td></tr></tbody></table></div><h3><a name="virSecretFree" id="virSecretFree"><code>virSecretFree</code></a></h3><pre class="programlisting">int	virSecretFree			(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br />
</pre><p>Release the secret handle. The underlying secret continues to exist.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>pointer to a secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error</td></tr></tbody></table></div><h3><a name="virSecretGetConnect" id="virSecretGetConnect"><code>virSecretGetConnect</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virSecretGetConnect	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br />
</pre><p>Provides the connection pointer associated with a secret. The reference
counter on the connection is not increased by this call.

WARNING: When writing libvirt bindings in other languages, do not use this
function. Instead, store the connection and the secret object together.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div><h3><a name="virSecretGetUUID" id="virSecretGetUUID"><code>virSecretGetUUID</code></a></h3><pre class="programlisting">int	virSecretGetUUID		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br />					 unsigned char * uuid)<br />
</pre><p>Fetches the UUID of the secret.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>buffer of <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes in size</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success with the uuid buffer being filled, or -1 upon failure.</td></tr></tbody></table></div><h3><a name="virSecretGetUUIDString" id="virSecretGetUUIDString"><code>virSecretGetUUIDString</code></a></h3><pre class="programlisting">int	virSecretGetUUIDString		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br />					 char * buf)<br />
</pre><p>Get the UUID for a secret as string. For more information about
UUID see RFC4122.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>a secret object</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div><h3><a name="virSecretGetUsageID" id="virSecretGetUsageID"><code>virSecretGetUsageID</code></a></h3><pre class="programlisting">const char *	virSecretGetUsageID	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br />
</pre><p>Get the unique identifier of the object with which this
secret is to be used. The format of the identifier is
dependant on the usage type of the secret. For a secret
with a usage type of <a href="libvirt-libvirt.html#VIR_SECRET_USAGE_TYPE_VOLUME">VIR_SECRET_USAGE_TYPE_VOLUME</a> the
identifier will be a fully qualfied path name. The
identifiers are intended to be unique within the set of
all secrets sharing the same usage type. ie, there shall
only ever be one secret for each volume path.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>a secret object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a string identifying the object using the secret, or NULL upon error</td></tr></tbody></table></div><h3><a name="virSecretGetUsageType" id="virSecretGetUsageType"><code>virSecretGetUsageType</code></a></h3><pre class="programlisting">int	virSecretGetUsageType		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br />
</pre><p>Get the type of object which uses this secret. The returned
value is one of the constants defined in the virSecretUsageType
enumeration. More values may be added to this enumeration in
the future, so callers should expect to see usage types they
do not explicitly know about.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>a secret object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a positive integer identifying the type of object, or -1 upon error.</td></tr></tbody></table></div><h3><a name="virSecretGetValue" id="virSecretGetValue"><code>virSecretGetValue</code></a></h3><pre class="programlisting">unsigned char *	virSecretGetValue	(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br />					 size_t * value_size, <br />					 unsigned int flags)<br />
</pre><p>Fetches the value of a secret.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> connection</td></tr><tr><td><span class="term"><i><tt>value_size</tt></i>:</span></td><td>Place for storing size of the secret value</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the secret value on success, NULL on failure. The caller must free() the secret value.</td></tr></tbody></table></div><h3><a name="virSecretGetXMLDesc" id="virSecretGetXMLDesc"><code>virSecretGetXMLDesc</code></a></h3><pre class="programlisting">char *	virSecretGetXMLDesc		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br />					 unsigned int flags)<br />
</pre><p>Fetches an XML document describing attributes of the secret.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the XML document on success, NULL on failure. The caller must free() the XML.</td></tr></tbody></table></div><h3><a name="virSecretLookupByUUID" id="virSecretLookupByUUID"><code>virSecretLookupByUUID</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	virSecretLookupByUUID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 const unsigned char * uuid)<br />
</pre><p>Try to lookup a secret on the given hypervisor based on its UUID.
Uses the 16 bytes of raw data to describe the UUID</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>the raw UUID for the secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new secret object or NULL in case of failure. If the secret cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_SECRET">VIR_ERR_NO_SECRET</a> error is raised.</td></tr></tbody></table></div><h3><a name="virSecretLookupByUUIDString" id="virSecretLookupByUUIDString"><code>virSecretLookupByUUIDString</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	virSecretLookupByUUIDString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * uuidstr)<br />
</pre><p>Try to lookup a secret on the given hypervisor based on its UUID.
Uses the printable string value to describe the UUID</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>the string UUID for the secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new secret object or NULL in case of failure. If the secret cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_SECRET">VIR_ERR_NO_SECRET</a> error is raised.</td></tr></tbody></table></div><h3><a name="virSecretLookupByUsage" id="virSecretLookupByUsage"><code>virSecretLookupByUsage</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a>	virSecretLookupByUsage	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 int usageType, <br />					 const char * usageID)<br />
</pre><p>Try to lookup a secret on the given hypervisor based on its usage
The usageID is unique within the set of secrets sharing the
same usageType value.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>usageType</tt></i>:</span></td><td>the type of secret usage</td></tr><tr><td><span class="term"><i><tt>usageID</tt></i>:</span></td><td>identifier of the object using the secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new secret object or NULL in case of failure. If the secret cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_SECRET">VIR_ERR_NO_SECRET</a> error is raised.</td></tr></tbody></table></div><h3><a name="virSecretRef" id="virSecretRef"><code>virSecretRef</code></a></h3><pre class="programlisting">int	virSecretRef			(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br />
</pre><p>Increment the reference count on the secret. For each additional call to
this method, there shall be a corresponding call to <a href="libvirt-libvirt.html#virSecretFree">virSecretFree</a> to release
the reference count, once the caller no longer needs the reference to this
object.

This method is typically useful for applications where multiple threads are
using a connection, and it is required that the connection remain open until
all threads have finished using it. ie, each new thread using a secret would
increment the reference count.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>the secret to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virSecretSetValue" id="virSecretSetValue"><code>virSecretSetValue</code></a></h3><pre class="programlisting">int	virSecretSetValue		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret, <br />					 const unsigned char * value, <br />					 size_t value_size, <br />					 unsigned int flags)<br />
</pre><p>Sets the value of a secret.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>Value of the secret</td></tr><tr><td><span class="term"><i><tt>value_size</tt></i>:</span></td><td>Size of the value</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div><h3><a name="virSecretUndefine" id="virSecretUndefine"><code>virSecretUndefine</code></a></h3><pre class="programlisting">int	virSecretUndefine		(<a href="libvirt-libvirt.html#virSecretPtr">virSecretPtr</a> secret)<br />
</pre><p>Deletes the specified secret. This does not free the associated
virSecretPtr object.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>secret</tt></i>:</span></td><td>A <a href="libvirt-libvirt.html#virSecret">virSecret</a> secret</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div><h3><a name="virStoragePoolBuild" id="virStoragePoolBuild"><code>virStoragePoolBuild</code></a></h3><pre class="programlisting">int	virStoragePoolBuild		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned int flags)<br />
</pre><p>Build the underlying storage pool</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>future flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 upon failure</td></tr></tbody></table></div><h3><a name="virStoragePoolCreate" id="virStoragePoolCreate"><code>virStoragePoolCreate</code></a></h3><pre class="programlisting">int	virStoragePoolCreate		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned int flags)<br />
</pre><p>Starts an inactive storage pool</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>future flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 if it could not be started</td></tr></tbody></table></div><h3><a name="virStoragePoolCreateXML" id="virStoragePoolCreateXML"><code>virStoragePoolCreateXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolCreateXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * xmlDesc, <br />						 unsigned int flags)<br />
</pre><p>Create a new storage based on its XML description. The
pool is not persistent, so its definition will disappear
when it is destroyed, or if the host is restarted</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>XML description for new pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>future flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if creation failed</td></tr></tbody></table></div><h3><a name="virStoragePoolDefineXML" id="virStoragePoolDefineXML"><code>virStoragePoolDefineXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolDefineXML	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />						 const char * xml, <br />						 unsigned int flags)<br />
</pre><p>Define a new inactive storage pool based on its XML description. The
pool is persistent, until explicitly undefined.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>XML description for new pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>future flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if creation failed</td></tr></tbody></table></div><h3><a name="virStoragePoolDelete" id="virStoragePoolDelete"><code>virStoragePoolDelete</code></a></h3><pre class="programlisting">int	virStoragePoolDelete		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned int flags)<br />
</pre><p>Delete the underlying pool resources. This is
a non-recoverable operation. The <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object
itself is not free'd.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags for obliteration process</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 if it could not be obliterate</td></tr></tbody></table></div><h3><a name="virStoragePoolDestroy" id="virStoragePoolDestroy"><code>virStoragePoolDestroy</code></a></h3><pre class="programlisting">int	virStoragePoolDestroy		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br />
</pre><p>Destroy an active storage pool. This will deactivate the
pool on the host, but keep any persistent config associated
with it. If it has a persistent config it can later be
restarted with virStoragePoolCreate(). This does not free
the associated <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 if it could not be destroyed</td></tr></tbody></table></div><h3><a name="virStoragePoolFree" id="virStoragePoolFree"><code>virStoragePoolFree</code></a></h3><pre class="programlisting">int	virStoragePoolFree		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br />
</pre><p>Free a storage pool object, releasing all memory associated with
it. Does not change the state of the pool on the host.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 if it could not be free'd.</td></tr></tbody></table></div><h3><a name="virStoragePoolGetAutostart" id="virStoragePoolGetAutostart"><code>virStoragePoolGetAutostart</code></a></h3><pre class="programlisting">int	virStoragePoolGetAutostart	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 int * autostart)<br />
</pre><p>Fetches the value of the autostart flag, which determines
whether the pool is automatically started at boot time</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>location in which to store autostart flag</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div><h3><a name="virStoragePoolGetConnect" id="virStoragePoolGetConnect"><code>virStoragePoolGetConnect</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virStoragePoolGetConnect	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br />
</pre><p>Provides the connection pointer associated with a storage pool. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function. Instead, store the connection and
the pool object together.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to a pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div><h3><a name="virStoragePoolGetInfo" id="virStoragePoolGetInfo"><code>virStoragePoolGetInfo</code></a></h3><pre class="programlisting">int	virStoragePoolGetInfo		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 <a href="libvirt-libvirt.html#virStoragePoolInfoPtr">virStoragePoolInfoPtr</a> info)<br />
</pre><p>Get volatile information about the storage pool
such as free space / usage summary</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer at which to store info</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on failure.</td></tr></tbody></table></div><h3><a name="virStoragePoolGetName" id="virStoragePoolGetName"><code>virStoragePoolGetName</code></a></h3><pre class="programlisting">const char *	virStoragePoolGetName	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br />
</pre><p>Fetch the locally unique name of the storage pool</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the name of the pool, or NULL on error</td></tr></tbody></table></div><h3><a name="virStoragePoolGetUUID" id="virStoragePoolGetUUID"><code>virStoragePoolGetUUID</code></a></h3><pre class="programlisting">int	virStoragePoolGetUUID		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned char * uuid)<br />
</pre><p>Fetch the globally unique ID of the storage pool</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>buffer of <a href="libvirt-libvirt.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes in size</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error;</td></tr></tbody></table></div><h3><a name="virStoragePoolGetUUIDString" id="virStoragePoolGetUUIDString"><code>virStoragePoolGetUUIDString</code></a></h3><pre class="programlisting">int	virStoragePoolGetUUIDString	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 char * buf)<br />
</pre><p>Fetch the globally unique ID of the storage pool as a string</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>buffer of <a href="libvirt-libvirt.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes in size</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error;</td></tr></tbody></table></div><h3><a name="virStoragePoolGetXMLDesc" id="virStoragePoolGetXMLDesc"><code>virStoragePoolGetXMLDesc</code></a></h3><pre class="programlisting">char *	virStoragePoolGetXMLDesc	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned int flags)<br />
</pre><p>Fetch an XML document describing all aspects of the
storage pool. This is suitable for later feeding back
into the <a href="libvirt-libvirt.html#virStoragePoolCreateXML">virStoragePoolCreateXML</a> method.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags for XML format options (set of virDomainXMLFlags)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a XML document, or NULL on error</td></tr></tbody></table></div><h3><a name="virStoragePoolIsActive" id="virStoragePoolIsActive"><code>virStoragePoolIsActive</code></a></h3><pre class="programlisting">int	virStoragePoolIsActive		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br />
</pre><p>Determine if the storage pool is currently running</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to the storage pool object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if running, 0 if inactive, -1 on error</td></tr></tbody></table></div><h3><a name="virStoragePoolIsPersistent" id="virStoragePoolIsPersistent"><code>virStoragePoolIsPersistent</code></a></h3><pre class="programlisting">int	virStoragePoolIsPersistent	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br />
</pre><p>Determine if the storage pool has a persistent configuration
which means it will still exist after shutting down</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to the storage pool object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if persistent, 0 if transient, -1 on error</td></tr></tbody></table></div><h3><a name="virStoragePoolListVolumes" id="virStoragePoolListVolumes"><code>virStoragePoolListVolumes</code></a></h3><pre class="programlisting">int	virStoragePoolListVolumes	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 char ** const names, <br />					 int maxnames)<br />
</pre><p>Fetch list of storage volume names, limiting to
at most maxnames.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array in which to storage volume names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of names array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of names fetched, or -1 on error</td></tr></tbody></table></div><h3><a name="virStoragePoolLookupByName" id="virStoragePoolLookupByName"><code>virStoragePoolLookupByName</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolLookupByName	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const char * name)<br />
</pre><p>Fetch a storage pool based on its unique name</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of pool to fetch</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</td></tr></tbody></table></div><h3><a name="virStoragePoolLookupByUUID" id="virStoragePoolLookupByUUID"><code>virStoragePoolLookupByUUID</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolLookupByUUID	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const unsigned char * uuid)<br />
</pre><p>Fetch a storage pool based on its globally unique id</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>globally unique id of pool to fetch</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</td></tr></tbody></table></div><h3><a name="virStoragePoolLookupByUUIDString" id="virStoragePoolLookupByUUIDString"><code>virStoragePoolLookupByUUIDString</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolLookupByUUIDString	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const char * uuidstr)<br />
</pre><p>Fetch a storage pool based on its globally unique id</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>globally unique id of pool to fetch</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</td></tr></tbody></table></div><h3><a name="virStoragePoolLookupByVolume" id="virStoragePoolLookupByVolume"><code>virStoragePoolLookupByVolume</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a>	virStoragePoolLookupByVolume	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br />
</pre><p>Fetch a storage pool which contains a particular volume</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> object, or NULL if no matching pool is found</td></tr></tbody></table></div><h3><a name="virStoragePoolNumOfVolumes" id="virStoragePoolNumOfVolumes"><code>virStoragePoolNumOfVolumes</code></a></h3><pre class="programlisting">int	virStoragePoolNumOfVolumes	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br />
</pre><p>Fetch the number of storage volumes within a pool</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of storage pools, or -1 on failure</td></tr></tbody></table></div><h3><a name="virStoragePoolRef" id="virStoragePoolRef"><code>virStoragePoolRef</code></a></h3><pre class="programlisting">int	virStoragePoolRef		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br />
</pre><p>Increment the reference count on the pool. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virStoragePoolFree">virStoragePoolFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a pool would increment
the reference count.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>the pool to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virStoragePoolRefresh" id="virStoragePoolRefresh"><code>virStoragePoolRefresh</code></a></h3><pre class="programlisting">int	virStoragePoolRefresh		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 unsigned int flags)<br />
</pre><p>Request that the pool refresh its list of volumes. This may
involve communicating with a remote server, and/or initializing
new devices at the OS layer</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags to control refresh behaviour (currently unused, use 0)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the volume list was refreshed, -1 on failure</td></tr></tbody></table></div><h3><a name="virStoragePoolSetAutostart" id="virStoragePoolSetAutostart"><code>virStoragePoolSetAutostart</code></a></h3><pre class="programlisting">int	virStoragePoolSetAutostart	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />					 int autostart)<br />
</pre><p>Sets the autostart flag</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>new flag setting</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div><h3><a name="virStoragePoolUndefine" id="virStoragePoolUndefine"><code>virStoragePoolUndefine</code></a></h3><pre class="programlisting">int	virStoragePoolUndefine		(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool)<br />
</pre><p>Undefine an inactive storage pool</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div><h3><a name="virStorageVolCreateXML" id="virStorageVolCreateXML"><code>virStorageVolCreateXML</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	virStorageVolCreateXML	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />						 const char * xmldesc, <br />						 unsigned int flags)<br />
</pre><p>Create a storage volume within a pool based
on an XML description. Not all pools support
creation of volumes</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>xmldesc</tt></i>:</span></td><td>description of volume to create</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags for creation (unused, pass 0)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the storage volume, or NULL on error</td></tr></tbody></table></div><h3><a name="virStorageVolCreateXMLFrom" id="virStorageVolCreateXMLFrom"><code>virStorageVolCreateXMLFrom</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	virStorageVolCreateXMLFrom	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />							 const char * xmldesc, <br />							 <a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> clonevol, <br />							 unsigned int flags)<br />
</pre><p>Create a storage volume in the parent pool, using the
'clonevol' volume as input. Information for the new
volume (name, perms) are passed via a typical volume
XML description.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to parent pool for the new volume</td></tr><tr><td><span class="term"><i><tt>xmldesc</tt></i>:</span></td><td>description of volume to create</td></tr><tr><td><span class="term"><i><tt>clonevol</tt></i>:</span></td><td>storage volume to use as input</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags for creation (unused, pass 0)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the storage volume, or NULL on error</td></tr></tbody></table></div><h3><a name="virStorageVolDelete" id="virStorageVolDelete"><code>virStorageVolDelete</code></a></h3><pre class="programlisting">int	virStorageVolDelete		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br />					 unsigned int flags)<br />
</pre><p>Delete the storage volume from the pool</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>future flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error</td></tr></tbody></table></div><h3><a name="virStorageVolFree" id="virStorageVolFree"><code>virStorageVolFree</code></a></h3><pre class="programlisting">int	virStorageVolFree		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br />
</pre><p>Release the storage volume handle. The underlying
storage volume continues to exist.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error</td></tr></tbody></table></div><h3><a name="virStorageVolGetConnect" id="virStorageVolGetConnect"><code>virStorageVolGetConnect</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a>	virStorageVolGetConnect	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br />
</pre><p>Provides the connection pointer associated with a storage volume. The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function. Instead, store the connection and
the volume object together.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to a pool</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div><h3><a name="virStorageVolGetInfo" id="virStorageVolGetInfo"><code>virStorageVolGetInfo</code></a></h3><pre class="programlisting">int	virStorageVolGetInfo		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br />					 <a href="libvirt-libvirt.html#virStorageVolInfoPtr">virStorageVolInfoPtr</a> info)<br />
</pre><p>Fetches volatile information about the storage
volume such as its current allocation</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer at which to store info</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on failure</td></tr></tbody></table></div><h3><a name="virStorageVolGetKey" id="virStorageVolGetKey"><code>virStorageVolGetKey</code></a></h3><pre class="programlisting">const char *	virStorageVolGetKey	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br />
</pre><p>Fetch the storage volume key. This is globally
unique, so the same volume will have the same
key no matter what host it is accessed from</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the volume key, or NULL on error</td></tr></tbody></table></div><h3><a name="virStorageVolGetName" id="virStorageVolGetName"><code>virStorageVolGetName</code></a></h3><pre class="programlisting">const char *	virStorageVolGetName	(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br />
</pre><p>Fetch the storage volume name. This is unique
within the scope of a pool</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the volume name, or NULL on error</td></tr></tbody></table></div><h3><a name="virStorageVolGetPath" id="virStorageVolGetPath"><code>virStorageVolGetPath</code></a></h3><pre class="programlisting">char *	virStorageVolGetPath		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br />
</pre><p>Fetch the storage volume path. Depending on the pool
configuration this is either persistent across hosts,
or dynamically assigned at pool startup. Consult
pool documentation for information on getting the
persistent naming</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the storage volume path, or NULL on error</td></tr></tbody></table></div><h3><a name="virStorageVolGetXMLDesc" id="virStorageVolGetXMLDesc"><code>virStorageVolGetXMLDesc</code></a></h3><pre class="programlisting">char *	virStorageVolGetXMLDesc		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br />					 unsigned int flags)<br />
</pre><p>Fetch an XML document describing all aspects of
the storage volume</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>flags for XML generation (unused, pass 0)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the XML document, or NULL on error</td></tr></tbody></table></div><h3><a name="virStorageVolLookupByKey" id="virStorageVolLookupByKey"><code>virStorageVolLookupByKey</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	virStorageVolLookupByKey	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const char * key)<br />
</pre><p>Fetch a pointer to a storage volume based on its
globally unique key</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>key</tt></i>:</span></td><td>globally unique key</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a storage volume, or NULL if not found / error</td></tr></tbody></table></div><h3><a name="virStorageVolLookupByName" id="virStorageVolLookupByName"><code>virStorageVolLookupByName</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	virStorageVolLookupByName	(<a href="libvirt-libvirt.html#virStoragePoolPtr">virStoragePoolPtr</a> pool, <br />							 const char * name)<br />
</pre><p>Fetch a pointer to a storage volume based on its name
within a pool</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pool</tt></i>:</span></td><td>pointer to storage pool</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name of storage volume</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a storage volume, or NULL if not found / error</td></tr></tbody></table></div><h3><a name="virStorageVolLookupByPath" id="virStorageVolLookupByPath"><code>virStorageVolLookupByPath</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a>	virStorageVolLookupByPath	(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />							 const char * path)<br />
</pre><p>Fetch a pointer to a storage volume based on its
locally (host) unique path</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to hypervisor connection</td></tr><tr><td><span class="term"><i><tt>path</tt></i>:</span></td><td>locally unique path</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a storage volume, or NULL if not found / error</td></tr></tbody></table></div><h3><a name="virStorageVolRef" id="virStorageVolRef"><code>virStorageVolRef</code></a></h3><pre class="programlisting">int	virStorageVolRef		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol)<br />
</pre><p>Increment the reference count on the vol. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virStorageVolFree">virStorageVolFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a vol would increment
the reference count.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>the vol to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div><h3><a name="virStorageVolWipe" id="virStorageVolWipe"><code>virStorageVolWipe</code></a></h3><pre class="programlisting">int	virStorageVolWipe		(<a href="libvirt-libvirt.html#virStorageVolPtr">virStorageVolPtr</a> vol, <br />					 unsigned int flags)<br />
</pre><p>Ensure data previously on a volume is not accessible to future reads</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>vol</tt></i>:</span></td><td>pointer to storage volume</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>future flags, use 0 for now</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, or -1 on error</td></tr></tbody></table></div><h3><a name="virStreamAbort" id="virStreamAbort"><code>virStreamAbort</code></a></h3><pre class="programlisting">int	virStreamAbort			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)<br />
</pre><p>Request that the in progress data transfer be cancelled
abnormally before the end of the stream has been reached.
For output streams this can be used to inform the driver
that the stream is being terminated early. For input
streams this can be used to inform the driver that it
should stop sending data.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div><h3><a name="virStreamEventAddCallback" id="virStreamEventAddCallback"><code>virStreamEventAddCallback</code></a></h3><pre class="programlisting">int	virStreamEventAddCallback	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 int events, <br />					 <a href="libvirt-libvirt.html#virStreamEventCallback">virStreamEventCallback</a> cb, <br />					 void * opaque, <br />					 <a href="libvirt-libvirt.html#virFreeCallback">virFreeCallback</a> ff)<br />
</pre><p>Register a callback to be notified when a stream
becomes writable, or readable. This is most commonly
used in conjunction with non-blocking data streams
to integrate into an event loop</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>set of events to monitor</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to invoke when an event occurs</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>ff</tt></i>:</span></td><td>callback to free @opaque data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div><h3><a name="virStreamEventCallback" id="virStreamEventCallback"><code>virStreamEventCallback</code></a></h3><pre class="programlisting">typedef void	(*virStreamEventCallback	)	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 int events, <br />					 void * opaque)
</pre><p>Callback for receiving stream events. The callback will
be invoked once for each event which is pending.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>stream on which the event occurred</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>bitset of events from <a href="libvirt-libvirt.html#virEventHandleType">virEventHandleType</a> constants</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data registered with handle</td></tr></tbody></table></div><br /><h3><a name="virStreamEventRemoveCallback" id="virStreamEventRemoveCallback"><code>virStreamEventRemoveCallback</code></a></h3><pre class="programlisting">int	virStreamEventRemoveCallback	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)<br />
</pre><p>Remove an event callback from the stream</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error</td></tr></tbody></table></div><h3><a name="virStreamEventUpdateCallback" id="virStreamEventUpdateCallback"><code>virStreamEventUpdateCallback</code></a></h3><pre class="programlisting">int	virStreamEventUpdateCallback	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 int events)<br />
</pre><p>Changes the set of events to monitor for a stream. This allows
for event notification to be changed without having to
unregister &amp; register the callback completely. This method
is guarenteed to succeed if a callback is already registered</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>set of events to monitor</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 if no callback is registered</td></tr></tbody></table></div><h3><a name="virStreamFinish" id="virStreamFinish"><code>virStreamFinish</code></a></h3><pre class="programlisting">int	virStreamFinish			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)<br />
</pre><p>Indicate that there is no further data is to be transmitted
on the stream. For output streams this should be called once
all data has been written. For input streams this should be
called once <a href="libvirt-libvirt.html#virStreamRecv">virStreamRecv</a> returns end-of-file.

This method is a synchronization point for all asynchronous
errors, so if this returns a success code the application can
be sure that all data has been successfully processed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div><h3><a name="virStreamFree" id="virStreamFree"><code>virStreamFree</code></a></h3><pre class="programlisting">int	virStreamFree			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)<br />
</pre><p>Decrement the reference count on a stream, releasing
the stream object if the reference count has hit zero.

There must not be an active data transfer in progress
when releasing the stream. If a stream needs to be
disposed of prior to end of stream being reached, then
the <a href="libvirt-libvirt.html#virStreamAbort">virStreamAbort</a> function should be called first.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 upon success, or -1 on error</td></tr></tbody></table></div><h3><a name="virStreamNew" id="virStreamNew"><code>virStreamNew</code></a></h3><pre class="programlisting"><a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a>	virStreamNew		(<a href="libvirt-libvirt.html#virConnectPtr">virConnectPtr</a> conn, <br />					 unsigned int flags)<br />
</pre><p>Creates a new stream object which can be used to perform
streamed I/O with other public API function.

When no longer needed, a stream object must be released
with virStreamFree. If a data stream has been used,
then the application must call <a href="libvirt-libvirt.html#virStreamFinish">virStreamFinish</a> or
virStreamAbort before free'ing to, in order to notify
the driver of termination.

If a non-blocking data stream is required passed
VIR_STREAM_NONBLOCK for flags, otherwise pass 0.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>control features of the stream</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new stream, or NULL upon error</td></tr></tbody></table></div><h3><a name="virStreamRecv" id="virStreamRecv"><code>virStreamRecv</code></a></h3><pre class="programlisting">int	virStreamRecv			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 char * data, <br />					 size_t nbytes)<br />
</pre><p>Write a series of bytes to the stream. This method may
block the calling application for an arbitrary amount
of time.

Errors are not guaranteed to be reported synchronously
with the call, but may instead be delayed until a
subsequent call.

An example using this with a hypothetical file download
API looks like

 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_WRONLY, 0600)

 virConnectDownloadFile(conn, "demo.iso", st);

 while (1) {
 char buf[1024];
 int got = virStreamRecv(st, buf, 1024);
 if (got &lt; 0)
 break;
 if (got == 0) {
 virStreamFinish(st);
 break;
 }
 int offset = 0;
 while (offset &lt; got) {
 int sent = write(fd, buf+offset, got-offset)
 if (sent &lt; 0) {
 virStreamAbort(st);
 goto done;
 }
 offset += sent;
 }
 }
 if (virStreamFinish(st) &lt; 0)
 ... report an error ....
done:
 virStreamFree(st);
 close(fd);</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>buffer to write to stream</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of @data buffer</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes read, which may be less than requested. Returns 0 when the end of the stream is reached, at which time the caller should invoke virStreamFinish() to get confirmation of stream completion. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree. Returns -2 if there is no data pending to be read &amp; the stream is marked as non-blocking.</td></tr></tbody></table></div><h3><a name="virStreamRecvAll" id="virStreamRecvAll"><code>virStreamRecvAll</code></a></h3><pre class="programlisting">int	virStreamRecvAll		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 <a href="libvirt-libvirt.html#virStreamSinkFunc">virStreamSinkFunc</a> handler, <br />					 void * opaque)<br />
</pre><p>Receive the entire data stream, sending the data to the
requested data sink. This is simply a convenient alternative
to virStreamRecv, for apps that do blocking-I/o.

An example using this with a hypothetical file download
API looks like

 int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {
 int *fd = opaque;

 return write(*fd, buf, nbytes);
 }

 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_WRONLY)

 virConnectUploadFile(conn, st);
 if (virStreamRecvAll(st, mysink, &amp;fd) &lt; 0) {
 ...report an error ...
 goto done;
 }
 if (virStreamFinish(st) &lt; 0)
 ...report an error...
 virStreamFree(st);
 close(fd);</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>handler</tt></i>:</span></td><td>sink callback for writing data to application</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a> Returns -1 upon any error, with virStreamAbort() already having been called, so the caller need only call virStreamFree()</td></tr></tbody></table></div><h3><a name="virStreamRef" id="virStreamRef"><code>virStreamRef</code></a></h3><pre class="programlisting">int	virStreamRef			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream)<br />
</pre><p>Increment the reference count on the stream. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a> to release the reference count, once
the caller no longer needs the reference to this object.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure</td></tr></tbody></table></div><h3><a name="virStreamSend" id="virStreamSend"><code>virStreamSend</code></a></h3><pre class="programlisting">int	virStreamSend			(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 const char * data, <br />					 size_t nbytes)<br />
</pre><p>Write a series of bytes to the stream. This method may
block the calling application for an arbitrary amount
of time. Once an application has finished sending data
it should call <a href="libvirt-libvirt.html#virStreamFinish">virStreamFinish</a> to wait for successful
confirmation from the driver, or detect any error

This method may not be used if a stream source has been
registered

Errors are not guaranteed to be reported synchronously
with the call, but may instead be delayed until a
subsequent call.

An example using this with a hypothetical file upload
API looks like

 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_RDONLY)

 virConnectUploadFile(conn, "demo.iso", st);

 while (1) {
 char buf[1024];
 int got = read(fd, buf, 1024);
 if (got &lt; 0) {
 virStreamAbort(st);
 break;
 }
 if (got == 0) {
 virStreamFinish(st);
 break;
 }
 int offset = 0;
 while (offset &lt; got) {
 int sent = virStreamSend(st, buf+offset, got-offset)
 if (sent &lt; 0) {
 virStreamAbort(st);
 goto done;
 }
 offset += sent;
 }
 }
 if (virStreamFinish(st) &lt; 0)
 ... report an error ....
done:
 virStreamFree(st);
 close(fd);</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>buffer to write to stream</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of @data buffer</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes written, which may be less than requested. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree. Returns -2 if the outgoing transmit buffers are full &amp; the stream is marked as non-blocking.</td></tr></tbody></table></div><h3><a name="virStreamSendAll" id="virStreamSendAll"><code>virStreamSendAll</code></a></h3><pre class="programlisting">int	virStreamSendAll		(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> stream, <br />					 <a href="libvirt-libvirt.html#virStreamSourceFunc">virStreamSourceFunc</a> handler, <br />					 void * opaque)<br />
</pre><p>Send the entire data stream, reading the data from the
requested data source. This is simply a convenient alternative
to virStreamSend, for apps that do blocking-I/o.

An example using this with a hypothetical file upload
API looks like

 int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {
 int *fd = opaque;

 return read(*fd, buf, nbytes);
 }

 <a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_RDONLY)

 virConnectUploadFile(conn, st);
 if (virStreamSendAll(st, mysource, &amp;fd) &lt; 0) {
 ...report an error ...
 goto done;
 }
 if (virStreamFinish(st) &lt; 0)
 ...report an error...
 virStreamFree(st);
 close(fd);</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>handler</tt></i>:</span></td><td>source callback for reading data from application</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt.html#virStreamFree">virStreamFree</a> Returns -1 upon any error, with virStreamAbort() already having been called, so the caller need only call virStreamFree()</td></tr></tbody></table></div><h3><a name="virStreamSinkFunc" id="virStreamSinkFunc"><code>virStreamSinkFunc</code></a></h3><pre class="programlisting">typedef int	(*virStreamSinkFunc	)	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br />					 const char * data, <br />					 size_t nbytes, <br />					 void * opaque)
</pre><p>The <a href="libvirt-libvirt.html#virStreamSinkFunc">virStreamSinkFunc</a> callback is used together
with the <a href="libvirt-libvirt.html#virStreamRecvAll">virStreamRecvAll</a> function for libvirt to
provide the data that has been received.

The callback will be invoked multiple times,
providing data in small chunks. The application
should consume up 'nbytes' from the 'data' array
of data and then return the number actual number
of bytes consumed. The callback will continue to be
invoked until it indicates the end of the stream
has been reached. A return value of -1 at any time
will abort the receive operation</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>preallocated array to be filled with data</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of the data array</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>optional application provided data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes consumed or -1 upon error</td></tr></tbody></table></div><br /><h3><a name="virStreamSourceFunc" id="virStreamSourceFunc"><code>virStreamSourceFunc</code></a></h3><pre class="programlisting">typedef int	(*virStreamSourceFunc	)	(<a href="libvirt-libvirt.html#virStreamPtr">virStreamPtr</a> st, <br />					 char * data, <br />					 size_t nbytes, <br />					 void * opaque)
</pre><p>The <a href="libvirt-libvirt.html#virStreamSourceFunc">virStreamSourceFunc</a> callback is used together
with the <a href="libvirt-libvirt.html#virStreamSendAll">virStreamSendAll</a> function for libvirt to
obtain the data that is to be sent.

The callback will be invoked multiple times,
fetching data in small chunks. The application
should fill the 'data' array with upto 'nbytes'
of data and then return the number actual number
of bytes. The callback will continue to be
invoked until it indicates the end of the source
has been reached by returning 0. A return value
of -1 at any time will abort the send operation</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>preallocated array to be filled with data</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of the data array</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>optional application provided data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes filled, 0 upon end of file, or -1 upon error</td></tr></tbody></table></div><br /></div></div><div id="footer"><p id="sponsor">
	    Sponsored by:<br /><a href="http://et.redhat.com/"><img src="../et.png" alt="Project sponsored by Red Hat Emerging Technology" /></a></p></div></body></html>
