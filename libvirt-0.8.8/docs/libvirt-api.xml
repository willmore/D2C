<?xml version="1.0" encoding="ISO-8859-1"?>
<api name='libvirt'>
  <files>
    <file name='libvirt'>
     <summary>core interfaces for the libvirt library</summary>
     <description>Provides the interfaces of the libvirt library to handle virtualized domains </description>
     <author>Daniel Veillard &lt;veillard@redhat.com&gt; </author>
     <exports symbol='LIBVIR_VERSION_NUMBER' type='macro'/>
     <exports symbol='VIR_COPY_CPUMAP' type='macro'/>
     <exports symbol='VIR_CPU_MAPLEN' type='macro'/>
     <exports symbol='VIR_CPU_USABLE' type='macro'/>
     <exports symbol='VIR_DOMAIN_EVENT_CALLBACK' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_HARD_LIMIT' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_MIN_GUARANTEE' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_UNLIMITED' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_SOFT_LIMIT' type='macro'/>
     <exports symbol='VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_GET_CPUMAP' type='macro'/>
     <exports symbol='VIR_NODEINFO_MAXCPUS' type='macro'/>
     <exports symbol='VIR_SECURITY_DOI_BUFLEN' type='macro'/>
     <exports symbol='VIR_SECURITY_LABEL_BUFLEN' type='macro'/>
     <exports symbol='VIR_SECURITY_MODEL_BUFLEN' type='macro'/>
     <exports symbol='VIR_UNUSE_CPU' type='macro'/>
     <exports symbol='VIR_USE_CPU' type='macro'/>
     <exports symbol='VIR_UUID_BUFLEN' type='macro'/>
     <exports symbol='VIR_UUID_STRING_BUFLEN' type='macro'/>
     <exports symbol='VIR_CONNECT_RO' type='enum'/>
     <exports symbol='VIR_CPU_COMPARE_ERROR' type='enum'/>
     <exports symbol='VIR_CPU_COMPARE_IDENTICAL' type='enum'/>
     <exports symbol='VIR_CPU_COMPARE_INCOMPATIBLE' type='enum'/>
     <exports symbol='VIR_CPU_COMPARE_SUPERSET' type='enum'/>
     <exports symbol='VIR_CRED_AUTHNAME' type='enum'/>
     <exports symbol='VIR_CRED_CNONCE' type='enum'/>
     <exports symbol='VIR_CRED_ECHOPROMPT' type='enum'/>
     <exports symbol='VIR_CRED_EXTERNAL' type='enum'/>
     <exports symbol='VIR_CRED_LANGUAGE' type='enum'/>
     <exports symbol='VIR_CRED_NOECHOPROMPT' type='enum'/>
     <exports symbol='VIR_CRED_PASSPHRASE' type='enum'/>
     <exports symbol='VIR_CRED_REALM' type='enum'/>
     <exports symbol='VIR_CRED_USERNAME' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCKED' type='enum'/>
     <exports symbol='VIR_DOMAIN_CRASHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_DEVICE_MODIFY_CONFIG' type='enum'/>
     <exports symbol='VIR_DOMAIN_DEVICE_MODIFY_CURRENT' type='enum'/>
     <exports symbol='VIR_DOMAIN_DEVICE_MODIFY_FORCE' type='enum'/>
     <exports symbol='VIR_DOMAIN_DEVICE_MODIFY_LIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED_ADDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED_UPDATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_CONNECT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_GRAPHICS' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_IO_ERROR' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_LAST' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_LIFECYCLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_REBOOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_RTC_CHANGE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_ID_WATCHDOG' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_IO_ERROR_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_IO_ERROR_PAUSE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_IO_ERROR_REPORT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED_UNPAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_BOOTED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_RESTORED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_CRASHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_DESTROYED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_FAILED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_SAVED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_IOERROR' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_PAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_UNDEFINED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_UNDEFINED_REMOVED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_DEBUG' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_PAUSE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_RESET' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_BOUNDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_CANCELLED' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_COMPLETED' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_FAILED' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_JOB_UNBOUNDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_BOOLEAN' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_DOUBLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_INT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_LLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_UINT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_PARAM_ULLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_AVAILABLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_NR' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_SWAP_IN' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_SWAP_OUT' type='enum'/>
     <exports symbol='VIR_DOMAIN_MEMORY_STAT_UNUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_NOSTATE' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_BOOLEAN' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_DOUBLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_INT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_LLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_UINT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_ULLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF' type='enum'/>
     <exports symbol='VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN' type='enum'/>
     <exports symbol='VIR_DOMAIN_START_PAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_VCPU_CONFIG' type='enum'/>
     <exports symbol='VIR_DOMAIN_VCPU_LIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_VCPU_MAXIMUM' type='enum'/>
     <exports symbol='VIR_DOMAIN_XML_INACTIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_XML_SECURE' type='enum'/>
     <exports symbol='VIR_DOMAIN_XML_UPDATE_CPU' type='enum'/>
     <exports symbol='VIR_DUMP_CRASH' type='enum'/>
     <exports symbol='VIR_DUMP_LIVE' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_ERROR' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_HANGUP' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_READABLE' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_WRITABLE' type='enum'/>
     <exports symbol='VIR_INTERFACE_XML_INACTIVE' type='enum'/>
     <exports symbol='VIR_MEMORY_PHYSICAL' type='enum'/>
     <exports symbol='VIR_MEMORY_VIRTUAL' type='enum'/>
     <exports symbol='VIR_MIGRATE_LIVE' type='enum'/>
     <exports symbol='VIR_MIGRATE_NON_SHARED_DISK' type='enum'/>
     <exports symbol='VIR_MIGRATE_NON_SHARED_INC' type='enum'/>
     <exports symbol='VIR_MIGRATE_PAUSED' type='enum'/>
     <exports symbol='VIR_MIGRATE_PEER2PEER' type='enum'/>
     <exports symbol='VIR_MIGRATE_PERSIST_DEST' type='enum'/>
     <exports symbol='VIR_MIGRATE_TUNNELLED' type='enum'/>
     <exports symbol='VIR_MIGRATE_UNDEFINE_SOURCE' type='enum'/>
     <exports symbol='VIR_SECRET_USAGE_TYPE_NONE' type='enum'/>
     <exports symbol='VIR_SECRET_USAGE_TYPE_VOLUME' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILDING' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_NEW' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_REPAIR' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_RESIZE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_DEGRADED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_DELETE_NORMAL' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_DELETE_ZEROED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_INACCESSIBLE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_INACTIVE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_RUNNING' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_BLOCK' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_DELETE_NORMAL' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_DELETE_ZEROED' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_FILE' type='enum'/>
     <exports symbol='VIR_STREAM_EVENT_ERROR' type='enum'/>
     <exports symbol='VIR_STREAM_EVENT_HANGUP' type='enum'/>
     <exports symbol='VIR_STREAM_EVENT_READABLE' type='enum'/>
     <exports symbol='VIR_STREAM_EVENT_WRITABLE' type='enum'/>
     <exports symbol='VIR_STREAM_NONBLOCK' type='enum'/>
     <exports symbol='VIR_VCPU_BLOCKED' type='enum'/>
     <exports symbol='VIR_VCPU_OFFLINE' type='enum'/>
     <exports symbol='VIR_VCPU_RUNNING' type='enum'/>
     <exports symbol='virCPUCompareResult' type='typedef'/>
     <exports symbol='virConnect' type='typedef'/>
     <exports symbol='virConnectAuth' type='typedef'/>
     <exports symbol='virConnectAuthPtr' type='typedef'/>
     <exports symbol='virConnectCredential' type='typedef'/>
     <exports symbol='virConnectCredentialPtr' type='typedef'/>
     <exports symbol='virConnectCredentialType' type='typedef'/>
     <exports symbol='virConnectFlags' type='typedef'/>
     <exports symbol='virConnectPtr' type='typedef'/>
     <exports symbol='virDomain' type='typedef'/>
     <exports symbol='virDomainBlockInfo' type='typedef'/>
     <exports symbol='virDomainBlockInfoPtr' type='typedef'/>
     <exports symbol='virDomainBlockStatsPtr' type='typedef'/>
     <exports symbol='virDomainBlockStatsStruct' type='typedef'/>
     <exports symbol='virDomainCoreDumpFlags' type='typedef'/>
     <exports symbol='virDomainCreateFlags' type='typedef'/>
     <exports symbol='virDomainDeviceModifyFlags' type='typedef'/>
     <exports symbol='virDomainEventDefinedDetailType' type='typedef'/>
     <exports symbol='virDomainEventGraphicsAddress' type='typedef'/>
     <exports symbol='virDomainEventGraphicsAddressPtr' type='typedef'/>
     <exports symbol='virDomainEventGraphicsAddressType' type='typedef'/>
     <exports symbol='virDomainEventGraphicsPhase' type='typedef'/>
     <exports symbol='virDomainEventGraphicsSubject' type='typedef'/>
     <exports symbol='virDomainEventGraphicsSubjectIdentity' type='typedef'/>
     <exports symbol='virDomainEventGraphicsSubjectIdentityPtr' type='typedef'/>
     <exports symbol='virDomainEventGraphicsSubjectPtr' type='typedef'/>
     <exports symbol='virDomainEventID' type='typedef'/>
     <exports symbol='virDomainEventIOErrorAction' type='typedef'/>
     <exports symbol='virDomainEventResumedDetailType' type='typedef'/>
     <exports symbol='virDomainEventStartedDetailType' type='typedef'/>
     <exports symbol='virDomainEventStoppedDetailType' type='typedef'/>
     <exports symbol='virDomainEventSuspendedDetailType' type='typedef'/>
     <exports symbol='virDomainEventType' type='typedef'/>
     <exports symbol='virDomainEventUndefinedDetailType' type='typedef'/>
     <exports symbol='virDomainEventWatchdogAction' type='typedef'/>
     <exports symbol='virDomainInfo' type='typedef'/>
     <exports symbol='virDomainInfoPtr' type='typedef'/>
     <exports symbol='virDomainInterfaceStatsPtr' type='typedef'/>
     <exports symbol='virDomainInterfaceStatsStruct' type='typedef'/>
     <exports symbol='virDomainJobInfo' type='typedef'/>
     <exports symbol='virDomainJobInfoPtr' type='typedef'/>
     <exports symbol='virDomainJobType' type='typedef'/>
     <exports symbol='virDomainMemoryFlags' type='typedef'/>
     <exports symbol='virDomainMemoryStatPtr' type='typedef'/>
     <exports symbol='virDomainMemoryStatStruct' type='typedef'/>
     <exports symbol='virDomainMemoryStatTags' type='typedef'/>
     <exports symbol='virDomainMigrateFlags' type='typedef'/>
     <exports symbol='virDomainPtr' type='typedef'/>
     <exports symbol='virDomainSnapshot' type='typedef'/>
     <exports symbol='virDomainSnapshotDeleteFlags' type='typedef'/>
     <exports symbol='virDomainSnapshotPtr' type='typedef'/>
     <exports symbol='virDomainState' type='typedef'/>
     <exports symbol='virDomainVcpuFlags' type='typedef'/>
     <exports symbol='virDomainXMLFlags' type='typedef'/>
     <exports symbol='virEventHandleType' type='typedef'/>
     <exports symbol='virInterface' type='typedef'/>
     <exports symbol='virInterfacePtr' type='typedef'/>
     <exports symbol='virInterfaceXMLFlags' type='typedef'/>
     <exports symbol='virMemoryParameter' type='typedef'/>
     <exports symbol='virMemoryParameterPtr' type='typedef'/>
     <exports symbol='virMemoryParameterType' type='typedef'/>
     <exports symbol='virNWFilter' type='typedef'/>
     <exports symbol='virNWFilterPtr' type='typedef'/>
     <exports symbol='virNetwork' type='typedef'/>
     <exports symbol='virNetworkPtr' type='typedef'/>
     <exports symbol='virNodeDevice' type='typedef'/>
     <exports symbol='virNodeDevicePtr' type='typedef'/>
     <exports symbol='virNodeInfo' type='typedef'/>
     <exports symbol='virNodeInfoPtr' type='typedef'/>
     <exports symbol='virSchedParameter' type='typedef'/>
     <exports symbol='virSchedParameterPtr' type='typedef'/>
     <exports symbol='virSchedParameterType' type='typedef'/>
     <exports symbol='virSecret' type='typedef'/>
     <exports symbol='virSecretPtr' type='typedef'/>
     <exports symbol='virSecretUsageType' type='typedef'/>
     <exports symbol='virSecurityLabel' type='typedef'/>
     <exports symbol='virSecurityLabelPtr' type='typedef'/>
     <exports symbol='virSecurityModel' type='typedef'/>
     <exports symbol='virSecurityModelPtr' type='typedef'/>
     <exports symbol='virStoragePool' type='typedef'/>
     <exports symbol='virStoragePoolBuildFlags' type='typedef'/>
     <exports symbol='virStoragePoolDeleteFlags' type='typedef'/>
     <exports symbol='virStoragePoolInfo' type='typedef'/>
     <exports symbol='virStoragePoolInfoPtr' type='typedef'/>
     <exports symbol='virStoragePoolPtr' type='typedef'/>
     <exports symbol='virStoragePoolState' type='typedef'/>
     <exports symbol='virStorageVol' type='typedef'/>
     <exports symbol='virStorageVolDeleteFlags' type='typedef'/>
     <exports symbol='virStorageVolInfo' type='typedef'/>
     <exports symbol='virStorageVolInfoPtr' type='typedef'/>
     <exports symbol='virStorageVolPtr' type='typedef'/>
     <exports symbol='virStorageVolType' type='typedef'/>
     <exports symbol='virStream' type='typedef'/>
     <exports symbol='virStreamEventType' type='typedef'/>
     <exports symbol='virStreamFlags' type='typedef'/>
     <exports symbol='virStreamPtr' type='typedef'/>
     <exports symbol='virVcpuInfo' type='typedef'/>
     <exports symbol='virVcpuInfoPtr' type='typedef'/>
     <exports symbol='virVcpuState' type='typedef'/>
     <exports symbol='_virConnectAuth' type='struct'/>
     <exports symbol='_virConnectCredential' type='struct'/>
     <exports symbol='_virDomainBlockInfo' type='struct'/>
     <exports symbol='_virDomainBlockStats' type='struct'/>
     <exports symbol='_virDomainEventGraphicsAddress' type='struct'/>
     <exports symbol='_virDomainEventGraphicsSubject' type='struct'/>
     <exports symbol='_virDomainEventGraphicsSubjectIdentity' type='struct'/>
     <exports symbol='_virDomainInfo' type='struct'/>
     <exports symbol='_virDomainInterfaceStats' type='struct'/>
     <exports symbol='_virDomainJobInfo' type='struct'/>
     <exports symbol='_virDomainMemoryStat' type='struct'/>
     <exports symbol='_virMemoryParameter' type='struct'/>
     <exports symbol='_virNodeInfo' type='struct'/>
     <exports symbol='_virSchedParameter' type='struct'/>
     <exports symbol='_virSecurityLabel' type='struct'/>
     <exports symbol='_virSecurityModel' type='struct'/>
     <exports symbol='_virStoragePoolInfo' type='struct'/>
     <exports symbol='_virStorageVolInfo' type='struct'/>
     <exports symbol='_virVcpuInfo' type='struct'/>
     <exports symbol='virConnectAuthPtrDefault' type='variable'/>
     <exports symbol='virConnectAuthCallbackPtr' type='function'/>
     <exports symbol='virConnectBaselineCPU' type='function'/>
     <exports symbol='virConnectClose' type='function'/>
     <exports symbol='virConnectCompareCPU' type='function'/>
     <exports symbol='virConnectDomainEventCallback' type='function'/>
     <exports symbol='virConnectDomainEventDeregister' type='function'/>
     <exports symbol='virConnectDomainEventDeregisterAny' type='function'/>
     <exports symbol='virConnectDomainEventGenericCallback' type='function'/>
     <exports symbol='virConnectDomainEventGraphicsCallback' type='function'/>
     <exports symbol='virConnectDomainEventIOErrorCallback' type='function'/>
     <exports symbol='virConnectDomainEventIOErrorReasonCallback' type='function'/>
     <exports symbol='virConnectDomainEventRTCChangeCallback' type='function'/>
     <exports symbol='virConnectDomainEventRegister' type='function'/>
     <exports symbol='virConnectDomainEventRegisterAny' type='function'/>
     <exports symbol='virConnectDomainEventWatchdogCallback' type='function'/>
     <exports symbol='virConnectDomainXMLFromNative' type='function'/>
     <exports symbol='virConnectDomainXMLToNative' type='function'/>
     <exports symbol='virConnectFindStoragePoolSources' type='function'/>
     <exports symbol='virConnectGetCapabilities' type='function'/>
     <exports symbol='virConnectGetHostname' type='function'/>
     <exports symbol='virConnectGetLibVersion' type='function'/>
     <exports symbol='virConnectGetMaxVcpus' type='function'/>
     <exports symbol='virConnectGetSysinfo' type='function'/>
     <exports symbol='virConnectGetType' type='function'/>
     <exports symbol='virConnectGetURI' type='function'/>
     <exports symbol='virConnectGetVersion' type='function'/>
     <exports symbol='virConnectIsEncrypted' type='function'/>
     <exports symbol='virConnectIsSecure' type='function'/>
     <exports symbol='virConnectListDefinedDomains' type='function'/>
     <exports symbol='virConnectListDefinedInterfaces' type='function'/>
     <exports symbol='virConnectListDefinedNetworks' type='function'/>
     <exports symbol='virConnectListDefinedStoragePools' type='function'/>
     <exports symbol='virConnectListDomains' type='function'/>
     <exports symbol='virConnectListInterfaces' type='function'/>
     <exports symbol='virConnectListNWFilters' type='function'/>
     <exports symbol='virConnectListNetworks' type='function'/>
     <exports symbol='virConnectListSecrets' type='function'/>
     <exports symbol='virConnectListStoragePools' type='function'/>
     <exports symbol='virConnectNumOfDefinedDomains' type='function'/>
     <exports symbol='virConnectNumOfDefinedInterfaces' type='function'/>
     <exports symbol='virConnectNumOfDefinedNetworks' type='function'/>
     <exports symbol='virConnectNumOfDefinedStoragePools' type='function'/>
     <exports symbol='virConnectNumOfDomains' type='function'/>
     <exports symbol='virConnectNumOfInterfaces' type='function'/>
     <exports symbol='virConnectNumOfNWFilters' type='function'/>
     <exports symbol='virConnectNumOfNetworks' type='function'/>
     <exports symbol='virConnectNumOfSecrets' type='function'/>
     <exports symbol='virConnectNumOfStoragePools' type='function'/>
     <exports symbol='virConnectOpen' type='function'/>
     <exports symbol='virConnectOpenAuth' type='function'/>
     <exports symbol='virConnectOpenReadOnly' type='function'/>
     <exports symbol='virConnectRef' type='function'/>
     <exports symbol='virDomainAbortJob' type='function'/>
     <exports symbol='virDomainAttachDevice' type='function'/>
     <exports symbol='virDomainAttachDeviceFlags' type='function'/>
     <exports symbol='virDomainBlockPeek' type='function'/>
     <exports symbol='virDomainBlockStats' type='function'/>
     <exports symbol='virDomainCoreDump' type='function'/>
     <exports symbol='virDomainCreate' type='function'/>
     <exports symbol='virDomainCreateLinux' type='function'/>
     <exports symbol='virDomainCreateWithFlags' type='function'/>
     <exports symbol='virDomainCreateXML' type='function'/>
     <exports symbol='virDomainDefineXML' type='function'/>
     <exports symbol='virDomainDestroy' type='function'/>
     <exports symbol='virDomainDetachDevice' type='function'/>
     <exports symbol='virDomainDetachDeviceFlags' type='function'/>
     <exports symbol='virDomainFree' type='function'/>
     <exports symbol='virDomainGetAutostart' type='function'/>
     <exports symbol='virDomainGetBlockInfo' type='function'/>
     <exports symbol='virDomainGetConnect' type='function'/>
     <exports symbol='virDomainGetID' type='function'/>
     <exports symbol='virDomainGetInfo' type='function'/>
     <exports symbol='virDomainGetJobInfo' type='function'/>
     <exports symbol='virDomainGetMaxMemory' type='function'/>
     <exports symbol='virDomainGetMaxVcpus' type='function'/>
     <exports symbol='virDomainGetMemoryParameters' type='function'/>
     <exports symbol='virDomainGetName' type='function'/>
     <exports symbol='virDomainGetOSType' type='function'/>
     <exports symbol='virDomainGetSchedulerParameters' type='function'/>
     <exports symbol='virDomainGetSchedulerType' type='function'/>
     <exports symbol='virDomainGetSecurityLabel' type='function'/>
     <exports symbol='virDomainGetUUID' type='function'/>
     <exports symbol='virDomainGetUUIDString' type='function'/>
     <exports symbol='virDomainGetVcpus' type='function'/>
     <exports symbol='virDomainGetVcpusFlags' type='function'/>
     <exports symbol='virDomainGetXMLDesc' type='function'/>
     <exports symbol='virDomainHasCurrentSnapshot' type='function'/>
     <exports symbol='virDomainHasManagedSaveImage' type='function'/>
     <exports symbol='virDomainInterfaceStats' type='function'/>
     <exports symbol='virDomainIsActive' type='function'/>
     <exports symbol='virDomainIsPersistent' type='function'/>
     <exports symbol='virDomainIsUpdated' type='function'/>
     <exports symbol='virDomainLookupByID' type='function'/>
     <exports symbol='virDomainLookupByName' type='function'/>
     <exports symbol='virDomainLookupByUUID' type='function'/>
     <exports symbol='virDomainLookupByUUIDString' type='function'/>
     <exports symbol='virDomainManagedSave' type='function'/>
     <exports symbol='virDomainManagedSaveRemove' type='function'/>
     <exports symbol='virDomainMemoryPeek' type='function'/>
     <exports symbol='virDomainMemoryStats' type='function'/>
     <exports symbol='virDomainMigrate' type='function'/>
     <exports symbol='virDomainMigrateSetMaxDowntime' type='function'/>
     <exports symbol='virDomainMigrateToURI' type='function'/>
     <exports symbol='virDomainOpenConsole' type='function'/>
     <exports symbol='virDomainPinVcpu' type='function'/>
     <exports symbol='virDomainReboot' type='function'/>
     <exports symbol='virDomainRef' type='function'/>
     <exports symbol='virDomainRestore' type='function'/>
     <exports symbol='virDomainResume' type='function'/>
     <exports symbol='virDomainRevertToSnapshot' type='function'/>
     <exports symbol='virDomainSave' type='function'/>
     <exports symbol='virDomainSetAutostart' type='function'/>
     <exports symbol='virDomainSetMaxMemory' type='function'/>
     <exports symbol='virDomainSetMemory' type='function'/>
     <exports symbol='virDomainSetMemoryParameters' type='function'/>
     <exports symbol='virDomainSetSchedulerParameters' type='function'/>
     <exports symbol='virDomainSetVcpus' type='function'/>
     <exports symbol='virDomainSetVcpusFlags' type='function'/>
     <exports symbol='virDomainShutdown' type='function'/>
     <exports symbol='virDomainSnapshotCreateXML' type='function'/>
     <exports symbol='virDomainSnapshotCurrent' type='function'/>
     <exports symbol='virDomainSnapshotDelete' type='function'/>
     <exports symbol='virDomainSnapshotFree' type='function'/>
     <exports symbol='virDomainSnapshotGetXMLDesc' type='function'/>
     <exports symbol='virDomainSnapshotListNames' type='function'/>
     <exports symbol='virDomainSnapshotLookupByName' type='function'/>
     <exports symbol='virDomainSnapshotNum' type='function'/>
     <exports symbol='virDomainSuspend' type='function'/>
     <exports symbol='virDomainUndefine' type='function'/>
     <exports symbol='virDomainUpdateDeviceFlags' type='function'/>
     <exports symbol='virEventAddHandleFunc' type='function'/>
     <exports symbol='virEventAddTimeoutFunc' type='function'/>
     <exports symbol='virEventHandleCallback' type='function'/>
     <exports symbol='virEventRegisterImpl' type='function'/>
     <exports symbol='virEventRemoveHandleFunc' type='function'/>
     <exports symbol='virEventRemoveTimeoutFunc' type='function'/>
     <exports symbol='virEventTimeoutCallback' type='function'/>
     <exports symbol='virEventUpdateHandleFunc' type='function'/>
     <exports symbol='virEventUpdateTimeoutFunc' type='function'/>
     <exports symbol='virFreeCallback' type='function'/>
     <exports symbol='virGetVersion' type='function'/>
     <exports symbol='virInitialize' type='function'/>
     <exports symbol='virInterfaceCreate' type='function'/>
     <exports symbol='virInterfaceDefineXML' type='function'/>
     <exports symbol='virInterfaceDestroy' type='function'/>
     <exports symbol='virInterfaceFree' type='function'/>
     <exports symbol='virInterfaceGetConnect' type='function'/>
     <exports symbol='virInterfaceGetMACString' type='function'/>
     <exports symbol='virInterfaceGetName' type='function'/>
     <exports symbol='virInterfaceGetXMLDesc' type='function'/>
     <exports symbol='virInterfaceIsActive' type='function'/>
     <exports symbol='virInterfaceLookupByMACString' type='function'/>
     <exports symbol='virInterfaceLookupByName' type='function'/>
     <exports symbol='virInterfaceRef' type='function'/>
     <exports symbol='virInterfaceUndefine' type='function'/>
     <exports symbol='virNWFilterDefineXML' type='function'/>
     <exports symbol='virNWFilterFree' type='function'/>
     <exports symbol='virNWFilterGetName' type='function'/>
     <exports symbol='virNWFilterGetUUID' type='function'/>
     <exports symbol='virNWFilterGetUUIDString' type='function'/>
     <exports symbol='virNWFilterGetXMLDesc' type='function'/>
     <exports symbol='virNWFilterLookupByName' type='function'/>
     <exports symbol='virNWFilterLookupByUUID' type='function'/>
     <exports symbol='virNWFilterLookupByUUIDString' type='function'/>
     <exports symbol='virNWFilterRef' type='function'/>
     <exports symbol='virNWFilterUndefine' type='function'/>
     <exports symbol='virNetworkCreate' type='function'/>
     <exports symbol='virNetworkCreateXML' type='function'/>
     <exports symbol='virNetworkDefineXML' type='function'/>
     <exports symbol='virNetworkDestroy' type='function'/>
     <exports symbol='virNetworkFree' type='function'/>
     <exports symbol='virNetworkGetAutostart' type='function'/>
     <exports symbol='virNetworkGetBridgeName' type='function'/>
     <exports symbol='virNetworkGetConnect' type='function'/>
     <exports symbol='virNetworkGetName' type='function'/>
     <exports symbol='virNetworkGetUUID' type='function'/>
     <exports symbol='virNetworkGetUUIDString' type='function'/>
     <exports symbol='virNetworkGetXMLDesc' type='function'/>
     <exports symbol='virNetworkIsActive' type='function'/>
     <exports symbol='virNetworkIsPersistent' type='function'/>
     <exports symbol='virNetworkLookupByName' type='function'/>
     <exports symbol='virNetworkLookupByUUID' type='function'/>
     <exports symbol='virNetworkLookupByUUIDString' type='function'/>
     <exports symbol='virNetworkRef' type='function'/>
     <exports symbol='virNetworkSetAutostart' type='function'/>
     <exports symbol='virNetworkUndefine' type='function'/>
     <exports symbol='virNodeDeviceCreateXML' type='function'/>
     <exports symbol='virNodeDeviceDestroy' type='function'/>
     <exports symbol='virNodeDeviceDettach' type='function'/>
     <exports symbol='virNodeDeviceFree' type='function'/>
     <exports symbol='virNodeDeviceGetName' type='function'/>
     <exports symbol='virNodeDeviceGetParent' type='function'/>
     <exports symbol='virNodeDeviceGetXMLDesc' type='function'/>
     <exports symbol='virNodeDeviceListCaps' type='function'/>
     <exports symbol='virNodeDeviceLookupByName' type='function'/>
     <exports symbol='virNodeDeviceNumOfCaps' type='function'/>
     <exports symbol='virNodeDeviceReAttach' type='function'/>
     <exports symbol='virNodeDeviceRef' type='function'/>
     <exports symbol='virNodeDeviceReset' type='function'/>
     <exports symbol='virNodeGetCellsFreeMemory' type='function'/>
     <exports symbol='virNodeGetFreeMemory' type='function'/>
     <exports symbol='virNodeGetInfo' type='function'/>
     <exports symbol='virNodeGetSecurityModel' type='function'/>
     <exports symbol='virNodeListDevices' type='function'/>
     <exports symbol='virNodeNumOfDevices' type='function'/>
     <exports symbol='virSecretDefineXML' type='function'/>
     <exports symbol='virSecretFree' type='function'/>
     <exports symbol='virSecretGetConnect' type='function'/>
     <exports symbol='virSecretGetUUID' type='function'/>
     <exports symbol='virSecretGetUUIDString' type='function'/>
     <exports symbol='virSecretGetUsageID' type='function'/>
     <exports symbol='virSecretGetUsageType' type='function'/>
     <exports symbol='virSecretGetValue' type='function'/>
     <exports symbol='virSecretGetXMLDesc' type='function'/>
     <exports symbol='virSecretLookupByUUID' type='function'/>
     <exports symbol='virSecretLookupByUUIDString' type='function'/>
     <exports symbol='virSecretLookupByUsage' type='function'/>
     <exports symbol='virSecretRef' type='function'/>
     <exports symbol='virSecretSetValue' type='function'/>
     <exports symbol='virSecretUndefine' type='function'/>
     <exports symbol='virStoragePoolBuild' type='function'/>
     <exports symbol='virStoragePoolCreate' type='function'/>
     <exports symbol='virStoragePoolCreateXML' type='function'/>
     <exports symbol='virStoragePoolDefineXML' type='function'/>
     <exports symbol='virStoragePoolDelete' type='function'/>
     <exports symbol='virStoragePoolDestroy' type='function'/>
     <exports symbol='virStoragePoolFree' type='function'/>
     <exports symbol='virStoragePoolGetAutostart' type='function'/>
     <exports symbol='virStoragePoolGetConnect' type='function'/>
     <exports symbol='virStoragePoolGetInfo' type='function'/>
     <exports symbol='virStoragePoolGetName' type='function'/>
     <exports symbol='virStoragePoolGetUUID' type='function'/>
     <exports symbol='virStoragePoolGetUUIDString' type='function'/>
     <exports symbol='virStoragePoolGetXMLDesc' type='function'/>
     <exports symbol='virStoragePoolIsActive' type='function'/>
     <exports symbol='virStoragePoolIsPersistent' type='function'/>
     <exports symbol='virStoragePoolListVolumes' type='function'/>
     <exports symbol='virStoragePoolLookupByName' type='function'/>
     <exports symbol='virStoragePoolLookupByUUID' type='function'/>
     <exports symbol='virStoragePoolLookupByUUIDString' type='function'/>
     <exports symbol='virStoragePoolLookupByVolume' type='function'/>
     <exports symbol='virStoragePoolNumOfVolumes' type='function'/>
     <exports symbol='virStoragePoolRef' type='function'/>
     <exports symbol='virStoragePoolRefresh' type='function'/>
     <exports symbol='virStoragePoolSetAutostart' type='function'/>
     <exports symbol='virStoragePoolUndefine' type='function'/>
     <exports symbol='virStorageVolCreateXML' type='function'/>
     <exports symbol='virStorageVolCreateXMLFrom' type='function'/>
     <exports symbol='virStorageVolDelete' type='function'/>
     <exports symbol='virStorageVolFree' type='function'/>
     <exports symbol='virStorageVolGetConnect' type='function'/>
     <exports symbol='virStorageVolGetInfo' type='function'/>
     <exports symbol='virStorageVolGetKey' type='function'/>
     <exports symbol='virStorageVolGetName' type='function'/>
     <exports symbol='virStorageVolGetPath' type='function'/>
     <exports symbol='virStorageVolGetXMLDesc' type='function'/>
     <exports symbol='virStorageVolLookupByKey' type='function'/>
     <exports symbol='virStorageVolLookupByName' type='function'/>
     <exports symbol='virStorageVolLookupByPath' type='function'/>
     <exports symbol='virStorageVolRef' type='function'/>
     <exports symbol='virStorageVolWipe' type='function'/>
     <exports symbol='virStreamAbort' type='function'/>
     <exports symbol='virStreamEventAddCallback' type='function'/>
     <exports symbol='virStreamEventCallback' type='function'/>
     <exports symbol='virStreamEventRemoveCallback' type='function'/>
     <exports symbol='virStreamEventUpdateCallback' type='function'/>
     <exports symbol='virStreamFinish' type='function'/>
     <exports symbol='virStreamFree' type='function'/>
     <exports symbol='virStreamNew' type='function'/>
     <exports symbol='virStreamRecv' type='function'/>
     <exports symbol='virStreamRecvAll' type='function'/>
     <exports symbol='virStreamRef' type='function'/>
     <exports symbol='virStreamSend' type='function'/>
     <exports symbol='virStreamSendAll' type='function'/>
     <exports symbol='virStreamSinkFunc' type='function'/>
     <exports symbol='virStreamSourceFunc' type='function'/>
    </file>
    <file name='virterror'>
     <summary>error handling interfaces for the libvirt library</summary>
     <description>Provides the interfaces of the libvirt library to handle errors raised while using the library. </description>
     <author>Daniel Veillard &lt;veillard@redhat.com&gt; </author>
     <exports symbol='VIR_ERR_AUTH_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_BUILD_FIREWALL' type='enum'/>
     <exports symbol='VIR_ERR_CALL_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_CONFIG_UNSUPPORTED' type='enum'/>
     <exports symbol='VIR_ERR_CONF_SYNTAX' type='enum'/>
     <exports symbol='VIR_ERR_DOM_EXIST' type='enum'/>
     <exports symbol='VIR_ERR_DRIVER_FULL' type='enum'/>
     <exports symbol='VIR_ERR_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_GET_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_GNUTLS_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_HOOK_SCRIPT_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_HTTP_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_INTERNAL_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_ARG' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_CONN' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_DOMAIN' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_DOMAIN_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_INTERFACE' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_MAC' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NETWORK' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NODE_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NWFILTER' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_SECRET' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_STORAGE_POOL' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_STORAGE_VOL' type='enum'/>
     <exports symbol='VIR_ERR_MIGRATE_PERSIST_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_MULTIPLE_INTERFACES' type='enum'/>
     <exports symbol='VIR_ERR_NETWORK_EXIST' type='enum'/>
     <exports symbol='VIR_ERR_NONE' type='enum'/>
     <exports symbol='VIR_ERR_NO_CONNECT' type='enum'/>
     <exports symbol='VIR_ERR_NO_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_NO_DOMAIN' type='enum'/>
     <exports symbol='VIR_ERR_NO_DOMAIN_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_ERR_NO_INTERFACE' type='enum'/>
     <exports symbol='VIR_ERR_NO_KERNEL' type='enum'/>
     <exports symbol='VIR_ERR_NO_MEMORY' type='enum'/>
     <exports symbol='VIR_ERR_NO_NAME' type='enum'/>
     <exports symbol='VIR_ERR_NO_NETWORK' type='enum'/>
     <exports symbol='VIR_ERR_NO_NODE_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_NO_NWFILTER' type='enum'/>
     <exports symbol='VIR_ERR_NO_OS' type='enum'/>
     <exports symbol='VIR_ERR_NO_ROOT' type='enum'/>
     <exports symbol='VIR_ERR_NO_SECRET' type='enum'/>
     <exports symbol='VIR_ERR_NO_SECURITY_MODEL' type='enum'/>
     <exports symbol='VIR_ERR_NO_SOURCE' type='enum'/>
     <exports symbol='VIR_ERR_NO_STORAGE_POOL' type='enum'/>
     <exports symbol='VIR_ERR_NO_STORAGE_VOL' type='enum'/>
     <exports symbol='VIR_ERR_NO_SUPPORT' type='enum'/>
     <exports symbol='VIR_ERR_NO_TARGET' type='enum'/>
     <exports symbol='VIR_ERR_NO_XEN' type='enum'/>
     <exports symbol='VIR_ERR_NO_XENSTORE' type='enum'/>
     <exports symbol='VIR_ERR_OK' type='enum'/>
     <exports symbol='VIR_ERR_OPEN_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_DENIED' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_INVALID' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_TIMEOUT' type='enum'/>
     <exports symbol='VIR_ERR_OS_TYPE' type='enum'/>
     <exports symbol='VIR_ERR_PARSE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_POST_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_READ_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_RPC' type='enum'/>
     <exports symbol='VIR_ERR_SEXPR_SERIAL' type='enum'/>
     <exports symbol='VIR_ERR_SYSTEM_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_UNKNOWN_HOST' type='enum'/>
     <exports symbol='VIR_ERR_WARNING' type='enum'/>
     <exports symbol='VIR_ERR_WRITE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_XEN_CALL' type='enum'/>
     <exports symbol='VIR_ERR_XML_DETAIL' type='enum'/>
     <exports symbol='VIR_ERR_XML_ERROR' type='enum'/>
     <exports symbol='VIR_FROM_AUDIT' type='enum'/>
     <exports symbol='VIR_FROM_CONF' type='enum'/>
     <exports symbol='VIR_FROM_CPU' type='enum'/>
     <exports symbol='VIR_FROM_DOM' type='enum'/>
     <exports symbol='VIR_FROM_DOMAIN' type='enum'/>
     <exports symbol='VIR_FROM_DOMAIN_SNAPSHOT' type='enum'/>
     <exports symbol='VIR_FROM_ESX' type='enum'/>
     <exports symbol='VIR_FROM_HOOK' type='enum'/>
     <exports symbol='VIR_FROM_INTERFACE' type='enum'/>
     <exports symbol='VIR_FROM_LXC' type='enum'/>
     <exports symbol='VIR_FROM_NET' type='enum'/>
     <exports symbol='VIR_FROM_NETWORK' type='enum'/>
     <exports symbol='VIR_FROM_NODEDEV' type='enum'/>
     <exports symbol='VIR_FROM_NONE' type='enum'/>
     <exports symbol='VIR_FROM_NWFILTER' type='enum'/>
     <exports symbol='VIR_FROM_ONE' type='enum'/>
     <exports symbol='VIR_FROM_OPENVZ' type='enum'/>
     <exports symbol='VIR_FROM_PHYP' type='enum'/>
     <exports symbol='VIR_FROM_PROXY' type='enum'/>
     <exports symbol='VIR_FROM_QEMU' type='enum'/>
     <exports symbol='VIR_FROM_REMOTE' type='enum'/>
     <exports symbol='VIR_FROM_RPC' type='enum'/>
     <exports symbol='VIR_FROM_SECRET' type='enum'/>
     <exports symbol='VIR_FROM_SECURITY' type='enum'/>
     <exports symbol='VIR_FROM_SEXPR' type='enum'/>
     <exports symbol='VIR_FROM_STATS_LINUX' type='enum'/>
     <exports symbol='VIR_FROM_STORAGE' type='enum'/>
     <exports symbol='VIR_FROM_STREAMS' type='enum'/>
     <exports symbol='VIR_FROM_SYSINFO' type='enum'/>
     <exports symbol='VIR_FROM_TEST' type='enum'/>
     <exports symbol='VIR_FROM_UML' type='enum'/>
     <exports symbol='VIR_FROM_VBOX' type='enum'/>
     <exports symbol='VIR_FROM_VMWARE' type='enum'/>
     <exports symbol='VIR_FROM_XEN' type='enum'/>
     <exports symbol='VIR_FROM_XENAPI' type='enum'/>
     <exports symbol='VIR_FROM_XEND' type='enum'/>
     <exports symbol='VIR_FROM_XENSTORE' type='enum'/>
     <exports symbol='VIR_FROM_XENXM' type='enum'/>
     <exports symbol='VIR_FROM_XEN_INOTIFY' type='enum'/>
     <exports symbol='VIR_FROM_XML' type='enum'/>
     <exports symbol='VIR_WAR_NO_INTERFACE' type='enum'/>
     <exports symbol='VIR_WAR_NO_NETWORK' type='enum'/>
     <exports symbol='VIR_WAR_NO_NODE' type='enum'/>
     <exports symbol='VIR_WAR_NO_NWFILTER' type='enum'/>
     <exports symbol='VIR_WAR_NO_SECRET' type='enum'/>
     <exports symbol='VIR_WAR_NO_STORAGE' type='enum'/>
     <exports symbol='virError' type='typedef'/>
     <exports symbol='virErrorDomain' type='typedef'/>
     <exports symbol='virErrorLevel' type='typedef'/>
     <exports symbol='virErrorNumber' type='typedef'/>
     <exports symbol='virErrorPtr' type='typedef'/>
     <exports symbol='_virError' type='struct'/>
     <exports symbol='virConnCopyLastError' type='function'/>
     <exports symbol='virConnGetLastError' type='function'/>
     <exports symbol='virConnResetLastError' type='function'/>
     <exports symbol='virConnSetErrorFunc' type='function'/>
     <exports symbol='virCopyLastError' type='function'/>
     <exports symbol='virDefaultErrorFunc' type='function'/>
     <exports symbol='virErrorFunc' type='function'/>
     <exports symbol='virFreeError' type='function'/>
     <exports symbol='virGetLastError' type='function'/>
     <exports symbol='virResetError' type='function'/>
     <exports symbol='virResetLastError' type='function'/>
     <exports symbol='virSaveLastError' type='function'/>
     <exports symbol='virSetErrorFunc' type='function'/>
    </file>
  </files>
  <symbols>
    <macro name='LIBVIR_VERSION_NUMBER' file='libvirt'>
      <info><![CDATA[Macro providing the version of the library as version * 1,000,000 + minor * 1000 + micro]]></info>
    </macro>
    <macro name='VIR_COPY_CPUMAP' file='libvirt'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_COPY_CPUMAP macro extract the cpumap of the specified vcpu from cpumaps array and copy it into cpumap to be used later by virDomainPinVcpu() API.]]></info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
      <arg name='cpumap' info='pointer to a cpumap (in 8-bit bytes) (OUT) This cpumap must be previously allocated by the caller (ie: malloc(maplen))'/>
    </macro>
    <macro name='VIR_CPU_MAPLEN' file='libvirt'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainPinVcpu() API. It returns the length (in bytes) required to store the complete CPU map between a single virtual & all physical CPUs of a domain.]]></info>
      <arg name='cpu' info='number of physical CPUs'/>
    </macro>
    <macro name='VIR_CPU_USABLE' file='libvirt'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainGetVcpus() API. VIR_CPU_USABLE macro returns a non zero value (true) if the cpu is usable by the vcpu, and 0 otherwise.]]></info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_DOMAIN_EVENT_CALLBACK' file='libvirt'>
      <info><![CDATA[Used to cast the event specific callback into the generic one for use for virDomainEventRegister]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_FIELD_LENGTH' file='libvirt'>
      <info><![CDATA[Macro providing the field length of virMemoryParameter]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_HARD_LIMIT' file='libvirt'>
      <info><![CDATA[Macro for the memory tunable hard_limit: it represents the maximum memory the guest can use.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_MIN_GUARANTEE' file='libvirt'>
      <info><![CDATA[Macro for the memory tunable min_guarantee: it represents the minimum memory guaranteed to be reserved for the guest.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_PARAM_UNLIMITED' file='libvirt'>
      <info><![CDATA[Macro providing the virMemoryParameter value that indicates "unlimited"]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_SOFT_LIMIT' file='libvirt'>
      <info><![CDATA[Macro for the memory tunable soft_limit: it represents the memory upper limit enforced during memory contention.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT' file='libvirt'>
      <info><![CDATA[Macro for the swap tunable swap_hard_limit: it represents the maximum swap the guest can use.]]></info>
    </macro>
    <macro name='VIR_DOMAIN_SCHED_FIELD_LENGTH' file='libvirt'>
      <info><![CDATA[Macro providing the field length of virSchedParameter]]></info>
    </macro>
    <macro name='VIR_GET_CPUMAP' file='libvirt'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_GET_CPUMAP macro returns a pointer to the cpumap of the specified vcpu from cpumaps array.]]></info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
    </macro>
    <macro name='VIR_NODEINFO_MAXCPUS' file='libvirt'>
      <info><![CDATA[This macro is to calculate the total number of CPUs supported but not necessary active in the host.]]></info>
      <arg name='nodeinfo' info='virNodeInfo instance'/>
    </macro>
    <macro name='VIR_SECURITY_DOI_BUFLEN' file='libvirt'>
      <info><![CDATA[Macro providing the maximum length of the virSecurityModel doi string.]]></info>
    </macro>
    <macro name='VIR_SECURITY_LABEL_BUFLEN' file='libvirt'>
      <info><![CDATA[Macro providing the maximum length of the virSecurityLabel label string. Note that this value is based on that used by Labeled NFS.]]></info>
    </macro>
    <macro name='VIR_SECURITY_MODEL_BUFLEN' file='libvirt'>
      <info><![CDATA[Macro providing the maximum length of the virSecurityModel model string.]]></info>
    </macro>
    <macro name='VIR_UNUSE_CPU' file='libvirt'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainPinVcpu() API. USE_CPU macro reset the bit (CPU not usable) of the related cpu in cpumap.]]></info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_USE_CPU' file='libvirt'>
      <info><![CDATA[This macro is to be used in conjunction with virDomainPinVcpu() API. USE_CPU macro set the bit (CPU usable) of the related cpu in cpumap.]]></info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_UUID_BUFLEN' file='libvirt'>
      <info><![CDATA[This macro provides the length of the buffer required for virDomainGetUUID()]]></info>
    </macro>
    <macro name='VIR_UUID_STRING_BUFLEN' file='libvirt'>
      <info><![CDATA[This macro provides the length of the buffer required for virDomainGetUUIDString()]]></info>
    </macro>
    <enum name='VIR_CONNECT_RO' file='libvirt' value='1' type='virConnectFlags' info=' A readonly connection'/>
    <enum name='VIR_CPU_COMPARE_ERROR' file='libvirt' value='-1' type='virCPUCompareResult'/>
    <enum name='VIR_CPU_COMPARE_IDENTICAL' file='libvirt' value='1' type='virCPUCompareResult'/>
    <enum name='VIR_CPU_COMPARE_INCOMPATIBLE' file='libvirt' value='0' type='virCPUCompareResult'/>
    <enum name='VIR_CPU_COMPARE_SUPERSET' file='libvirt' value='2' type='virCPUCompareResult'/>
    <enum name='VIR_CRED_AUTHNAME' file='libvirt' value='2' type='virConnectCredentialType' info='Identify to authorize as'/>
    <enum name='VIR_CRED_CNONCE' file='libvirt' value='4' type='virConnectCredentialType' info='client supplies a nonce'/>
    <enum name='VIR_CRED_ECHOPROMPT' file='libvirt' value='6' type='virConnectCredentialType' info='Challenge response'/>
    <enum name='VIR_CRED_EXTERNAL' file='libvirt' value='9' type='virConnectCredentialType' info=' Externally managed credential More may be added - expect the unexpected'/>
    <enum name='VIR_CRED_LANGUAGE' file='libvirt' value='3' type='virConnectCredentialType' info='RFC 1766 languages, comma separated'/>
    <enum name='VIR_CRED_NOECHOPROMPT' file='libvirt' value='7' type='virConnectCredentialType' info='Challenge response'/>
    <enum name='VIR_CRED_PASSPHRASE' file='libvirt' value='5' type='virConnectCredentialType' info='Passphrase secret'/>
    <enum name='VIR_CRED_REALM' file='libvirt' value='8' type='virConnectCredentialType' info='Authentication realm'/>
    <enum name='VIR_CRED_USERNAME' file='libvirt' value='1' type='virConnectCredentialType' info='Identity to act as'/>
    <enum name='VIR_DOMAIN_BLOCKED' file='libvirt' value='2' type='virDomainState' info='the domain is blocked on resource'/>
    <enum name='VIR_DOMAIN_CRASHED' file='libvirt' value='6' type='virDomainState' info=' the domain is crashed'/>
    <enum name='VIR_DOMAIN_DEVICE_MODIFY_CONFIG' file='libvirt' value='2' type='virDomainDeviceModifyFlags' info='Modify persisted device allocation'/>
    <enum name='VIR_DOMAIN_DEVICE_MODIFY_CURRENT' file='libvirt' value='0' type='virDomainDeviceModifyFlags' info='Modify device allocation based on current domain state'/>
    <enum name='VIR_DOMAIN_DEVICE_MODIFY_FORCE' file='libvirt' value='4' type='virDomainDeviceModifyFlags' info=' Forcibly modify device
(ex. force eject a cdrom)'/>
    <enum name='VIR_DOMAIN_DEVICE_MODIFY_LIVE' file='libvirt' value='1' type='virDomainDeviceModifyFlags' info='Modify live device allocation'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED' file='libvirt' value='0' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED_ADDED' file='libvirt' value='0' type='virDomainEventDefinedDetailType' info='Newly created config file'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED_UPDATED' file='libvirt' value='1' type='virDomainEventDefinedDetailType' info=' Changed config file'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4' file='libvirt' value='1' type='virDomainEventGraphicsAddressType' info='IPv4 address'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6' file='libvirt' value='2' type='virDomainEventGraphicsAddressType' info=' IPv6 address'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_CONNECT' file='libvirt' value='0' type='virDomainEventGraphicsPhase' info='Initial socket connection established'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT' file='libvirt' value='2' type='virDomainEventGraphicsPhase' info=' Final socket disconnection'/>
    <enum name='VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE' file='libvirt' value='1' type='virDomainEventGraphicsPhase' info='Authentication &amp; setup completed'/>
    <enum name='VIR_DOMAIN_EVENT_ID_GRAPHICS' file='libvirt' value='5' type='virDomainEventID' info='virConnectDomainEventGraphicsCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_IO_ERROR' file='libvirt' value='4' type='virDomainEventID' info='virConnectDomainEventIOErrorCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON' file='libvirt' value='6' type='virDomainEventID' info='* NB: this enum value will increase over time as new events are
* added to the libvirt API. It reflects the last event ID supported
* by this version of the libvirt API.
*'/>
    <enum name='VIR_DOMAIN_EVENT_ID_LAST' file='libvirt' value='7' type='virDomainEventID'/>
    <enum name='VIR_DOMAIN_EVENT_ID_LIFECYCLE' file='libvirt' value='0' type='virDomainEventID' info='virConnectDomainEventCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_REBOOT' file='libvirt' value='1' type='virDomainEventID' info='virConnectDomainEventGenericCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_RTC_CHANGE' file='libvirt' value='2' type='virDomainEventID' info='virConnectDomainEventRTCChangeCallback'/>
    <enum name='VIR_DOMAIN_EVENT_ID_WATCHDOG' file='libvirt' value='3' type='virDomainEventID' info='virConnectDomainEventWatchdogCallback'/>
    <enum name='VIR_DOMAIN_EVENT_IO_ERROR_NONE' file='libvirt' value='0' type='virDomainEventIOErrorAction' info='No action, IO error ignored'/>
    <enum name='VIR_DOMAIN_EVENT_IO_ERROR_PAUSE' file='libvirt' value='1' type='virDomainEventIOErrorAction' info='Guest CPUs are pausde'/>
    <enum name='VIR_DOMAIN_EVENT_IO_ERROR_REPORT' file='libvirt' value='2' type='virDomainEventIOErrorAction' info=' IO error reported to guest OS'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED' file='libvirt' value='4' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED_MIGRATED' file='libvirt' value='1' type='virDomainEventResumedDetailType' info=' Resumed for completion of migration'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED_UNPAUSED' file='libvirt' value='0' type='virDomainEventResumedDetailType' info='Normal resume due to admin unpause'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED' file='libvirt' value='2' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_BOOTED' file='libvirt' value='0' type='virDomainEventStartedDetailType' info='Normal startup from boot'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT' file='libvirt' value='3' type='virDomainEventStartedDetailType' info=' Restored from snapshot'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_MIGRATED' file='libvirt' value='1' type='virDomainEventStartedDetailType' info='Incoming migration from another host'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_RESTORED' file='libvirt' value='2' type='virDomainEventStartedDetailType' info='Restored from a state file'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED' file='libvirt' value='5' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_CRASHED' file='libvirt' value='2' type='virDomainEventStoppedDetailType' info='Guest crashed'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_DESTROYED' file='libvirt' value='1' type='virDomainEventStoppedDetailType' info='Forced poweroff from host'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_FAILED' file='libvirt' value='5' type='virDomainEventStoppedDetailType' info='Host emulator/mgmt failed'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT' file='libvirt' value='6' type='virDomainEventStoppedDetailType' info=' offline snapshot loaded'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_MIGRATED' file='libvirt' value='3' type='virDomainEventStoppedDetailType' info='Migrated off to another host'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_SAVED' file='libvirt' value='4' type='virDomainEventStoppedDetailType' info='Saved to a state file'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN' file='libvirt' value='0' type='virDomainEventStoppedDetailType' info='Normal shutdown'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED' file='libvirt' value='3' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_IOERROR' file='libvirt' value='2' type='virDomainEventSuspendedDetailType' info='Suspended due to a disk I/O error'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED' file='libvirt' value='1' type='virDomainEventSuspendedDetailType' info='Suspended for offline migration'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_PAUSED' file='libvirt' value='0' type='virDomainEventSuspendedDetailType' info='Normal suspend due to admin pause'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG' file='libvirt' value='3' type='virDomainEventSuspendedDetailType' info=' Suspended due to a watchdog firing'/>
    <enum name='VIR_DOMAIN_EVENT_UNDEFINED' file='libvirt' value='1' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_UNDEFINED_REMOVED' file='libvirt' value='0' type='virDomainEventUndefinedDetailType' info=' Deleted the config file'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_DEBUG' file='libvirt' value='5' type='virDomainEventWatchdogAction' info=' No action, a debug message logged'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_NONE' file='libvirt' value='0' type='virDomainEventWatchdogAction' info='No action, watchdog ignored'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_PAUSE' file='libvirt' value='1' type='virDomainEventWatchdogAction' info='Guest CPUs are paused'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF' file='libvirt' value='3' type='virDomainEventWatchdogAction' info='Guest is forcably powered off'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_RESET' file='libvirt' value='2' type='virDomainEventWatchdogAction' info='Guest CPUs are reset'/>
    <enum name='VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN' file='libvirt' value='4' type='virDomainEventWatchdogAction' info='Guest is requested to gracefully shutdown'/>
    <enum name='VIR_DOMAIN_JOB_BOUNDED' file='libvirt' value='1' type='virDomainJobType' info='Job with a finite completion time'/>
    <enum name='VIR_DOMAIN_JOB_CANCELLED' file='libvirt' value='5' type='virDomainJobType' info=' Job was aborted, but isn&apos;t cleaned up'/>
    <enum name='VIR_DOMAIN_JOB_COMPLETED' file='libvirt' value='3' type='virDomainJobType' info='Job has finished, but isn&apos;t cleaned up'/>
    <enum name='VIR_DOMAIN_JOB_FAILED' file='libvirt' value='4' type='virDomainJobType' info='Job hit error, but isn&apos;t cleaned up'/>
    <enum name='VIR_DOMAIN_JOB_NONE' file='libvirt' value='0' type='virDomainJobType' info='No job is active'/>
    <enum name='VIR_DOMAIN_JOB_UNBOUNDED' file='libvirt' value='2' type='virDomainJobType' info='Job without a finite completion time'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_BOOLEAN' file='libvirt' value='6' type='virMemoryParameterType' info=' boolean(character) case'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_DOUBLE' file='libvirt' value='5' type='virMemoryParameterType' info='double case'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_INT' file='libvirt' value='1' type='virMemoryParameterType' info='integer case'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_LLONG' file='libvirt' value='3' type='virMemoryParameterType' info='long long case'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_UINT' file='libvirt' value='2' type='virMemoryParameterType' info='unsigned integer case'/>
    <enum name='VIR_DOMAIN_MEMORY_PARAM_ULLONG' file='libvirt' value='4' type='virMemoryParameterType' info='unsigned long long case'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_AVAILABLE' file='libvirt' value='5' type='virDomainMemoryStatTags' info='* The number of statistics supported by this version of the interface.
* To add new statistics, add them to the enum and increase this value.
*'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT' file='libvirt' value='2' type='virDomainMemoryStatTags'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT' file='libvirt' value='3' type='virDomainMemoryStatTags' info='* The amount of memory left completely unused by the system.  Memory that
* is available but used for reclaimable caches should NOT be reported as
* free.  This value is expressed in kB.
*'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_NR' file='libvirt' value='6' type='virDomainMemoryStatTags'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_SWAP_IN' file='libvirt' value='0' type='virDomainMemoryStatTags' info='The total amount of memory written out to swap space (in kB).'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_SWAP_OUT' file='libvirt' value='1' type='virDomainMemoryStatTags' info='* Page faults occur when a process makes a valid access to virtual memory
* that is not available.  When servicing the page fault, if disk IO is
* required, it is considered a major fault.  If not, it is a minor fault.
* These are expressed as the number of faults that have occurred.
*'/>
    <enum name='VIR_DOMAIN_MEMORY_STAT_UNUSED' file='libvirt' value='4' type='virDomainMemoryStatTags' info='* The total amount of usable memory as seen by the domain.  This value
* may be less than the amount of memory assigned to the domain if a
* balloon driver is in use or if the guest OS does not initialize all
* assigned pages.  This value is expressed in kB.
*'/>
    <enum name='VIR_DOMAIN_NONE' file='libvirt' value='0' type='virDomainCreateFlags' info='Default behavior'/>
    <enum name='VIR_DOMAIN_NOSTATE' file='libvirt' value='0' type='virDomainState' info='no state'/>
    <enum name='VIR_DOMAIN_PAUSED' file='libvirt' value='3' type='virDomainState' info='the domain is paused by user'/>
    <enum name='VIR_DOMAIN_RUNNING' file='libvirt' value='1' type='virDomainState' info='the domain is running'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_BOOLEAN' file='libvirt' value='6' type='virSchedParameterType' info=' boolean(character) case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_DOUBLE' file='libvirt' value='5' type='virSchedParameterType' info='double case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_INT' file='libvirt' value='1' type='virSchedParameterType' info='integer case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_LLONG' file='libvirt' value='3' type='virSchedParameterType' info='long long case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_UINT' file='libvirt' value='2' type='virSchedParameterType' info='unsigned integer case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_ULLONG' file='libvirt' value='4' type='virSchedParameterType' info='unsigned long long case'/>
    <enum name='VIR_DOMAIN_SHUTDOWN' file='libvirt' value='4' type='virDomainState' info='the domain is being shut down'/>
    <enum name='VIR_DOMAIN_SHUTOFF' file='libvirt' value='5' type='virDomainState' info='the domain is shut off'/>
    <enum name='VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN' file='libvirt' value='1' type='virDomainSnapshotDeleteFlags'/>
    <enum name='VIR_DOMAIN_START_PAUSED' file='libvirt' value='1' type='virDomainCreateFlags' info=' Launch guest in paused state'/>
    <enum name='VIR_DOMAIN_VCPU_CONFIG' file='libvirt' value='2' type='virDomainVcpuFlags' info='Affect next boot Additional flags to be bit-wise OR&apos;d in'/>
    <enum name='VIR_DOMAIN_VCPU_LIVE' file='libvirt' value='1' type='virDomainVcpuFlags' info='Affect active domain'/>
    <enum name='VIR_DOMAIN_VCPU_MAXIMUM' file='libvirt' value='4' type='virDomainVcpuFlags' info=' Max rather than current count'/>
    <enum name='VIR_DOMAIN_XML_INACTIVE' file='libvirt' value='2' type='virDomainXMLFlags' info='dump inactive domain information'/>
    <enum name='VIR_DOMAIN_XML_SECURE' file='libvirt' value='1' type='virDomainXMLFlags' info='dump security sensitive information too'/>
    <enum name='VIR_DOMAIN_XML_UPDATE_CPU' file='libvirt' value='4' type='virDomainXMLFlags' info=' update guest CPU requirements according to host CPU'/>
    <enum name='VIR_DUMP_CRASH' file='libvirt' value='1' type='virDomainCoreDumpFlags' info='crash after dump'/>
    <enum name='VIR_DUMP_LIVE' file='libvirt' value='2' type='virDomainCoreDumpFlags' info=' live dump'/>
    <enum name='VIR_ERR_AUTH_FAILED' file='virterror' value='45' type='virErrorNumber' info='authentication failed'/>
    <enum name='VIR_ERR_BUILD_FIREWALL' file='virterror' value='63' type='virErrorNumber' info='nw filter pool not found'/>
    <enum name='VIR_ERR_CALL_FAILED' file='virterror' value='26' type='virErrorNumber' info='not supported by the drivers
(DEPRECATED)'/>
    <enum name='VIR_ERR_CONFIG_UNSUPPORTED' file='virterror' value='67' type='virErrorNumber' info='unsupported configuration
construct'/>
    <enum name='VIR_ERR_CONF_SYNTAX' file='virterror' value='33' type='virErrorNumber' info='failed to parse the syntax of a
conf file'/>
    <enum name='VIR_ERR_DOM_EXIST' file='virterror' value='28' type='virErrorNumber' info='the domain already exist'/>
    <enum name='VIR_ERR_DRIVER_FULL' file='virterror' value='25' type='virErrorNumber' info='too many drivers registered'/>
    <enum name='VIR_ERR_ERROR' file='virterror' value='2' type='virErrorLevel' info=' An error'/>
    <enum name='VIR_ERR_GET_FAILED' file='virterror' value='10' type='virErrorNumber' info='a HTTP GET command to failed'/>
    <enum name='VIR_ERR_GNUTLS_ERROR' file='virterror' value='40' type='virErrorNumber' info='error from a GNUTLS call'/>
    <enum name='VIR_ERR_HOOK_SCRIPT_FAILED' file='virterror' value='70' type='virErrorNumber' info='a synchronous hook script failed'/>
    <enum name='VIR_ERR_HTTP_ERROR' file='virterror' value='12' type='virErrorNumber' info='unexpected HTTP error code'/>
    <enum name='VIR_ERR_INTERNAL_ERROR' file='virterror' value='1' type='virErrorNumber' info='internal error'/>
    <enum name='VIR_ERR_INVALID_ARG' file='virterror' value='8' type='virErrorNumber' info='invalid function argument'/>
    <enum name='VIR_ERR_INVALID_CONN' file='virterror' value='6' type='virErrorNumber' info='invalid connection object'/>
    <enum name='VIR_ERR_INVALID_DOMAIN' file='virterror' value='7' type='virErrorNumber' info='invalid domain object'/>
    <enum name='VIR_ERR_INVALID_DOMAIN_SNAPSHOT' file='virterror' value='71' type='virErrorNumber' info='invalid domain snapshot'/>
    <enum name='VIR_ERR_INVALID_INTERFACE' file='virterror' value='58' type='virErrorNumber' info='invalid interface object'/>
    <enum name='VIR_ERR_INVALID_MAC' file='virterror' value='44' type='virErrorNumber' info='invalid MAC address'/>
    <enum name='VIR_ERR_INVALID_NETWORK' file='virterror' value='36' type='virErrorNumber' info='invalid network object'/>
    <enum name='VIR_ERR_INVALID_NODE_DEVICE' file='virterror' value='52' type='virErrorNumber' info='invalid node device object'/>
    <enum name='VIR_ERR_INVALID_NWFILTER' file='virterror' value='61' type='virErrorNumber' info='invalid nwfilter object'/>
    <enum name='VIR_ERR_INVALID_SECRET' file='virterror' value='65' type='virErrorNumber' info='invalid secret'/>
    <enum name='VIR_ERR_INVALID_STORAGE_POOL' file='virterror' value='46' type='virErrorNumber' info='invalid storage pool object'/>
    <enum name='VIR_ERR_INVALID_STORAGE_VOL' file='virterror' value='47' type='virErrorNumber' info='invalid storage vol object'/>
    <enum name='VIR_ERR_MIGRATE_PERSIST_FAILED' file='virterror' value='69' type='virErrorNumber' info='a migration worked, but making the
VM persist on the dest host failed'/>
    <enum name='VIR_ERR_MULTIPLE_INTERFACES' file='virterror' value='59' type='virErrorNumber' info='more than one matching interface
found'/>
    <enum name='VIR_ERR_NETWORK_EXIST' file='virterror' value='37' type='virErrorNumber' info='the network already exist'/>
    <enum name='VIR_ERR_NONE' file='virterror' value='0' type='virErrorLevel'/>
    <enum name='VIR_ERR_NO_CONNECT' file='virterror' value='5' type='virErrorNumber' info='can&apos;t connect to hypervisor'/>
    <enum name='VIR_ERR_NO_DEVICE' file='virterror' value='23' type='virErrorNumber' info='missing domain devices information'/>
    <enum name='VIR_ERR_NO_DOMAIN' file='virterror' value='42' type='virErrorNumber' info='domain not found or unexpectedly
disappeared'/>
    <enum name='VIR_ERR_NO_DOMAIN_SNAPSHOT' file='virterror' value='72' type='virErrorNumber' info=' domain snapshot not found'/>
    <enum name='VIR_ERR_NO_INTERFACE' file='virterror' value='57' type='virErrorNumber' info='interface driver not running'/>
    <enum name='VIR_ERR_NO_KERNEL' file='virterror' value='17' type='virErrorNumber' info='missing kernel information'/>
    <enum name='VIR_ERR_NO_MEMORY' file='virterror' value='2' type='virErrorNumber' info='memory allocation failure'/>
    <enum name='VIR_ERR_NO_NAME' file='virterror' value='21' type='virErrorNumber' info='missing domain name information'/>
    <enum name='VIR_ERR_NO_NETWORK' file='virterror' value='43' type='virErrorNumber' info='network not found'/>
    <enum name='VIR_ERR_NO_NODE_DEVICE' file='virterror' value='53' type='virErrorNumber' info='node device not found'/>
    <enum name='VIR_ERR_NO_NWFILTER' file='virterror' value='62' type='virErrorNumber' info='nw filter pool not found'/>
    <enum name='VIR_ERR_NO_OS' file='virterror' value='22' type='virErrorNumber' info='missing domain OS information'/>
    <enum name='VIR_ERR_NO_ROOT' file='virterror' value='18' type='virErrorNumber' info='missing root device information'/>
    <enum name='VIR_ERR_NO_SECRET' file='virterror' value='66' type='virErrorNumber' info='secret not found'/>
    <enum name='VIR_ERR_NO_SECURITY_MODEL' file='virterror' value='54' type='virErrorNumber' info='security model not found'/>
    <enum name='VIR_ERR_NO_SOURCE' file='virterror' value='19' type='virErrorNumber' info='missing source device information'/>
    <enum name='VIR_ERR_NO_STORAGE_POOL' file='virterror' value='49' type='virErrorNumber' info='storage pool not found'/>
    <enum name='VIR_ERR_NO_STORAGE_VOL' file='virterror' value='50' type='virErrorNumber' info='storage pool not found'/>
    <enum name='VIR_ERR_NO_SUPPORT' file='virterror' value='3' type='virErrorNumber' info='no support for this function'/>
    <enum name='VIR_ERR_NO_TARGET' file='virterror' value='20' type='virErrorNumber' info='missing target device information'/>
    <enum name='VIR_ERR_NO_XEN' file='virterror' value='14' type='virErrorNumber' info='could not open Xen hypervisor
control'/>
    <enum name='VIR_ERR_NO_XENSTORE' file='virterror' value='24' type='virErrorNumber' info='could not open Xen Store control'/>
    <enum name='VIR_ERR_OK' file='virterror' value='0' type='virErrorNumber'/>
    <enum name='VIR_ERR_OPEN_FAILED' file='virterror' value='30' type='virErrorNumber' info='failed to open a conf file'/>
    <enum name='VIR_ERR_OPERATION_DENIED' file='virterror' value='29' type='virErrorNumber' info='operation forbidden on read-only
connections'/>
    <enum name='VIR_ERR_OPERATION_FAILED' file='virterror' value='9' type='virErrorNumber' info='a command to hypervisor failed'/>
    <enum name='VIR_ERR_OPERATION_INVALID' file='virterror' value='55' type='virErrorNumber' info='operation is not applicable at this
time'/>
    <enum name='VIR_ERR_OPERATION_TIMEOUT' file='virterror' value='68' type='virErrorNumber' info='timeout occurred during operation'/>
    <enum name='VIR_ERR_OS_TYPE' file='virterror' value='16' type='virErrorNumber' info='unknown OS type'/>
    <enum name='VIR_ERR_PARSE_FAILED' file='virterror' value='32' type='virErrorNumber' info='failed to parse a conf file'/>
    <enum name='VIR_ERR_POST_FAILED' file='virterror' value='11' type='virErrorNumber' info='a HTTP POST command to failed'/>
    <enum name='VIR_ERR_READ_FAILED' file='virterror' value='31' type='virErrorNumber' info='failed to read a conf file'/>
    <enum name='VIR_ERR_RPC' file='virterror' value='39' type='virErrorNumber' info='some sort of RPC error'/>
    <enum name='VIR_ERR_SEXPR_SERIAL' file='virterror' value='13' type='virErrorNumber' info='failure to serialize an S-Expr'/>
    <enum name='VIR_ERR_SYSTEM_ERROR' file='virterror' value='38' type='virErrorNumber' info='general system call failure'/>
    <enum name='VIR_ERR_UNKNOWN_HOST' file='virterror' value='4' type='virErrorNumber' info='could not resolve hostname'/>
    <enum name='VIR_ERR_WARNING' file='virterror' value='1' type='virErrorLevel' info='A simple warning'/>
    <enum name='VIR_ERR_WRITE_FAILED' file='virterror' value='34' type='virErrorNumber' info='failed to write a conf file'/>
    <enum name='VIR_ERR_XEN_CALL' file='virterror' value='15' type='virErrorNumber' info='failure doing an hypervisor call'/>
    <enum name='VIR_ERR_XML_DETAIL' file='virterror' value='35' type='virErrorNumber' info='detail of an XML error'/>
    <enum name='VIR_ERR_XML_ERROR' file='virterror' value='27' type='virErrorNumber' info='an XML description is not well
formed or broken'/>
    <enum name='VIR_EVENT_HANDLE_ERROR' file='libvirt' value='4' type='virEventHandleType'/>
    <enum name='VIR_EVENT_HANDLE_HANGUP' file='libvirt' value='8' type='virEventHandleType'/>
    <enum name='VIR_EVENT_HANDLE_READABLE' file='libvirt' value='1' type='virEventHandleType'/>
    <enum name='VIR_EVENT_HANDLE_WRITABLE' file='libvirt' value='2' type='virEventHandleType'/>
    <enum name='VIR_FROM_AUDIT' file='virterror' value='36' type='virErrorDomain' info='Error from auditing subsystem'/>
    <enum name='VIR_FROM_CONF' file='virterror' value='9' type='virErrorDomain' info='Error in the configuration file handling'/>
    <enum name='VIR_FROM_CPU' file='virterror' value='31' type='virErrorDomain' info='Error from CPU driver'/>
    <enum name='VIR_FROM_DOM' file='virterror' value='6' type='virErrorDomain' info='Error when operating on a domain'/>
    <enum name='VIR_FROM_DOMAIN' file='virterror' value='20' type='virErrorDomain' info='Error from domain config'/>
    <enum name='VIR_FROM_DOMAIN_SNAPSHOT' file='virterror' value='35' type='virErrorDomain' info='Error from domain snapshot'/>
    <enum name='VIR_FROM_ESX' file='virterror' value='28' type='virErrorDomain' info='Error from ESX driver'/>
    <enum name='VIR_FROM_HOOK' file='virterror' value='34' type='virErrorDomain' info='Error from Synchronous hooks'/>
    <enum name='VIR_FROM_INTERFACE' file='virterror' value='26' type='virErrorDomain' info='Error when operating on an interface'/>
    <enum name='VIR_FROM_LXC' file='virterror' value='17' type='virErrorDomain' info='Error from Linux Container driver'/>
    <enum name='VIR_FROM_NET' file='virterror' value='11' type='virErrorDomain' info='Error when operating on a network'/>
    <enum name='VIR_FROM_NETWORK' file='virterror' value='19' type='virErrorDomain' info='Error from network config'/>
    <enum name='VIR_FROM_NODEDEV' file='virterror' value='22' type='virErrorDomain' info='Error from node device monitor'/>
    <enum name='VIR_FROM_NONE' file='virterror' value='0' type='virErrorDomain'/>
    <enum name='VIR_FROM_NWFILTER' file='virterror' value='33' type='virErrorDomain' info='Error from network filter driver'/>
    <enum name='VIR_FROM_ONE' file='virterror' value='27' type='virErrorDomain' info='Error from OpenNebula driver'/>
    <enum name='VIR_FROM_OPENVZ' file='virterror' value='14' type='virErrorDomain' info='Error from OpenVZ driver'/>
    <enum name='VIR_FROM_PHYP' file='virterror' value='29' type='virErrorDomain' info='Error from IBM power hypervisor'/>
    <enum name='VIR_FROM_PROXY' file='virterror' value='8' type='virErrorDomain' info='Error in the proxy code; unused since
0.8.6'/>
    <enum name='VIR_FROM_QEMU' file='virterror' value='10' type='virErrorDomain' info='Error at the QEMU daemon'/>
    <enum name='VIR_FROM_REMOTE' file='virterror' value='13' type='virErrorDomain' info='Error from remote driver'/>
    <enum name='VIR_FROM_RPC' file='virterror' value='7' type='virErrorDomain' info='Error in the XML-RPC code'/>
    <enum name='VIR_FROM_SECRET' file='virterror' value='30' type='virErrorDomain' info='Error from secret storage'/>
    <enum name='VIR_FROM_SECURITY' file='virterror' value='24' type='virErrorDomain' info='Error from security framework'/>
    <enum name='VIR_FROM_SEXPR' file='virterror' value='4' type='virErrorDomain' info='Error in the S-Expression code'/>
    <enum name='VIR_FROM_STATS_LINUX' file='virterror' value='16' type='virErrorDomain' info='Error in the Linux Stats code'/>
    <enum name='VIR_FROM_STORAGE' file='virterror' value='18' type='virErrorDomain' info='Error from storage driver'/>
    <enum name='VIR_FROM_STREAMS' file='virterror' value='38' type='virErrorDomain' info='Error from I/O streams'/>
    <enum name='VIR_FROM_SYSINFO' file='virterror' value='37' type='virErrorDomain' info='Error from sysinfo/SMBIOS'/>
    <enum name='VIR_FROM_TEST' file='virterror' value='12' type='virErrorDomain' info='Error from test driver'/>
    <enum name='VIR_FROM_UML' file='virterror' value='21' type='virErrorDomain' info='Error at the UML driver'/>
    <enum name='VIR_FROM_VBOX' file='virterror' value='25' type='virErrorDomain' info='Error from VirtualBox driver'/>
    <enum name='VIR_FROM_VMWARE' file='virterror' value='39' type='virErrorDomain' info=' Error from VMware driver'/>
    <enum name='VIR_FROM_XEN' file='virterror' value='1' type='virErrorDomain' info='Error at Xen hypervisor layer'/>
    <enum name='VIR_FROM_XENAPI' file='virterror' value='32' type='virErrorDomain' info='Error from XenAPI'/>
    <enum name='VIR_FROM_XEND' file='virterror' value='2' type='virErrorDomain' info='Error at connection with xend daemon'/>
    <enum name='VIR_FROM_XENSTORE' file='virterror' value='3' type='virErrorDomain' info='Error at connection with xen store'/>
    <enum name='VIR_FROM_XENXM' file='virterror' value='15' type='virErrorDomain' info='Error at Xen XM layer'/>
    <enum name='VIR_FROM_XEN_INOTIFY' file='virterror' value='23' type='virErrorDomain' info='Error from xen inotify layer'/>
    <enum name='VIR_FROM_XML' file='virterror' value='5' type='virErrorDomain' info='Error in the XML code'/>
    <enum name='VIR_INTERFACE_XML_INACTIVE' file='libvirt' value='1' type='virInterfaceXMLFlags' info=' dump inactive interface information'/>
    <enum name='VIR_MEMORY_PHYSICAL' file='libvirt' value='2' type='virDomainMemoryFlags' info=' addresses are physical addresses'/>
    <enum name='VIR_MEMORY_VIRTUAL' file='libvirt' value='1' type='virDomainMemoryFlags' info='addresses are virtual addresses'/>
    <enum name='VIR_MIGRATE_LIVE' file='libvirt' value='1' type='virDomainMigrateFlags' info='live migration'/>
    <enum name='VIR_MIGRATE_NON_SHARED_DISK' file='libvirt' value='64' type='virDomainMigrateFlags' info='migration with non-shared storage with full disk copy'/>
    <enum name='VIR_MIGRATE_NON_SHARED_INC' file='libvirt' value='128' type='virDomainMigrateFlags' info=' migration with non-shared storage with incremental copy (same base image shared between source and destination)'/>
    <enum name='VIR_MIGRATE_PAUSED' file='libvirt' value='32' type='virDomainMigrateFlags' info='pause on remote side'/>
    <enum name='VIR_MIGRATE_PEER2PEER' file='libvirt' value='2' type='virDomainMigrateFlags' info='direct source -&gt; dest host control channel Note the less-common spelling that we&apos;re stuck with:
VIR_MIGRATE_TUNNELLED should be VIR_MIGRATE_TUNNELED'/>
    <enum name='VIR_MIGRATE_PERSIST_DEST' file='libvirt' value='8' type='virDomainMigrateFlags' info='persist the VM on the destination'/>
    <enum name='VIR_MIGRATE_TUNNELLED' file='libvirt' value='4' type='virDomainMigrateFlags' info='tunnel migration data over libvirtd connection'/>
    <enum name='VIR_MIGRATE_UNDEFINE_SOURCE' file='libvirt' value='16' type='virDomainMigrateFlags' info='undefine the VM on the source'/>
    <enum name='VIR_SECRET_USAGE_TYPE_NONE' file='libvirt' value='0' type='virSecretUsageType'/>
    <enum name='VIR_SECRET_USAGE_TYPE_VOLUME' file='libvirt' value='1' type='virSecretUsageType' info=' Expect more owner types later...'/>
    <enum name='VIR_STORAGE_POOL_BUILDING' file='libvirt' value='1' type='virStoragePoolState' info='Initializing pool, not available'/>
    <enum name='VIR_STORAGE_POOL_BUILD_NEW' file='libvirt' value='0' type='virStoragePoolBuildFlags' info='Regular build from scratch'/>
    <enum name='VIR_STORAGE_POOL_BUILD_REPAIR' file='libvirt' value='1' type='virStoragePoolBuildFlags' info='Repair / reinitialize'/>
    <enum name='VIR_STORAGE_POOL_BUILD_RESIZE' file='libvirt' value='2' type='virStoragePoolBuildFlags' info=' Extend existing pool'/>
    <enum name='VIR_STORAGE_POOL_DEGRADED' file='libvirt' value='3' type='virStoragePoolState' info='Running degraded'/>
    <enum name='VIR_STORAGE_POOL_DELETE_NORMAL' file='libvirt' value='0' type='virStoragePoolDeleteFlags' info='Delete metadata only    (fast)'/>
    <enum name='VIR_STORAGE_POOL_DELETE_ZEROED' file='libvirt' value='1' type='virStoragePoolDeleteFlags' info=' Clear all data to zeros (slow)'/>
    <enum name='VIR_STORAGE_POOL_INACCESSIBLE' file='libvirt' value='4' type='virStoragePoolState' info=' Running, but not accessible'/>
    <enum name='VIR_STORAGE_POOL_INACTIVE' file='libvirt' value='0' type='virStoragePoolState' info='Not running'/>
    <enum name='VIR_STORAGE_POOL_RUNNING' file='libvirt' value='2' type='virStoragePoolState' info='Running normally'/>
    <enum name='VIR_STORAGE_VOL_BLOCK' file='libvirt' value='1' type='virStorageVolType' info=' Block based volumes'/>
    <enum name='VIR_STORAGE_VOL_DELETE_NORMAL' file='libvirt' value='0' type='virStorageVolDeleteFlags' info='Delete metadata only    (fast)'/>
    <enum name='VIR_STORAGE_VOL_DELETE_ZEROED' file='libvirt' value='1' type='virStorageVolDeleteFlags' info=' Clear all data to zeros (slow)'/>
    <enum name='VIR_STORAGE_VOL_FILE' file='libvirt' value='0' type='virStorageVolType' info='Regular file based volumes'/>
    <enum name='VIR_STREAM_EVENT_ERROR' file='libvirt' value='4' type='virStreamEventType'/>
    <enum name='VIR_STREAM_EVENT_HANGUP' file='libvirt' value='8' type='virStreamEventType'/>
    <enum name='VIR_STREAM_EVENT_READABLE' file='libvirt' value='1' type='virStreamEventType'/>
    <enum name='VIR_STREAM_EVENT_WRITABLE' file='libvirt' value='2' type='virStreamEventType'/>
    <enum name='VIR_STREAM_NONBLOCK' file='libvirt' value='1' type='virStreamFlags'/>
    <enum name='VIR_VCPU_BLOCKED' file='libvirt' value='2' type='virVcpuState' info=' the virtual CPU is blocked on resource'/>
    <enum name='VIR_VCPU_OFFLINE' file='libvirt' value='0' type='virVcpuState' info='the virtual CPU is offline'/>
    <enum name='VIR_VCPU_RUNNING' file='libvirt' value='1' type='virVcpuState' info='the virtual CPU is running'/>
    <enum name='VIR_WAR_NO_INTERFACE' file='virterror' value='56' type='virErrorNumber' info='failed to start interface driver'/>
    <enum name='VIR_WAR_NO_NETWORK' file='virterror' value='41' type='virErrorNumber' info='failed to start network'/>
    <enum name='VIR_WAR_NO_NODE' file='virterror' value='51' type='virErrorNumber' info='failed to start node driver'/>
    <enum name='VIR_WAR_NO_NWFILTER' file='virterror' value='60' type='virErrorNumber' info='failed to start nwfilter driver'/>
    <enum name='VIR_WAR_NO_SECRET' file='virterror' value='64' type='virErrorNumber' info='failed to start secret storage'/>
    <enum name='VIR_WAR_NO_STORAGE' file='virterror' value='48' type='virErrorNumber' info='failed to start storage'/>
    <typedef name='virCPUCompareResult' file='libvirt' type='enum'/>
    <struct name='virConnect' file='libvirt' type='struct _virConnect'/>
    <struct name='virConnectAuth' file='libvirt' type='struct _virConnectAuth'>
      <field name='credtype' type='int *' info=' List of supported virConnectCredentialType values'/>
      <field name='ncredtype' type='unsigned int' info=''/>
      <field name='cb' type='virConnectAuthCallbackPtr' info=' Callback used to collect credentials'/>
      <field name='cbdata' type='void *' info=''/>
    </struct>
    <typedef name='virConnectAuthPtr' file='libvirt' type='virConnectAuth *'/>
    <struct name='virConnectCredential' file='libvirt' type='struct _virConnectCredential'>
      <field name='type' type='int' info=' One of virConnectCredentialType constants'/>
      <field name='prompt' type='const char *' info=' Prompt to show to user'/>
      <field name='challenge' type='const char *' info=' Additional challenge to show'/>
      <field name='defresult' type='const char *' info=' Optional default result'/>
      <field name='result' type='char *' info=' Result to be filled with user response (or defresult)'/>
      <field name='resultlen' type='unsigned int' info=' Length of the result'/>
    </struct>
    <typedef name='virConnectCredentialPtr' file='libvirt' type='virConnectCredential *'/>
    <typedef name='virConnectCredentialType' file='libvirt' type='enum'/>
    <typedef name='virConnectFlags' file='libvirt' type='enum'/>
    <typedef name='virConnectPtr' file='libvirt' type='virConnect *'>
      <info><![CDATA[a virConnectPtr is pointer to a virConnect private structure, this is the type used to reference a connection to the Hypervisor in the API.]]></info>
    </typedef>
    <struct name='virDomain' file='libvirt' type='struct _virDomain'/>
    <struct name='virDomainBlockInfo' file='libvirt' type='struct _virDomainBlockInfo'>
      <field name='capacity' type='unsigned long long' info=' logical size in bytes of the block device backing image'/>
      <field name='allocation' type='unsigned long long' info=' highest allocated extent in bytes of the block device backing image'/>
      <field name='physical' type='unsigned long long' info=' physical size in bytes of the container of the backing image'/>
    </struct>
    <typedef name='virDomainBlockInfoPtr' file='libvirt' type='virDomainBlockInfo *'/>
    <typedef name='virDomainBlockStatsPtr' file='libvirt' type='virDomainBlockStatsStruct *'>
      <info><![CDATA[A pointer to a virDomainBlockStats structure]]></info>
    </typedef>
    <struct name='virDomainBlockStatsStruct' file='libvirt' type='struct _virDomainBlockStats'>
      <field name='rd_req' type='long long' info=' number of read requests'/>
      <field name='rd_bytes' type='long long' info=' number of read bytes'/>
      <field name='wr_req' type='long long' info=' number of write requests'/>
      <field name='wr_bytes' type='long long' info=' number of written bytes'/>
      <field name='errs' type='long long' info=' In Xen this returns the mysterious &apos;oo_req&apos;.'/>
    </struct>
    <typedef name='virDomainCoreDumpFlags' file='libvirt' type='enum'/>
    <typedef name='virDomainCreateFlags' file='libvirt' type='enum'/>
    <typedef name='virDomainDeviceModifyFlags' file='libvirt' type='enum'/>
    <typedef name='virDomainEventDefinedDetailType' file='libvirt' type='enum'/>
    <struct name='virDomainEventGraphicsAddress' file='libvirt' type='struct _virDomainEventGraphicsAddress'>
      <field name='family' type='int' info=' Address family, virDomainEventGraphicsAddressType'/>
      <field name='node' type='const char *' info=' Address of node (eg IP address)'/>
      <field name='service' type='const char *' info=' Service name/number (eg TCP port)'/>
    </struct>
    <typedef name='virDomainEventGraphicsAddressPtr' file='libvirt' type='virDomainEventGraphicsAddress *'/>
    <typedef name='virDomainEventGraphicsAddressType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventGraphicsPhase' file='libvirt' type='enum'/>
    <struct name='virDomainEventGraphicsSubject' file='libvirt' type='struct _virDomainEventGraphicsSubject'>
      <field name='nidentity' type='int' info=' Number of identities in arra'/>
      <field name='identities' type='virDomainEventGraphicsSubjectIdentityPtr' info=' Array of identities for subject'/>
    </struct>
    <struct name='virDomainEventGraphicsSubjectIdentity' file='libvirt' type='struct _virDomainEventGraphicsSubjectIdentity'>
      <field name='type' type='const char *' info=' Type of identity'/>
      <field name='name' type='const char *' info=' Identity value'/>
    </struct>
    <typedef name='virDomainEventGraphicsSubjectIdentityPtr' file='libvirt' type='virDomainEventGraphicsSubjectIdentity *'/>
    <typedef name='virDomainEventGraphicsSubjectPtr' file='libvirt' type='virDomainEventGraphicsSubject *'/>
    <typedef name='virDomainEventID' file='libvirt' type='enum'/>
    <typedef name='virDomainEventIOErrorAction' file='libvirt' type='enum'/>
    <typedef name='virDomainEventResumedDetailType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventStartedDetailType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventStoppedDetailType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventSuspendedDetailType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventUndefinedDetailType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventWatchdogAction' file='libvirt' type='enum'/>
    <struct name='virDomainInfo' file='libvirt' type='struct _virDomainInfo'>
      <field name='state' type='unsigned char' info=' the running state, one of virDomainState'/>
      <field name='maxMem' type='unsigned long' info=' the maximum memory in KBytes allowed'/>
      <field name='memory' type='unsigned long' info=' the memory in KBytes used by the domain'/>
      <field name='nrVirtCpu' type='unsigned short' info=' the number of virtual CPUs for the domain'/>
      <field name='cpuTime' type='unsigned long long' info=' the CPU time used in nanoseconds'/>
    </struct>
    <typedef name='virDomainInfoPtr' file='libvirt' type='virDomainInfo *'>
      <info><![CDATA[a virDomainInfoPtr is a pointer to a virDomainInfo structure.]]></info>
    </typedef>
    <typedef name='virDomainInterfaceStatsPtr' file='libvirt' type='virDomainInterfaceStatsStruct *'>
      <info><![CDATA[A pointer to a virDomainInterfaceStats structure]]></info>
    </typedef>
    <struct name='virDomainInterfaceStatsStruct' file='libvirt' type='struct _virDomainInterfaceStats'>
      <field name='rx_bytes' type='long long' info=''/>
      <field name='rx_packets' type='long long' info=''/>
      <field name='rx_errs' type='long long' info=''/>
      <field name='rx_drop' type='long long' info=''/>
      <field name='tx_bytes' type='long long' info=''/>
      <field name='tx_packets' type='long long' info=''/>
      <field name='tx_errs' type='long long' info=''/>
      <field name='tx_drop' type='long long' info=''/>
    </struct>
    <struct name='virDomainJobInfo' file='libvirt' type='struct _virDomainJobInfo'>
      <field name='type' type='int' info=' Time is measured in mill-seconds'/>
      <field name='timeElapsed' type='unsigned long long' info=' Always set'/>
      <field name='timeRemaining' type='unsigned long long' info=' Only for VIR_DOMAIN_JOB_BOUNDED Data is measured in bytes unless otherwise specified
* and is measuring the job as a whole
*
* For VIR_DOMAIN_JOB_UNBOUNDED, dataTotal may be less
* than the final sum of dataProcessed + dataRemaining
* in the event that the hypervisor has to repeat some
* data eg due to dirtied pages during migration
*
* For VIR_DOMAIN_JOB_BOUNDED, dataTotal shall always
* equal sum of dataProcessed + dataRemaining
*'/>
      <field name='dataTotal' type='unsigned long long' info=''/>
      <field name='dataProcessed' type='unsigned long long' info=''/>
      <field name='dataRemaining' type='unsigned long long' info=' As above, but only tracking guest memory progress'/>
      <field name='memTotal' type='unsigned long long' info=''/>
      <field name='memProcessed' type='unsigned long long' info=''/>
      <field name='memRemaining' type='unsigned long long' info=' As above, but only tracking guest disk file progress'/>
      <field name='fileTotal' type='unsigned long long' info=''/>
      <field name='fileProcessed' type='unsigned long long' info=''/>
      <field name='fileRemaining' type='unsigned long long' info=''/>
    </struct>
    <typedef name='virDomainJobInfoPtr' file='libvirt' type='virDomainJobInfo *'/>
    <typedef name='virDomainJobType' file='libvirt' type='enum'/>
    <typedef name='virDomainMemoryFlags' file='libvirt' type='enum'/>
    <typedef name='virDomainMemoryStatPtr' file='libvirt' type='virDomainMemoryStatStruct *'/>
    <struct name='virDomainMemoryStatStruct' file='libvirt' type='struct _virDomainMemoryStat'>
      <field name='tag' type='int' info=''/>
      <field name='val' type='unsigned long long' info=''/>
    </struct>
    <typedef name='virDomainMemoryStatTags' file='libvirt' type='enum'/>
    <typedef name='virDomainMigrateFlags' file='libvirt' type='enum'/>
    <typedef name='virDomainPtr' file='libvirt' type='virDomain *'>
      <info><![CDATA[a virDomainPtr is pointer to a virDomain private structure, this is the type used to reference a domain in the API.]]></info>
    </typedef>
    <struct name='virDomainSnapshot' file='libvirt' type='struct _virDomainSnapshot'/>
    <typedef name='virDomainSnapshotDeleteFlags' file='libvirt' type='enum'/>
    <typedef name='virDomainSnapshotPtr' file='libvirt' type='virDomainSnapshot *'>
      <info><![CDATA[a virDomainSnapshotPtr is pointer to a virDomainSnapshot private structure, and is the type used to reference a domain snapshot in the API.]]></info>
    </typedef>
    <typedef name='virDomainState' file='libvirt' type='enum'/>
    <typedef name='virDomainVcpuFlags' file='libvirt' type='enum'/>
    <typedef name='virDomainXMLFlags' file='libvirt' type='enum'/>
    <struct name='virError' file='virterror' type='struct _virError'>
      <field name='code' type='int' info=' The error code, a virErrorNumber'/>
      <field name='domain' type='int' info=' What part of the library raised this error'/>
      <field name='message' type='char *' info=' human-readable informative error message'/>
      <field name='level' type='virErrorLevel' info=' how consequent is the error'/>
      <field name='conn' type='virConnectPtr' info=' connection if available, deprecated
see note above'/>
      <field name='dom' type='virDomainPtr' info=' domain if available, deprecated
see note above'/>
      <field name='str1' type='char *' info=' extra string information'/>
      <field name='str2' type='char *' info=' extra string information'/>
      <field name='str3' type='char *' info=' extra string information'/>
      <field name='int1' type='int' info=' extra number information'/>
      <field name='int2' type='int' info=' extra number information'/>
      <field name='net' type='virNetworkPtr' info=' network if available, deprecated
see note above'/>
    </struct>
    <typedef name='virErrorDomain' file='virterror' type='enum'/>
    <typedef name='virErrorLevel' file='virterror' type='enum'/>
    <typedef name='virErrorNumber' file='virterror' type='enum'/>
    <typedef name='virErrorPtr' file='virterror' type='virError *'/>
    <typedef name='virEventHandleType' file='libvirt' type='enum'/>
    <struct name='virInterface' file='libvirt' type='struct _virInterface'/>
    <typedef name='virInterfacePtr' file='libvirt' type='virInterface *'>
      <info><![CDATA[a virInterfacePtr is pointer to a virInterface private structure, this is the type used to reference a virtual interface in the API.]]></info>
    </typedef>
    <typedef name='virInterfaceXMLFlags' file='libvirt' type='enum'/>
    <struct name='virMemoryParameter' file='libvirt' type='struct _virMemoryParameter'>
      <field name='field' type='charfield[VIR_DOMAIN_MEMORY_FIELD_LENGTH]' info=' parameter name'/>
      <field name='type' type='int' info=' parameter type'/>
    </struct>
    <typedef name='virMemoryParameterPtr' file='libvirt' type='virMemoryParameter *'>
      <info><![CDATA[a virMemoryParameterPtr is a pointer to a virMemoryParameter structure.]]></info>
    </typedef>
    <typedef name='virMemoryParameterType' file='libvirt' type='enum'/>
    <struct name='virNWFilter' file='libvirt' type='struct _virNWFilter'/>
    <typedef name='virNWFilterPtr' file='libvirt' type='virNWFilter *'>
      <info><![CDATA[a virNWFilterPtr is pointer to a virNWFilter private structure, this is the type used to reference a network filter in the API.]]></info>
    </typedef>
    <struct name='virNetwork' file='libvirt' type='struct _virNetwork'/>
    <typedef name='virNetworkPtr' file='libvirt' type='virNetwork *'>
      <info><![CDATA[a virNetworkPtr is pointer to a virNetwork private structure, this is the type used to reference a virtual network in the API.]]></info>
    </typedef>
    <struct name='virNodeDevice' file='libvirt' type='struct _virNodeDevice'/>
    <typedef name='virNodeDevicePtr' file='libvirt' type='virNodeDevice *'>
      <info><![CDATA[A virNodeDevicePtr is a pointer to a virNodeDevice structure.  Get one via virNodeDeviceLookupByKey, virNodeDeviceLookupByName, or virNodeDeviceCreate.  Be sure to Call virNodeDeviceFree when done using a virNodeDevicePtr obtained from any of the above functions to avoid leaking memory.]]></info>
    </typedef>
    <struct name='virNodeInfo' file='libvirt' type='struct _virNodeInfo'>
      <field name='model' type='charmodel[32]' info=' string indicating the CPU model'/>
      <field name='memory' type='unsigned long' info=' memory size in kilobytes'/>
      <field name='cpus' type='unsigned int' info=' the number of active CPUs'/>
      <field name='mhz' type='unsigned int' info=' expected CPU frequency'/>
      <field name='nodes' type='unsigned int' info=' the number of NUMA cell, 1 for unusual NUMA
topologies or uniform memory access; check
capabilities XML for the actual NUMA topology'/>
      <field name='sockets' type='unsigned int' info=' number of CPU sockets per node if nodes &gt; 1,
total number of CPU sockets otherwise'/>
      <field name='cores' type='unsigned int' info=' number of cores per socket'/>
      <field name='threads' type='unsigned int' info=' number of threads per core'/>
    </struct>
    <typedef name='virNodeInfoPtr' file='libvirt' type='virNodeInfo *'>
      <info><![CDATA[a virNodeInfoPtr is a pointer to a virNodeInfo structure.]]></info>
    </typedef>
    <struct name='virSchedParameter' file='libvirt' type='struct _virSchedParameter'>
      <field name='field' type='charfield[VIR_DOMAIN_SCHED_FIELD_LENGTH]' info=' parameter name'/>
      <field name='type' type='int' info=' parameter type'/>
    </struct>
    <typedef name='virSchedParameterPtr' file='libvirt' type='virSchedParameter *'>
      <info><![CDATA[a virSchedParameterPtr is a pointer to a virSchedParameter structure.]]></info>
    </typedef>
    <typedef name='virSchedParameterType' file='libvirt' type='enum'/>
    <struct name='virSecret' file='libvirt' type='struct _virSecret'/>
    <typedef name='virSecretPtr' file='libvirt' type='virSecret *'/>
    <typedef name='virSecretUsageType' file='libvirt' type='enum'/>
    <struct name='virSecurityLabel' file='libvirt' type='struct _virSecurityLabel'/>
    <typedef name='virSecurityLabelPtr' file='libvirt' type='virSecurityLabel *'>
      <info><![CDATA[a virSecurityLabelPtr is a pointer to a virSecurityLabel.]]></info>
    </typedef>
    <struct name='virSecurityModel' file='libvirt' type='struct _virSecurityModel'/>
    <typedef name='virSecurityModelPtr' file='libvirt' type='virSecurityModel *'>
      <info><![CDATA[a virSecurityModelPtr is a pointer to a virSecurityModel.]]></info>
    </typedef>
    <struct name='virStoragePool' file='libvirt' type='struct _virStoragePool'/>
    <typedef name='virStoragePoolBuildFlags' file='libvirt' type='enum'/>
    <typedef name='virStoragePoolDeleteFlags' file='libvirt' type='enum'/>
    <struct name='virStoragePoolInfo' file='libvirt' type='struct _virStoragePoolInfo'>
      <field name='state' type='int' info=' virStoragePoolState flags'/>
      <field name='capacity' type='unsigned long long' info=' Logical size bytes'/>
      <field name='allocation' type='unsigned long long' info=' Current allocation bytes'/>
      <field name='available' type='unsigned long long' info=' Remaining free space bytes'/>
    </struct>
    <typedef name='virStoragePoolInfoPtr' file='libvirt' type='virStoragePoolInfo *'/>
    <typedef name='virStoragePoolPtr' file='libvirt' type='virStoragePool *'>
      <info><![CDATA[a virStoragePoolPtr is pointer to a virStoragePool private structure, this is the type used to reference a storage pool in the API.]]></info>
    </typedef>
    <typedef name='virStoragePoolState' file='libvirt' type='enum'/>
    <struct name='virStorageVol' file='libvirt' type='struct _virStorageVol'/>
    <typedef name='virStorageVolDeleteFlags' file='libvirt' type='enum'/>
    <struct name='virStorageVolInfo' file='libvirt' type='struct _virStorageVolInfo'>
      <field name='type' type='int' info=' virStorageVolType flags'/>
      <field name='capacity' type='unsigned long long' info=' Logical size bytes'/>
      <field name='allocation' type='unsigned long long' info=' Current allocation bytes'/>
    </struct>
    <typedef name='virStorageVolInfoPtr' file='libvirt' type='virStorageVolInfo *'/>
    <typedef name='virStorageVolPtr' file='libvirt' type='virStorageVol *'>
      <info><![CDATA[a virStorageVolPtr is pointer to a virStorageVol private structure, this is the type used to reference a storage volume in the API.]]></info>
    </typedef>
    <typedef name='virStorageVolType' file='libvirt' type='enum'/>
    <struct name='virStream' file='libvirt' type='struct _virStream'/>
    <typedef name='virStreamEventType' file='libvirt' type='enum'/>
    <typedef name='virStreamFlags' file='libvirt' type='enum'/>
    <typedef name='virStreamPtr' file='libvirt' type='virStream *'>
      <info><![CDATA[a virStreamPtr is pointer to a virStream private structure, this is the type used to reference a data stream in the API.]]></info>
    </typedef>
    <struct name='virVcpuInfo' file='libvirt' type='struct _virVcpuInfo'>
      <field name='number' type='unsigned int' info=' virtual CPU number'/>
      <field name='state' type='int' info=' value from virVcpuState'/>
      <field name='cpuTime' type='unsigned long long' info=' CPU time used, in nanoseconds'/>
      <field name='cpu' type='int' info=' real CPU number, or -1 if offline'/>
    </struct>
    <typedef name='virVcpuInfoPtr' file='libvirt' type='virVcpuInfo *'/>
    <typedef name='virVcpuState' file='libvirt' type='enum'/>
    <variable name='virConnectAuthPtrDefault' file='libvirt' type='virConnectAuthPtr'/>
    <function name='virConnCopyLastError' file='virterror' module='virterror'>
      <info><![CDATA[Copy the content of the last error caught on that connection

This method is not protected against access from multiple
threads. In a multi-threaded application, always use the
global virGetLastError() API which is backed by thread
local storage.

If the connection object was discovered to be invalid by
an API call, then the error will be reported against the
global error object.

Since 0.6.0, all errors reported in the per-connection object
are also duplicated in the global error object. As such an
application can always use virGetLastError(). This method
remains for backwards compatability.

One will need to free the result with virResetError()]]></info>
      <return type='int' info='0 if no error was found and the error code otherwise and -1 in case of parameter error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='to' type='virErrorPtr' info='target to receive the copy'/>
    </function>
    <function name='virConnGetLastError' file='virterror' module='virterror'>
      <info><![CDATA[Provide a pointer to the last error caught on that connection

This method is not protected against access from multiple
threads. In a multi-threaded application, always use the
global virGetLastError() API which is backed by thread
local storage.

If the connection object was discovered to be invalid by
an API call, then the error will be reported against the
global error object.

Since 0.6.0, all errors reported in the per-connection object
are also duplicated in the global error object. As such an
application can always use virGetLastError(). This method
remains for backwards compatability.]]></info>
      <return type='virErrorPtr' info='a pointer to the last error or NULL if none occurred.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnResetLastError' file='virterror' module='virterror'>
      <info><![CDATA[The error object is kept in thread local storage, so separate
threads can safely access this concurrently.

Reset the last error caught on that connection]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnSetErrorFunc' file='virterror' module='virterror'>
      <info><![CDATA[Set a connection error handling function, if @handler is NULL
it will reset to default which is to pass error back to the global
library handler.]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='userData' type='void *' info='pointer to the user data provided in the handler callback'/>
      <arg name='handler' type='virErrorFunc' info='the function to get called in case of error or NULL'/>
    </function>
    <functype name='virConnectAuthCallbackPtr' file='libvirt' module='libvirt'>
      <info><![CDATA[When authentication requires one or more interactions, this callback
is invoked. For each interaction supplied, data must be gathered
from the user and filled in to the 'result' and 'resultlen' fields.
If an interaction can not be filled, fill in NULL and 0.]]></info>
      <return type='int' info='0 if all interactions were filled, or -1 upon error'/>
      <arg name='cred' type='virConnectCredentialPtr' info='list of virConnectCredential object to fetch from user'/>
      <arg name='ncred' type='unsigned int' info='size of cred list'/>
      <arg name='cbdata' type='void *' info='opaque data passed to virConnectOpenAuth'/>
    </functype>
    <function name='virConnectBaselineCPU' file='libvirt' module='libvirt'>
      <info><![CDATA[Computes the most feature-rich CPU which is compatible with all given
host CPUs.]]></info>
      <return type='char *' info='XML description of the computed CPU or NULL on error.'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='xmlCPUs' type='const char **' info='array of XML descriptions of host CPUs'/>
      <arg name='ncpus' type='unsigned int' info='number of CPUs in xmlCPUs'/>
      <arg name='flags' type='unsigned int' info='fine-tuning flags, currently unused, pass 0.'/>
    </function>
    <function name='virConnectClose' file='libvirt' module='libvirt'>
      <info><![CDATA[This function closes the connection to the Hypervisor. This should
not be called if further interaction with the Hypervisor are needed
especially if there is running domain which need further monitoring by
the application.]]></info>
      <return type='int' info='0 in case of success or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectCompareCPU' file='libvirt' module='libvirt'>
      <info><![CDATA[Compares the given CPU description with the host CPU]]></info>
      <return type='int' info='comparison result according to enum virCPUCompareResult'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='xmlDesc' type='const char *' info='XML describing the CPU to compare with host CPU'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <functype name='virConnectDomainEventCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[A callback function to be registered, and called when a domain event occurs]]></info>
      <return type='int' info=''/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='dom' type='virDomainPtr' info='The domain on which the event occured'/>
      <arg name='event' type='int' info='The specfic virDomainEventType which occured'/>
      <arg name='detail' type='int' info='event specific detail information'/>
      <arg name='opaque' type='void *' info='opaque user data'/>
    </functype>
    <function name='virConnectDomainEventDeregister' file='libvirt' module='libvirt'>
      <info><![CDATA[Removes a callback previously registered with the virConnectDomainEventRegister
funtion.

Use of this method is no longer recommended. Instead applications
should try virConnectDomainEventUnregisterAny which has a more flexible
API contract]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='cb' type='virConnectDomainEventCallback' info='callback to the function handling domain events'/>
    </function>
    <function name='virConnectDomainEventDeregisterAny' file='libvirt' module='libvirt'>
      <info><![CDATA[Removes an event callback. The callbackID parameter should be the
vaule obtained from a previous virDomainEventRegisterAny method.]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='callbackID' type='int' info='the callback identifier'/>
    </function>
    <functype name='virConnectDomainEventGenericCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[A generic domain event callback handler. Specific events usually
have a customization with extra parameters]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='the connection pointer'/>
      <arg name='dom' type='virDomainPtr' info='the domain pointer'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventGraphicsCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_GRAPHICS with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='phase' type='int' info='the phase of the connection'/>
      <arg name='local' type='virDomainEventGraphicsAddressPtr' info='the local server address'/>
      <arg name='remote' type='virDomainEventGraphicsAddressPtr' info='the remote client address'/>
      <arg name='authScheme' type='const char *' info='the authentication scheme activated'/>
      <arg name='subject' type='virDomainEventGraphicsSubjectPtr' info='the authenticated subject (user)'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventIOErrorCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_IO_ERROR with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='srcPath' type='const char *' info='The host file on which the IO error occurred'/>
      <arg name='devAlias' type='const char *' info='The guest device alias associated with the path'/>
      <arg name='action' type='int' info='action that is to be taken due to the IO error'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventIOErrorReasonCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_IO_ERROR with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='srcPath' type='const char *' info='The host file on which the IO error occurred'/>
      <arg name='devAlias' type='const char *' info='The guest device alias associated with the path'/>
      <arg name='action' type='int' info='action that is to be taken due to the IO error'/>
      <arg name='reason' type='const char *' info='the cause of the IO error'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <functype name='virConnectDomainEventRTCChangeCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_RTC_CHANGE with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='utcoffset' type='long long' info='the new RTC offset from UTC, measured in seconds'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <function name='virConnectDomainEventRegister' file='libvirt' module='libvirt'>
      <info><![CDATA[Adds a callback to receive notifications of domain lifecycle events
occurring on a connection

Use of this method is no longer recommended. Instead applications
should try virConnectDomainEventRegisterAny which has a more flexible
API contract

The virDomainPtr object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the domain object after the callback]]></info>
      <return type='int' info='it shall take a reference to it, by calling virDomainRef. The reference can be released once the object is no longer required by calling virDomainFree.  Returns 0 on success, -1 on failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='cb' type='virConnectDomainEventCallback' info='callback to the function handling domain events'/>
      <arg name='opaque' type='void *' info='opaque data to pass on to the callback'/>
      <arg name='freecb' type='virFreeCallback' info='optional function to deallocate opaque when not used anymore'/>
    </function>
    <function name='virConnectDomainEventRegisterAny' file='libvirt' module='libvirt'>
      <info><![CDATA[Adds a callback to receive notifications of arbitrary domain events
occurring on a domain.

If dom is NULL, then events will be monitored for any domain. If dom
is non-NULL, then only the specific domain will be monitored

Most types of event have a callback providing a custom set of parameters
for the event. When registering an event, it is thus neccessary to use
the VIR_DOMAIN_EVENT_CALLBACK() macro to cast the supplied function pointer
to match the signature of this method.

The virDomainPtr object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the domain object after the callback]]></info>
      <return type='int' info='it shall take a reference to it, by calling virDomainRef. The reference can be released once the object is no longer required by calling virDomainFree.  The return value from this method is a positive integer identifier for the callback. To unregister a callback, this callback ID should be passed to the virDomainEventUnregisterAny method  Returns a callback identifier on success, -1 on failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain'/>
      <arg name='eventID' type='int' info='the event type to receive'/>
      <arg name='cb' type='virConnectDomainEventGenericCallback' info='callback to the function handling domain events'/>
      <arg name='opaque' type='void *' info='opaque data to pass on to the callback'/>
      <arg name='freecb' type='virFreeCallback' info='optional function to deallocate opaque when not used anymore'/>
    </function>
    <functype name='virConnectDomainEventWatchdogCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_WATCHDOG with virConnectDomainEventRegisterAny()]]></info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='connection object'/>
      <arg name='dom' type='virDomainPtr' info='domain on which the event occurred'/>
      <arg name='action' type='int' info='action that is to be taken due to watchdog firing'/>
      <arg name='opaque' type='void *' info='application specified data'/>
    </functype>
    <function name='virConnectDomainXMLFromNative' file='libvirt' module='libvirt'>
      <info><![CDATA[Reads native configuration data  describing a domain, and
generates libvirt domain XML. The format of the native
data is hypervisor dependant.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='conn' type='virConnectPtr' info='a connection object'/>
      <arg name='nativeFormat' type='const char *' info='configuration format importing from'/>
      <arg name='nativeConfig' type='const char *' info='the configuration data to import'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <function name='virConnectDomainXMLToNative' file='libvirt' module='libvirt'>
      <info><![CDATA[Reads a domain XML configuration document, and generates
a native configuration file describing the domain.
The format of the native data is hypervisor dependant.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded native config datafile, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='conn' type='virConnectPtr' info='a connection object'/>
      <arg name='nativeFormat' type='const char *' info='configuration format exporting to'/>
      <arg name='domainXml' type='const char *' info='the domain configuration to export'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass 0'/>
    </function>
    <function name='virConnectFindStoragePoolSources' file='libvirt' module='libvirt'>
      <info><![CDATA[Talks to a storage backend and attempts to auto-discover the set of
available storage pool sources. e.g. For iSCSI this would be a set of
iSCSI targets. For NFS this would be a list of exported paths.  The
srcSpec (optional for some storage pool types, e.g. local ones) is
an instance of the storage pool's source element specifying where
to look for the pools.

srcSpec is not required for some types (e.g., those querying
local storage resources only)]]></info>
      <return type='char *' info='an xml document consisting of a SourceList element containing a source document appropriate to the given pool type for each discovered source.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='type' type='const char *' info='type of storage pool sources to discover'/>
      <arg name='srcSpec' type='const char *' info='XML document specifying discovery source'/>
      <arg name='flags' type='unsigned int' info='flags for discovery (unused, pass 0)'/>
    </function>
    <function name='virConnectGetCapabilities' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides capabilities of the hypervisor / driver.]]></info>
      <return type='char *' info='NULL in case of error, or an XML string defining the capabilities. The client must free the returned string after use.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetHostname' file='libvirt' module='libvirt'>
      <info><![CDATA[This returns the system hostname on which the hypervisor is
running (the result of the gethostname system call).  If
we are connected to a remote system, then this returns the
hostname of the remote system.]]></info>
      <return type='char *' info='the hostname which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
    </function>
    <function name='virConnectGetLibVersion' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides @libVer, which is the version of libvirt used by the
  daemon running on the @conn host]]></info>
      <return type='int' info='-1 in case of failure, 0 otherwise, and values for @libVer have the format major * 1,000,000 + minor * 1,000 + release.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='libVer' type='unsigned long *' info='returns the libvirt library version used on the connection (OUT)'/>
    </function>
    <function name='virConnectGetMaxVcpus' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the maximum number of virtual CPUs supported for a guest VM of a
specific type. The 'type' parameter here corresponds to the 'type'
attribute in the <domain> element of the XML.]]></info>
      <return type='int' info='the maximum of virtual CPU or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='type' type='const char *' info='value of the &apos;type&apos; attribute in the &lt;domain&gt; element'/>
    </function>
    <function name='virConnectGetSysinfo' file='libvirt' module='libvirt'>
      <info><![CDATA[This returns the XML description of the sysinfo details for the
host on which the hypervisor is running, in the same format as the
<sysinfo> element of a domain XML.  This information is generally
available only for hypervisors running with root privileges.]]></info>
      <return type='char *' info='the XML string which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
      <arg name='flags' type='unsigned int' info='callers should always pass 0'/>
    </function>
    <function name='virConnectGetType' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the name of the Hypervisor software used.]]></info>
      <return type='const char *' info='NULL in case of error, a static zero terminated string otherwise.  See also: http://www.redhat.com/archives/libvir-list/2007-February/msg00096.html'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetURI' file='libvirt' module='libvirt'>
      <info><![CDATA[This returns the URI (name) of the hypervisor connection.
Normally this is the same as or similar to the string passed
to the virConnectOpen/virConnectOpenReadOnly call, but
the driver may make the URI canonical.  If name == NULL
was passed to virConnectOpen, then the driver will return
a non-NULL URI which can be used to connect to the same
hypervisor later.]]></info>
      <return type='char *' info='the URI string which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
    </function>
    <function name='virConnectGetVersion' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the version level of the Hypervisor running. This may work only with
hypervisor call, i.e. with privileged access to the hypervisor, not
with a Read-Only connection.]]></info>
      <return type='int' info='-1 in case of error, 0 otherwise. if the version can&apos;t be extracted by lack of capacities returns 0 and @hvVer is 0, otherwise @hvVer value is major * 1,000,000 + minor * 1,000 + release'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='hvVer' type='unsigned long *' info='return value for the version of the running hypervisor (OUT)'/>
    </function>
    <function name='virConnectIsEncrypted' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the connection to the hypervisor is encrypted]]></info>
      <return type='int' info='1 if encrypted, 0 if not encrypted, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection object'/>
    </function>
    <function name='virConnectIsSecure' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the connection to the hypervisor is secure

A connection will be classed as secure if it is either
encrypted, or running over a channel which is not exposed
to eavesdropping (eg a UNIX domain socket, or pipe)]]></info>
      <return type='int' info='1 if secure, 0 if secure, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection object'/>
    </function>
    <function name='virConnectListDefinedDomains' file='libvirt' module='libvirt'>
      <info><![CDATA[list the defined but inactive domains, stores the pointers to the names
in @names]]></info>
      <return type='int' info='the number of names provided in the array or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='pointer to an array to store the names'/>
      <arg name='maxnames' type='int' info='size of the array'/>
    </function>
    <function name='virConnectListDefinedInterfaces' file='libvirt' module='libvirt'>
      <info><![CDATA[Collect the list of defined (inactive) physical host interfaces,
and store their names in @names.]]></info>
      <return type='int' info='the number of interfaces found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='array to collect the list of names of interfaces'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virConnectListDefinedNetworks' file='libvirt' module='libvirt'>
      <info><![CDATA[list the inactive networks, stores the pointers to the names in @names]]></info>
      <return type='int' info='the number of names provided in the array or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='pointer to an array to store the names'/>
      <arg name='maxnames' type='int' info='size of the array'/>
    </function>
    <function name='virConnectListDefinedStoragePools' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the list of names of inactive storage pools
upto maxnames. If there are more than maxnames, the
remaining names will be silently ignored.]]></info>
      <return type='int' info='0 on success, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='names' type='char ** const' info='array of char * to fill with pool names (allocated by caller)'/>
      <arg name='maxnames' type='int' info='size of the names array'/>
    </function>
    <function name='virConnectListDomains' file='libvirt' module='libvirt'>
      <info><![CDATA[Collect the list of active domains, and store their ID in @maxids]]></info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='ids' type='int *' info='array to collect the list of IDs of active domains'/>
      <arg name='maxids' type='int' info='size of @ids'/>
    </function>
    <function name='virConnectListInterfaces' file='libvirt' module='libvirt'>
      <info><![CDATA[Collect the list of active physical host interfaces,
and store their names in @names]]></info>
      <return type='int' info='the number of interfaces found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='array to collect the list of names of interfaces'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virConnectListNWFilters' file='libvirt' module='libvirt'>
      <info><![CDATA[Collect the list of network filters, and store their names in @names]]></info>
      <return type='int' info='the number of network filters found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='array to collect the list of names of network filters'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virConnectListNetworks' file='libvirt' module='libvirt'>
      <info><![CDATA[Collect the list of active networks, and store their names in @names]]></info>
      <return type='int' info='the number of networks found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='array to collect the list of names of active networks'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virConnectListSecrets' file='libvirt' module='libvirt'>
      <info><![CDATA[List UUIDs of defined secrets, store pointers to names in uuids.]]></info>
      <return type='int' info='the number of UUIDs provided in the array, or -1 on failure.'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='uuids' type='char **' info='Pointer to an array to store the UUIDs'/>
      <arg name='maxuuids' type='int' info='size of the array.'/>
    </function>
    <function name='virConnectListStoragePools' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the list of names of active storage pools
upto maxnames. If there are more than maxnames, the
remaining names will be silently ignored.]]></info>
      <return type='int' info='0 on success, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='names' type='char ** const' info='array of char * to fill with pool names (allocated by caller)'/>
      <arg name='maxnames' type='int' info='size of the names array'/>
    </function>
    <function name='virConnectNumOfDefinedDomains' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of defined but inactive domains.]]></info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDefinedInterfaces' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of defined (inactive) interfaces on the physical host.]]></info>
      <return type='int' info='the number of defined interface found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDefinedNetworks' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of inactive networks.]]></info>
      <return type='int' info='the number of networks found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDefinedStoragePools' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of inactive storage pools]]></info>
      <return type='int' info='the number of pools found, or -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDomains' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of active domains.]]></info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfInterfaces' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of active interfaces on the physical host.]]></info>
      <return type='int' info='the number of active interfaces found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfNWFilters' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of nwfilters.]]></info>
      <return type='int' info='the number of nwfilters found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfNetworks' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of active networks.]]></info>
      <return type='int' info='the number of network found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfSecrets' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch number of currently defined secrets.]]></info>
      <return type='int' info='the number currently defined secrets.'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
    </function>
    <function name='virConnectNumOfStoragePools' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of active storage pools]]></info>
      <return type='int' info='the number of pools found, or -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
    </function>
    <function name='virConnectOpen' file='libvirt' module='libvirt'>
      <info><![CDATA[This function should be called first to get a connection to the
Hypervisor and xen store]]></info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error  If @name is NULL then probing will be done to determine a suitable default driver to activate. This involves trying each hypervisor in turn until one successfully opens. If the LIBVIRT_DEFAULT_URI environment variable is set, then it will be used in preference to probing for a driver.  If connecting to an unprivileged hypervisor driver which requires the libvirtd daemon to be active, it will automatically be launched if not already running. This can be prevented by setting the environment variable LIBVIRT_AUTOSTART=0  URIs are documented at http://libvirt.org/uri.html'/>
      <arg name='name' type='const char *' info='URI of the hypervisor'/>
    </function>
    <function name='virConnectOpenAuth' file='libvirt' module='libvirt'>
      <info><![CDATA[This function should be called first to get a connection to the
Hypervisor. If necessary, authentication will be performed fetching
credentials via the callback

See virConnectOpen for notes about environment variables which can
have an effect on opening drivers]]></info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error  URIs are documented at http://libvirt.org/uri.html'/>
      <arg name='name' type='const char *' info='URI of the hypervisor'/>
      <arg name='auth' type='virConnectAuthPtr' info='Authenticate callback parameters'/>
      <arg name='flags' type='int' info='Open flags'/>
    </function>
    <function name='virConnectOpenReadOnly' file='libvirt' module='libvirt'>
      <info><![CDATA[This function should be called first to get a restricted connection to the
library functionalities. The set of APIs usable are then restricted
on the available methods to control the domains.

See virConnectOpen for notes about environment variables which can
have an effect on opening drivers]]></info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error  URIs are documented at http://libvirt.org/uri.html'/>
      <arg name='name' type='const char *' info='URI of the hypervisor'/>
    </function>
    <function name='virConnectRef' file='libvirt' module='libvirt'>
      <info><![CDATA[Increment the reference count on the connection. For each
additional call to this method, there shall be a corresponding
call to virConnectClose to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a connection would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='the connection to hold a reference on'/>
    </function>
    <function name='virCopyLastError' file='virterror' module='virterror'>
      <info><![CDATA[Copy the content of the last error caught at the library level

The error object is kept in thread local storage, so separate
threads can safely access this concurrently.

One will need to free the result with virResetError()]]></info>
      <return type='int' info='0 if no error was found and the error code otherwise and -1 in case of parameter error.'/>
      <arg name='to' type='virErrorPtr' info='target to receive the copy'/>
    </function>
    <function name='virDefaultErrorFunc' file='virterror' module='virterror'>
      <info><![CDATA[Default routine reporting an error to stderr.]]></info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='pointer to the error.'/>
    </function>
    <function name='virDomainAbortJob' file='libvirt' module='libvirt'>
      <info><![CDATA[Requests that the current background job be aborted at the
soonest opportunity. This will block until the job has
either completed, or aborted.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainAttachDevice' file='libvirt' module='libvirt'>
      <info><![CDATA[Create a virtual device attachment to backend.  This function,
having hotplug semantics, is only allowed on an active domain.

For compatibility, this method can also be used to change the media
in an existing CDROM/Floppy device, however, applications are
recommended to use the virDomainUpdateDeviceFlag method instead.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
    </function>
    <function name='virDomainAttachDeviceFlags' file='libvirt' module='libvirt'>
      <info><![CDATA[Attach a virtual device to a domain, using the flags parameter
to control how the device is attached.  VIR_DOMAIN_DEVICE_MODIFY_CURRENT
specifies that the device allocation is made based on current domain
state.  VIR_DOMAIN_DEVICE_MODIFY_LIVE specifies that the device shall be
allocated to the active domain instance only and is not added to the
persisted domain configuration.  VIR_DOMAIN_DEVICE_MODIFY_CONFIG
specifies that the device shall be allocated to the persisted domain
configuration only.  Note that the target hypervisor must return an
error if unable to satisfy flags.  E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports modifying the
persisted device allocation.

For compatibility, this method can also be used to change the media
in an existing CDROM/Floppy device, however, applications are
recommended to use the virDomainUpdateDeviceFlag method instead.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
      <arg name='flags' type='unsigned int' info='an OR&apos;ed set of virDomainDeviceModifyFlags'/>
    </function>
    <function name='virDomainBlockPeek' file='libvirt' module='libvirt'>
      <info><![CDATA[This function allows you to read the contents of a domain's
disk device.

Typical uses for this are to determine if the domain has
written a Master Boot Record (indicating that the domain
has completed installation), or to try to work out the state
of the domain's filesystems.

(Note that in the local case you might try to open the
block device or file directly, but that won't work in the
remote case, nor if you don't have sufficient permission.
Hence the need for this call).

'path' must be a device or file corresponding to the domain.
In other words it must be the precise string returned in
a <disk><source dev='...'/></disk> from
virDomainGetXMLDesc.

'offset' and 'size' represent an area which must lie entirely
within the device or file.  'size' may be 0 to test if the
call would succeed.

'buffer' is the return buffer and must be at least 'size' bytes.

NB. The remote driver imposes a 64K byte limit on 'size'.
For your program to be able to work reliably over a remote
connection you should split large requests to <= 65536 bytes.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure. really 64 bits'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='path' type='const char *' info='path to the block device'/>
      <arg name='offset' type='unsigned long long' info='offset within block device'/>
      <arg name='size' type='size_t' info='size to read'/>
      <arg name='buffer' type='void *' info='return buffer (must be at least size bytes)'/>
      <arg name='flags' type='unsigned int' info='unused, always pass 0'/>
    </function>
    <function name='virDomainBlockStats' file='libvirt' module='libvirt'>
      <info><![CDATA[This function returns block device (disk) stats for block
devices attached to the domain.

The path parameter is the name of the block device.  Get this
by calling virDomainGetXMLDesc and finding the <target dev='...'>
attribute within //domain/devices/disk.  (For example, "xvda").

Domains may have more than one block device.  To get stats for
each you should make multiple calls to this function.

Individual fields within the stats structure may be returned
as -1, which indicates that the hypervisor does not support
that particular statistic.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='path' type='const char *' info='path to the block device'/>
      <arg name='stats' type='virDomainBlockStatsPtr' info='block device stats (returned)'/>
      <arg name='size' type='size_t' info='size of stats structure'/>
    </function>
    <function name='virDomainCoreDump' file='libvirt' module='libvirt'>
      <info><![CDATA[This method will dump the core of a domain on a given file for analysis.
Note that for remote Xen Daemon the file path will be interpreted in
the remote host.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the core file'/>
      <arg name='flags' type='int' info='extra flags, currently unused'/>
    </function>
    <function name='virDomainCreate' file='libvirt' module='libvirt'>
      <info><![CDATA[Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
    </function>
    <function name='virDomainCreateLinux' file='libvirt' module='libvirt'>
      <info><![CDATA[Deprecated after 0.4.6.
Renamed to virDomainCreateXML() providing identical functionality.
This existing name will left indefinitely for API compatibility.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the domain'/>
      <arg name='flags' type='unsigned int' info='callers should always pass 0'/>
    </function>
    <function name='virDomainCreateWithFlags' file='libvirt' module='libvirt'>
      <info><![CDATA[Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
      <arg name='flags' type='unsigned int' info='bitwise-or of supported virDomainCreateFlags'/>
    </function>
    <function name='virDomainCreateXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Launch a new guest domain, based on an XML description similar
to the one returned by virDomainGetXMLDesc()
This function may requires privileged access to the hypervisor.
The domain is not persistent, so its definition will disappear when it
is destroyed, or if the host is restarted (see virDomainDefineXML() to
define persistent domains).]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the domain'/>
      <arg name='flags' type='unsigned int' info='bitwise-or of supported virDomainCreateFlags'/>
    </function>
    <function name='virDomainDefineXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Define a domain, but does not start it.
This definition is persistent, until explicitly undefined with
virDomainUndefine(). A previous definition for this domain would be
overriden if it already exists.]]></info>
      <return type='virDomainPtr' info='NULL in case of error, a pointer to the domain otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the domain, preferably in UTF-8'/>
    </function>
    <function name='virDomainDestroy' file='libvirt' module='libvirt'>
      <info><![CDATA[Destroy the domain object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor. This
does not free the associated virDomainPtr object.
This function may require privileged access]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainDetachDevice' file='libvirt' module='libvirt'>
      <info><![CDATA[Destroy a virtual device attachment to backend.  This function,
having hot-unplug semantics, is only allowed on an active domain.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
    </function>
    <function name='virDomainDetachDeviceFlags' file='libvirt' module='libvirt'>
      <info><![CDATA[Detach a virtual device from a domain, using the flags parameter
to control how the device is detached.  VIR_DOMAIN_DEVICE_MODIFY_CURRENT
specifies that the device allocation is removed based on current domain
state.  VIR_DOMAIN_DEVICE_MODIFY_LIVE specifies that the device shall be
deallocated from the active domain instance only and is not from the
persisted domain configuration.  VIR_DOMAIN_DEVICE_MODIFY_CONFIG
specifies that the device shall be deallocated from the persisted domain
configuration only.  Note that the target hypervisor must return an
error if unable to satisfy flags.  E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports removing the
persisted device allocation.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
      <arg name='flags' type='unsigned int' info='an OR&apos;ed set of virDomainDeviceModifyFlags'/>
    </function>
    <function name='virDomainFree' file='libvirt' module='libvirt'>
      <info><![CDATA[Free the domain object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetAutostart' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides a boolean value indicating whether the domain
configured to be automatically started when the host
machine boots.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='autostart' type='int *' info='the value returned'/>
    </function>
    <function name='virDomainGetBlockInfo' file='libvirt' module='libvirt'>
      <info><![CDATA[Extract information about a domain's block device.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='path' type='const char *' info='path to the block device or file'/>
      <arg name='info' type='virDomainBlockInfoPtr' info='pointer to a virDomainBlockInfo structure allocated by the user'/>
      <arg name='flags' type='unsigned int' info='currently unused, pass zero'/>
    </function>
    <function name='virDomainGetConnect' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the connection pointer associated with a domain.  The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function.  Instead, store the connection and
the domain object together.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to a domain'/>
    </function>
    <function name='virDomainGetID' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the hypervisor ID number for the domain]]></info>
      <return type='unsigned int' info='the domain ID number or (unsigned int) -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetInfo' file='libvirt' module='libvirt'>
      <info><![CDATA[Extract information about a domain. Note that if the connection
used to get the domain is limited only a partial set of the information
can be extracted.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='info' type='virDomainInfoPtr' info='pointer to a virDomainInfo structure allocated by the user'/>
    </function>
    <function name='virDomainGetJobInfo' file='libvirt' module='libvirt'>
      <info><![CDATA[Extract information about progress of a background job on a domain.
Will return an error if the domain is not active.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='info' type='virDomainJobInfoPtr' info='pointer to a virDomainJobInfo structure allocated by the user'/>
    </function>
    <function name='virDomainGetMaxMemory' file='libvirt' module='libvirt'>
      <info><![CDATA[Retrieve the maximum amount of physical memory allocated to a
domain. If domain is NULL, then this get the amount of memory reserved
to Domain0 i.e. the domain where the application runs.]]></info>
      <return type='unsigned long' info='the memory size in kilobytes or 0 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
    </function>
    <function name='virDomainGetMaxVcpus' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the maximum number of virtual CPUs supported for
the guest VM. If the guest is inactive, this is basically
the same as virConnectGetMaxVcpus(). If the guest is running
this will reflect the maximum number of virtual CPUs the
guest was booted with.  For more details, see virDomainGetVcpusFlags().]]></info>
      <return type='int' info='the maximum of virtual CPU or -1 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
    </function>
    <function name='virDomainGetMemoryParameters' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the memory parameters, the @params array will be filled with the values
equal to the number of parameters suggested by @nparams

As the value of @nparams is dynamic, call the API setting @nparams to 0 and
@params as NULL, the API returns the number of parameters supported by the
HV by updating @nparams on SUCCESS. The caller should then allocate @params
array, i.e. (sizeof(@virMemoryParameter) * @nparams) bytes and call the API
again.

Here is the sample code snippet:

if ((virDomainGetMemoryParameters(dom, NULL, &nparams, 0) == 0) &&
    (nparams != 0)) {
    params = vshMalloc(ctl, sizeof(virMemoryParameter) * nparams);
    memset(params, 0, sizeof(virMemoryParameter) * nparams);
    if (virDomainGetMemoryParameters(dom, params, &nparams, 0)) {
        vshError(ctl, "%s", _("Unable to get memory parameters"));
        goto error;
    }
}

This function requires privileged access to the hypervisor. This function
expects the caller to allocate the @params.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virMemoryParameterPtr' info='pointer to memory parameter object (return value, allocated by the caller)'/>
      <arg name='nparams' type='int *' info='pointer to number of memory parameters'/>
      <arg name='flags' type='unsigned int' info='currently unused, for future extension'/>
    </function>
    <function name='virDomainGetName' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the public name for that domain]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the domain object.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetOSType' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the type of domain operation system.]]></info>
      <return type='char *' info='the new string or NULL in case of error, the string must be freed by the caller.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetSchedulerParameters' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the scheduler parameters, the @params array will be filled with the
values.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virSchedParameterPtr' info='pointer to scheduler parameter object (return value)'/>
      <arg name='nparams' type='int *' info='pointer to number of scheduler parameter (this value should be same than the returned value nparams of virDomainGetSchedulerType)'/>
    </function>
    <function name='virDomainGetSchedulerType' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the scheduler type.]]></info>
      <return type='char *' info='NULL in case of error. The caller must free the returned string.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='nparams' type='int *' info='number of scheduler parameters(return value)'/>
    </function>
    <function name='virDomainGetSecurityLabel' file='libvirt' module='libvirt'>
      <info><![CDATA[Extract security label of an active domain. The 'label' field
in the @seclabel argument will be initialized to the empty
string if the domain is not running under a security model.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='seclabel' type='virSecurityLabelPtr' info='pointer to a virSecurityLabel structure'/>
    </function>
    <function name='virDomainGetUUID' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the UUID for a domain]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virDomainGetUUIDString' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the UUID for a domain as string. For more information about
UUID see RFC4122.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virDomainGetVcpus' file='libvirt' module='libvirt'>
      <info><![CDATA[Extract information about virtual CPUs of domain, store it in info array
and also in cpumaps if this pointer isn't NULL.]]></info>
      <return type='int' info='the number of info filled in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='info' type='virVcpuInfoPtr' info='pointer to an array of virVcpuInfo structures (OUT)'/>
      <arg name='maxinfo' type='int' info='number of structures in info array'/>
      <arg name='cpumaps' type='unsigned char *' info='pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) If cpumaps is NULL, then no cpumap information is returned by the API. It&apos;s assumed there is &lt;maxinfo&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (maxinfo * maplen) bytes (ie: calloc(maxinfo, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API.'/>
      <arg name='maplen' type='int' info='number of bytes in one cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). Must be zero when cpumaps is NULL and positive when it is non-NULL.'/>
    </function>
    <function name='virDomainGetVcpusFlags' file='libvirt' module='libvirt'>
      <info><![CDATA[Query the number of virtual CPUs used by the domain.  Note that
this call may fail if the underlying virtualization hypervisor does
not support it.  This function requires privileged access to the
hypervisor.

@flags must include either VIR_DOMAIN_VCPU_ACTIVE to query a
running domain (which will fail if domain is not active), or
VIR_DOMAIN_VCPU_PERSISTENT to query the XML description of the
domain.  It is an error to set both flags.

If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then the maximum
virtual CPU limit is queried.  Otherwise, this call queries the
current virtual CPU limit.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='flags' type='unsigned int' info='an OR&apos;ed set of virDomainVcpuFlags'/>
    </function>
    <function name='virDomainGetXMLDesc' file='libvirt' module='libvirt'>
      <info><![CDATA[Provide an XML description of the domain. The description may be reused
later to relaunch the domain with virDomainCreateXML().]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='int' info='an OR&apos;ed set of virDomainXMLFlags'/>
    </function>
    <function name='virDomainHasCurrentSnapshot' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the domain has a current snapshot.]]></info>
      <return type='int' info='1 if such snapshot exists, 0 if it doesn&apos;t, -1 on error.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='flags' type='unsigned int' info='unused flag parameters; callers should pass 0'/>
    </function>
    <function name='virDomainHasManagedSaveImage' file='libvirt' module='libvirt'>
      <info><![CDATA[Check if a domain has a managed save image as created by
virDomainManagedSave(). Note that any running domain should not have
such an image, as it should have been removed on restart.]]></info>
      <return type='int' info='0 if no image is present, 1 if an image is present, and -1 in case of error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain'/>
      <arg name='flags' type='unsigned int' info='optional flags currently unused'/>
    </function>
    <function name='virDomainInterfaceStats' file='libvirt' module='libvirt'>
      <info><![CDATA[This function returns network interface stats for interfaces
attached to the domain.

The path parameter is the name of the network interface.

Domains may have more than one network interface.  To get stats for
each you should make multiple calls to this function.

Individual fields within the stats structure may be returned
as -1, which indicates that the hypervisor does not support
that particular statistic.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='path' type='const char *' info='path to the interface'/>
      <arg name='stats' type='virDomainInterfaceStatsPtr' info='network interface stats (returned)'/>
      <arg name='size' type='size_t' info='size of stats structure'/>
    </function>
    <function name='virDomainIsActive' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the domain is currently running]]></info>
      <return type='int' info='1 if running, 0 if inactive, -1 on error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
    </function>
    <function name='virDomainIsPersistent' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the domain has a persistent configuration
which means it will still exist after shutting down]]></info>
      <return type='int' info='1 if persistent, 0 if transient, -1 on error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
    </function>
    <function name='virDomainIsUpdated' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the domain has been updated.]]></info>
      <return type='int' info='1 if updated, 0 if not, -1 on error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
    </function>
    <function name='virDomainLookupByID' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to find a domain based on the hypervisor ID number
Note that this won't work for inactive domains which have an ID of -1,
in that case a lookup based on the Name or UUId need to be done instead.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='id' type='int' info='the domain ID number'/>
    </function>
    <function name='virDomainLookupByName' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a domain on the given hypervisor based on its name.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the domain'/>
    </function>
    <function name='virDomainLookupByUUID' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a domain on the given hypervisor based on its UUID.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the domain'/>
    </function>
    <function name='virDomainLookupByUUIDString' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a domain on the given hypervisor based on its UUID.]]></info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the domain'/>
    </function>
    <function name='virDomainManagedSave' file='libvirt' module='libvirt'>
      <info><![CDATA[This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore.
The difference from virDomainSave() is that libvirt is keeping track of
the saved state itself, and will reuse it once the domain is being
restarted (automatically or via an explicit libvirt call).
As a result any running domain is sure to not have a managed saved image.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain'/>
      <arg name='flags' type='unsigned int' info='optional flags currently unused'/>
    </function>
    <function name='virDomainManagedSaveRemove' file='libvirt' module='libvirt'>
      <info><![CDATA[Remove any managed save image for this domain.]]></info>
      <return type='int' info='0 in case of success, and -1 in case of error'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain'/>
      <arg name='flags' type='unsigned int' info='optional flags currently unused'/>
    </function>
    <function name='virDomainMemoryPeek' file='libvirt' module='libvirt'>
      <info><![CDATA[This function allows you to read the contents of a domain's
memory.

The memory which is read is controlled by the 'start', 'size'
and 'flags' parameters.

If 'flags' is VIR_MEMORY_VIRTUAL then the 'start' and 'size'
parameters are interpreted as virtual memory addresses for
whichever task happens to be running on the domain at the
moment.  Although this sounds haphazard it is in fact what
you want in order to read Linux kernel state, because it
ensures that pointers in the kernel image can be interpreted
coherently.

'buffer' is the return buffer and must be at least 'size' bytes.
'size' may be 0 to test if the call would succeed.

NB. The remote driver imposes a 64K byte limit on 'size'.
For your program to be able to work reliably over a remote
connection you should split large requests to <= 65536 bytes.]]></info>
      <return type='int' info='0 in case of success or -1 in case of failure. really 64 bits'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='start' type='unsigned long long' info='start of memory to peek'/>
      <arg name='size' type='size_t' info='size of memory to peek'/>
      <arg name='buffer' type='void *' info='return buffer (must be at least size bytes)'/>
      <arg name='flags' type='unsigned int' info='flags, see below'/>
    </function>
    <function name='virDomainMemoryStats' file='libvirt' module='libvirt'>
      <info><![CDATA[This function provides memory statistics for the domain.

Up to 'nr_stats' elements of 'stats' will be populated with memory statistics
from the domain.  Only statistics supported by the domain, the driver, and
this version of libvirt will be returned.

Memory Statistics:

VIR_DOMAIN_MEMORY_STAT_SWAP_IN:
    The total amount of data read from swap space (in kb).
VIR_DOMAIN_MEMORY_STAT_SWAP_OUT:
    The total amount of memory written out to swap space (in kb).
VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT:
    The number of page faults that required disk IO to service.
VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT:
    The number of page faults serviced without disk IO.
VIR_DOMAIN_MEMORY_STAT_UNUSED:
    The amount of memory which is not being used for any purpose (in kb).
VIR_DOMAIN_MEMORY_STAT_AVAILABLE:
    The total amount of memory available to the domain's OS (in kb).]]></info>
      <return type='int' info='The number of stats provided or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='stats' type='virDomainMemoryStatPtr' info='nr_stats-sized array of stat structures (returned)'/>
      <arg name='nr_stats' type='unsigned int' info='number of memory statistics requested'/>
      <arg name='flags' type='unsigned int' info='unused, always pass 0'/>
    </function>
    <function name='virDomainMigrate' file='libvirt' module='libvirt'>
      <info><![CDATA[Migrate the domain object from its current host to the destination
host given by dconn (a connection to the destination host).

Flags may be one of more of the following:
  VIR_MIGRATE_LIVE      Do not pause the VM during migration
  VIR_MIGRATE_PEER2PEER Direct connection between source & destination hosts
  VIR_MIGRATE_TUNNELLED Tunnel migration data over the libvirt RPC channel
  VIR_MIGRATE_PERSIST_DEST If the migration is successful, persist the domain
                           on the destination host.
  VIR_MIGRATE_UNDEFINE_SOURCE If the migration is successful, undefine the
                              domain on the source host.
  VIR_MIGRATE_PAUSED    Leave the domain suspended on the remote side.

VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.
Applications using the VIR_MIGRATE_PEER2PEER flag will probably
prefer to invoke virDomainMigrateToURI, avoiding the need to
open connection to the destination host themselves.

If a hypervisor supports renaming domains during migration,
then you may set the dname parameter to the new name (otherwise
it keeps the same name).  If this is not supported by the
hypervisor, dname must be NULL or else you will get an error.

If the VIR_MIGRATE_PEER2PEER flag is set, the uri parameter
must be a valid libvirt connection URI, by which the source
libvirt driver can connect to the destination libvirt. If
omitted, the dconn connection object will be queried for its
current URI.

If the VIR_MIGRATE_PEER2PEER flag is NOT set, the URI parameter
takes a hypervisor specific format. The hypervisor capabilities
XML includes details of the support URI schemes. If omitted
the dconn will be asked for a default URI.

In either case it is typically only necessary to specify a
URI if the destination host has multiple interfaces and a
specific interface is required to transmit migration data.

The maximum bandwidth (in Mbps) that will be used to do migration
can be specified with the bandwidth parameter.  If set to 0,
libvirt will choose a suitable default.  Some hypervisors do
not support this feature and will return an error if bandwidth
is not 0.

To see which features are supported by the current hypervisor,
see virConnectGetCapabilities, /capabilities/host/migration_features.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.]]></info>
      <return type='virDomainPtr' info='the new domain object if the migration was successful, or NULL in case of error.  Note that the new domain object exists in the scope of the destination connection (dconn).'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='dconn' type='virConnectPtr' info='destination host (a connection object)'/>
      <arg name='flags' type='unsigned long' info='flags'/>
      <arg name='dname' type='const char *' info='(optional) rename domain to this at destination'/>
      <arg name='uri' type='const char *' info='(optional) dest hostname/URI as seen from the source host'/>
      <arg name='bandwidth' type='unsigned long' info='(optional) specify migration bandwidth limit in Mbps'/>
    </function>
    <function name='virDomainMigrateSetMaxDowntime' file='libvirt' module='libvirt'>
      <info><![CDATA[Sets maximum tolerable time for which the domain is allowed to be paused
at the end of live migration. It's supposed to be called while the domain is
being live-migrated as a reaction to migration progress.]]></info>
      <return type='int' info='0 in case of success, -1 otherwise.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='downtime' type='unsigned long long' info='maximum tolerable downtime for live migration, in milliseconds'/>
      <arg name='flags' type='unsigned int' info='fine-tuning flags, currently unused, use 0'/>
    </function>
    <function name='virDomainMigrateToURI' file='libvirt' module='libvirt'>
      <info><![CDATA[Migrate the domain object from its current host to the destination
host given by duri.

Flags may be one of more of the following:
  VIR_MIGRATE_LIVE      Do not pause the VM during migration
  VIR_MIGRATE_PEER2PEER Direct connection between source & destination hosts
  VIR_MIGRATE_TUNNELLED Tunnel migration data over the libvirt RPC channel
  VIR_MIGRATE_PERSIST_DEST If the migration is successful, persist the domain
                           on the destination host.
  VIR_MIGRATE_UNDEFINE_SOURCE If the migration is successful, undefine the
                              domain on the source host.

The operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.
If the VIR_MIGRATE_PEER2PEER flag is NOT set, the duri parameter
takes a hypervisor specific format. The uri_transports element of the
hypervisor capabilities XML includes details of the supported URI
schemes. Not all hypervisors will support this mode of migration, so
if the VIR_MIGRATE_PEER2PEER flag is not set, then it may be necessary
to use the alternative virDomainMigrate API providing and explicit
virConnectPtr for the destination host.

If the VIR_MIGRATE_PEER2PEER flag IS set, the duri parameter
must be a valid libvirt connection URI, by which the source
libvirt driver can connect to the destination libvirt.

VIR_MIGRATE_TUNNELLED requires that VIR_MIGRATE_PEER2PEER be set.

If a hypervisor supports renaming domains during migration,
the dname parameter specifies the new name for the domain.
Setting dname to NULL keeps the domain name the same.  If domain
renaming is not supported by the hypervisor, dname must be NULL or
else an error will be returned.

The maximum bandwidth (in Mbps) that will be used to do migration
can be specified with the bandwidth parameter.  If set to 0,
libvirt will choose a suitable default.  Some hypervisors do
not support this feature and will return an error if bandwidth
is not 0.

To see which features are supported by the current hypervisor,
see virConnectGetCapabilities, /capabilities/host/migration_features.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.]]></info>
      <return type='int' info='0 if the migration succeeded, -1 upon error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='duri' type='const char *' info='mandatory URI for the destination host'/>
      <arg name='flags' type='unsigned long' info='flags'/>
      <arg name='dname' type='const char *' info='(optional) rename domain to this at destination'/>
      <arg name='bandwidth' type='unsigned long' info='(optional) specify migration bandwidth limit in Mbps'/>
    </function>
    <function name='virDomainOpenConsole' file='libvirt' module='libvirt'>
      <info><![CDATA[This opens the backend associated with a console, serial or
parallel port device on a guest, if the backend is supported.
If the @devname is omitted, then the first console or serial
device is opened. The console is associated with the passed
in @st stream, which should have been opened in non-blocking
mode for bi-directional I/O.]]></info>
      <return type='int' info='0 if the console was opened, -1 on error'/>
      <arg name='dom' type='virDomainPtr' info='a domain object'/>
      <arg name='devname' type='const char *' info='the console, serial or parallel port device alias, or NULL'/>
      <arg name='st' type='virStreamPtr' info='a stream to associate with the console'/>
      <arg name='flags' type='unsigned int' info='unused, pass 0'/>
    </function>
    <function name='virDomainPinVcpu' file='libvirt' module='libvirt'>
      <info><![CDATA[Dynamically change the real CPUs which can be allocated to a virtual CPU.
This function requires privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='vcpu' type='unsigned int' info='virtual CPU number'/>
      <arg name='cpumap' type='unsigned char *' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.'/>
      <arg name='maplen' type='int' info='number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.'/>
    </function>
    <function name='virDomainReboot' file='libvirt' module='libvirt'>
      <info><![CDATA[Reboot a domain, the domain object is still usable there after but
the domain OS is being stopped for a restart.
Note that the guest OS may ignore the request.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='extra flags for the reboot operation, not used yet'/>
    </function>
    <function name='virDomainRef' file='libvirt' module='libvirt'>
      <info><![CDATA[Increment the reference count on the domain. For each
additional call to this method, there shall be a corresponding
call to virDomainFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a domain would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='the domain to hold a reference on'/>
    </function>
    <function name='virDomainRestore' file='libvirt' module='libvirt'>
      <info><![CDATA[This method will restore a domain saved to disk by virDomainSave().]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='from' type='const char *' info='path to the'/>
    </function>
    <function name='virDomainResume' file='libvirt' module='libvirt'>
      <info><![CDATA[Resume a suspended domain, the process is restarted from the state where
it was frozen by calling virSuspendDomain().
This function may requires privileged access]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainRevertToSnapshot' file='libvirt' module='libvirt'>
      <info><![CDATA[Revert the domain to a given snapshot.]]></info>
      <return type='int' info='0 if the creation is successful, -1 on error.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
      <arg name='flags' type='unsigned int' info='unused flag parameters; callers should pass 0'/>
    </function>
    <function name='virDomainSave' file='libvirt' module='libvirt'>
      <info><![CDATA[This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore (this may be a problem).
Use virDomainRestore() to restore a domain after saving.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the output file'/>
    </function>
    <function name='virDomainSetAutostart' file='libvirt' module='libvirt'>
      <info><![CDATA[Configure the domain to be automatically started
when the host machine boots.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='autostart' type='int' info='whether the domain should be automatically started 0 or 1'/>
    </function>
    <function name='virDomainSetMaxMemory' file='libvirt' module='libvirt'>
      <info><![CDATA[Dynamically change the maximum amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function requires privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kilobytes'/>
    </function>
    <function name='virDomainSetMemory' file='libvirt' module='libvirt'>
      <info><![CDATA[Dynamically change the target amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may requires privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kilobytes'/>
    </function>
    <function name='virDomainSetMemoryParameters' file='libvirt' module='libvirt'>
      <info><![CDATA[Change the memory tunables
This function requires privileged access to the hypervisor.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virMemoryParameterPtr' info='pointer to memory parameter objects'/>
      <arg name='nparams' type='int' info='number of memory parameter (this value should be same or less than the number of parameters supported)'/>
      <arg name='flags' type='unsigned int' info='currently unused, for future extension'/>
    </function>
    <function name='virDomainSetSchedulerParameters' file='libvirt' module='libvirt'>
      <info><![CDATA[Change the scheduler parameters]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virSchedParameterPtr' info='pointer to scheduler parameter objects'/>
      <arg name='nparams' type='int' info='number of scheduler parameter (this value should be same or less than the returned value nparams of virDomainGetSchedulerType)'/>
    </function>
    <function name='virDomainSetVcpus' file='libvirt' module='libvirt'>
      <info><![CDATA[Dynamically change the number of virtual CPUs used by the domain.
Note that this call may fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrary limited.
This function requires privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.  It is hypervisor-dependent
whether it also affects persistent configuration; for more control,
use virDomainSetVcpusFlags().]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='nvcpus' type='unsigned int' info='the new number of virtual CPUs for this domain'/>
    </function>
    <function name='virDomainSetVcpusFlags' file='libvirt' module='libvirt'>
      <info><![CDATA[Dynamically change the number of virtual CPUs used by the domain.
Note that this call may fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrary limited.
This function requires privileged access to the hypervisor.

@flags must include VIR_DOMAIN_VCPU_LIVE to affect a running
domain (which may fail if domain is not active), or
VIR_DOMAIN_VCPU_CONFIG to affect the next boot via the XML
description of the domain.  Both flags may be set.

If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then
VIR_DOMAIN_VCPU_LIVE must be clear, and only the maximum virtual
CPU limit is altered; generally, this value must be less than or
equal to virConnectGetMaxVcpus().  Otherwise, this call affects the
current virtual CPU limit, which must be less than or equal to the
maximum limit.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='nvcpus' type='unsigned int' info='the new number of virtual CPUs for this domain, must be at least 1'/>
      <arg name='flags' type='unsigned int' info='an OR&apos;ed set of virDomainVcpuFlags'/>
    </function>
    <function name='virDomainShutdown' file='libvirt' module='libvirt'>
      <info><![CDATA[Shutdown a domain, the domain object is still usable there after but
the domain OS is being stopped. Note that the guest OS may ignore the
request.

TODO: should we add an option for reboot, knowing it may not be doable
      in the general case ?]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainSnapshotCreateXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Creates a new snapshot of a domain based on the snapshot xml
contained in xmlDesc.]]></info>
      <return type='virDomainSnapshotPtr' info='an (opaque) virDomainSnapshotPtr on success, NULL on failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the domain'/>
      <arg name='flags' type='unsigned int' info='unused flag parameters; callers should pass 0'/>
    </function>
    <function name='virDomainSnapshotCurrent' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the current snapshot for a domain, if any.]]></info>
      <return type='virDomainSnapshotPtr' info='a domain snapshot object or NULL in case of failure.  If the current domain snapshot cannot be found, then the VIR_ERR_NO_DOMAIN_SNAPSHOT error is raised.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='unused flag parameters; callers should pass 0'/>
    </function>
    <function name='virDomainSnapshotDelete' file='libvirt' module='libvirt'>
      <info><![CDATA[Delete the snapshot.

If @flags is 0, then just this snapshot is deleted, and changes from
this snapshot are automatically merged into children snapshots.  If
flags is VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN, then this snapshot
and any children snapshots are deleted.]]></info>
      <return type='int' info='0 if the snapshot was successfully deleted, -1 on error.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
      <arg name='flags' type='unsigned int' info='flag parameters'/>
    </function>
    <function name='virDomainSnapshotFree' file='libvirt' module='libvirt'>
      <info><![CDATA[Free the domain snapshot object.  The snapshot itself is not modified.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
    </function>
    <function name='virDomainSnapshotGetXMLDesc' file='libvirt' module='libvirt'>
      <info><![CDATA[Provide an XML description of the domain snapshot.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='snapshot' type='virDomainSnapshotPtr' info='a domain snapshot object'/>
      <arg name='flags' type='unsigned int' info='unused flag parameters; callers should pass 0'/>
    </function>
    <function name='virDomainSnapshotListNames' file='libvirt' module='libvirt'>
      <info><![CDATA[Collect the list of domain snapshots for the given domain, and store
their names in @names.  Caller is responsible for freeing each member
of the array.]]></info>
      <return type='int' info='the number of domain snapshots found or -1 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='names' type='char **' info='array to collect the list of names of snapshots'/>
      <arg name='nameslen' type='int' info='size of @names'/>
      <arg name='flags' type='unsigned int' info='unused flag parameters; callers should pass 0'/>
    </function>
    <function name='virDomainSnapshotLookupByName' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a domain snapshot based on its name.]]></info>
      <return type='virDomainSnapshotPtr' info='a domain snapshot object or NULL in case of failure.  If the domain snapshot cannot be found, then the VIR_ERR_NO_DOMAIN_SNAPSHOT error is raised.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='name' type='const char *' info='name for the domain snapshot'/>
      <arg name='flags' type='unsigned int' info='unused flag parameters; callers should pass 0'/>
    </function>
    <function name='virDomainSnapshotNum' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of domain snapshots for this domain..]]></info>
      <return type='int' info='the number of domain snapshost found or -1 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='unused flag parameters; callers should pass 0'/>
    </function>
    <function name='virDomainSuspend' file='libvirt' module='libvirt'>
      <info><![CDATA[Suspends an active domain, the process is frozen without further access
to CPU resources and I/O but the memory used by the domain at the
hypervisor level will stay allocated. Use virDomainResume() to reactivate
the domain.
This function may requires privileged access.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainUndefine' file='libvirt' module='libvirt'>
      <info><![CDATA[Undefine a domain but does not stop it if it is running]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
    </function>
    <function name='virDomainUpdateDeviceFlags' file='libvirt' module='libvirt'>
      <info><![CDATA[Change a virtual device on a domain, using the flags parameter
to control how the device is changed.  VIR_DOMAIN_DEVICE_MODIFY_CURRENT
specifies that the device change is made based on current domain
state.  VIR_DOMAIN_DEVICE_MODIFY_LIVE specifies that the device shall be
changed on the active domain instance only and is not added to the
persisted domain configuration. VIR_DOMAIN_DEVICE_MODIFY_CONFIG
specifies that the device shall be changed on the persisted domain
configuration only.  Note that the target hypervisor must return an
error if unable to satisfy flags.  E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports modifying the
persisted device allocation.

This method is used for actions such changing CDROM/Floppy device
media, altering the graphics configuration such as password,
reconfiguring the NIC device backend connectivity, etc.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
      <arg name='flags' type='unsigned int' info='an OR&apos;ed set of virDomainDeviceModifyFlags'/>
    </function>
    <functype name='virErrorFunc' file='virterror' module='virterror'>
      <info><![CDATA[Signature of a function to use when there is an error raised by the library.]]></info>
      <return type='void'/>
      <arg name='userData' type='void *' info='user provided data for the error callback'/>
      <arg name='error' type='virErrorPtr' info='the error being raised.'/>
    </functype>
    <functype name='virEventAddHandleFunc' file='libvirt' module='libvirt'>
      <info><![CDATA[Part of the EventImpl, this callback Adds a file handle callback to
listen for specific events. The same file handle can be registered
multiple times provided the requested event sets are non-overlapping

If the opaque user data requires free'ing when the handle
is unregistered, then a 2nd callback can be supplied for
this purpose.]]></info>
      <return type='int' info='a handle watch number to be used for updating and unregistering for events'/>
      <arg name='fd' type='int' info='file descriptor to listen on'/>
      <arg name='event' type='int' info='bitset of events on which to fire the callback'/>
      <arg name='cb' type='virEventHandleCallback' info='the callback to be called when an event occurrs'/>
      <arg name='opaque' type='void *' info='user data to pass to the callback'/>
      <arg name='ff' type='virFreeCallback' info='the callback invoked to free opaque data blob'/>
    </functype>
    <functype name='virEventAddTimeoutFunc' file='libvirt' module='libvirt'>
      <info><![CDATA[Part of the EventImpl, this user-defined callback handles adding an
event timeout.

If the opaque user data requires free'ing when the handle
is unregistered, then a 2nd callback can be supplied for
this purpose.]]></info>
      <return type='int' info='a timer value'/>
      <arg name='timeout' type='int' info='The timeout to monitor'/>
      <arg name='cb' type='virEventTimeoutCallback' info='the callback to call when timeout has expired'/>
      <arg name='opaque' type='void *' info='user data to pass to the callback'/>
      <arg name='ff' type='virFreeCallback' info='the callback invoked to free opaque data blob'/>
    </functype>
    <functype name='virEventHandleCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[Callback for receiving file handle events. The callback will
be invoked once for each event which is pending.]]></info>
      <return type='void'/>
      <arg name='watch' type='int' info='watch on which the event occurred'/>
      <arg name='fd' type='int' info='file handle on which the event occurred'/>
      <arg name='events' type='int' info='bitset of events from virEventHandleType constants'/>
      <arg name='opaque' type='void *' info='user data registered with handle'/>
    </functype>
    <function name='virEventRegisterImpl' file='libvirt' module='event'>
      <info><![CDATA[Registers an event implementation]]></info>
      <return type='void'/>
      <arg name='addHandle' type='virEventAddHandleFunc' info='the callback to add fd handles'/>
      <arg name='updateHandle' type='virEventUpdateHandleFunc' info='the callback to update fd handles'/>
      <arg name='removeHandle' type='virEventRemoveHandleFunc' info='the callback to remove fd handles'/>
      <arg name='addTimeout' type='virEventAddTimeoutFunc' info='the callback to add a timeout'/>
      <arg name='updateTimeout' type='virEventUpdateTimeoutFunc' info='the callback to update a timeout'/>
      <arg name='removeTimeout' type='virEventRemoveTimeoutFunc' info='the callback to remove a timeout'/>
    </function>
    <functype name='virEventRemoveHandleFunc' file='libvirt' module='libvirt'>
      <info><![CDATA[Part of the EventImpl, this user-provided callback is notified when
an fd is no longer being listened on.

If a virEventHandleFreeFunc was supplied when the handle was
registered, it will be invoked some time during, or after this
function call, when it is safe to release the user data.]]></info>
      <return type='int' info=''/>
      <arg name='watch' type='int' info='file descriptor watch to stop listening on'/>
    </functype>
    <functype name='virEventRemoveTimeoutFunc' file='libvirt' module='libvirt'>
      <info><![CDATA[Part of the EventImpl, this user-defined callback removes a timer

If a virEventTimeoutFreeFunc was supplied when the handle was
registered, it will be invoked some time during, or after this
function call, when it is safe to release the user data.]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='timer' type='int' info='the timer to remove'/>
    </functype>
    <functype name='virEventTimeoutCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[callback for receiving timer events]]></info>
      <return type='void'/>
      <arg name='timer' type='int' info='timer id emitting the event'/>
      <arg name='opaque' type='void *' info='user data registered with handle'/>
    </functype>
    <functype name='virEventUpdateHandleFunc' file='libvirt' module='libvirt'>
      <info><![CDATA[Part of the EventImpl, this user-provided callback is notified when
events to listen on change]]></info>
      <return type='void'/>
      <arg name='watch' type='int' info='file descriptor watch to modify'/>
      <arg name='event' type='int' info='new events to listen on'/>
    </functype>
    <functype name='virEventUpdateTimeoutFunc' file='libvirt' module='libvirt'>
      <info><![CDATA[Part of the EventImpl, this user-defined callback updates an
event timeout.]]></info>
      <return type='void'/>
      <arg name='timer' type='int' info='the timer to modify'/>
      <arg name='timeout' type='int' info='the new timeout value'/>
    </functype>
    <functype name='virFreeCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[Type for a domain event callback when the event is deregistered and
need to be freed, @opaque is provided along with the callback at
registration time]]></info>
      <return type='void'/>
      <arg name='opaque' type='void *' info='opaque user data provided at registration'/>
    </functype>
    <function name='virFreeError' file='virterror' module='virterror'>
      <info><![CDATA[Resets and frees the given error.]]></info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='error to free'/>
    </function>
    <function name='virGetLastError' file='virterror' module='virterror'>
      <info><![CDATA[Provide a pointer to the last error caught at the library level

The error object is kept in thread local storage, so separate
threads can safely access this concurrently.]]></info>
      <return type='virErrorPtr' info='a pointer to the last error or NULL if none occurred.'/>
    </function>
    <function name='virGetVersion' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides two information back, @libVer is the version of the library
while @typeVer will be the version of the hypervisor type @type against
which the library was compiled. If @type is NULL, "Xen" is assumed, if
@type is unknown or not available, an error code will be returned and
@typeVer will be 0.]]></info>
      <return type='int' info='-1 in case of failure, 0 otherwise, and values for @libVer and @typeVer have the format major * 1,000,000 + minor * 1,000 + release.'/>
      <arg name='libVer' type='unsigned long *' info='return value for the library version (OUT)'/>
      <arg name='type' type='const char *' info='the type of connection/driver looked at'/>
      <arg name='typeVer' type='unsigned long *' info='return value for the version of the hypervisor (OUT)'/>
    </function>
    <function name='virInitialize' file='libvirt' module='libvirt'>
      <info><![CDATA[Initialize the library. It's better to call this routine at startup
in multithreaded applications to avoid potential race when initializing
the library.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
    </function>
    <function name='virInterfaceCreate' file='libvirt' module='libvirt'>
      <info><![CDATA[Activate an interface (ie call "ifup")]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='iface' type='virInterfacePtr' info='pointer to a defined interface'/>
      <arg name='flags' type='unsigned int' info='and OR&apos;ed set of extraction flags, not used yet'/>
    </function>
    <function name='virInterfaceDefineXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Define an interface (or modify existing interface configuration)]]></info>
      <return type='virInterfacePtr' info='NULL in case of error, a pointer to the interface otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the interface, preferably in UTF-8'/>
      <arg name='flags' type='unsigned int' info='and OR&apos;ed set of extraction flags, not used yet'/>
    </function>
    <function name='virInterfaceDestroy' file='libvirt' module='libvirt'>
      <info><![CDATA[deactivate an interface (ie call "ifdown")
This does not remove the interface from the config, and
does not free the associated virInterfacePtr object.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='iface' type='virInterfacePtr' info='an interface object'/>
      <arg name='flags' type='unsigned int' info='and OR&apos;ed set of extraction flags, not used yet'/>
    </function>
    <function name='virInterfaceFree' file='libvirt' module='libvirt'>
      <info><![CDATA[Free the interface object. The interface itself is unaltered.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='iface' type='virInterfacePtr' info='an interface object'/>
    </function>
    <function name='virInterfaceGetConnect' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the connection pointer associated with an interface.  The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function.  Instead, store the connection and
the interface object together.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='iface' type='virInterfacePtr' info='pointer to an interface'/>
    </function>
    <function name='virInterfaceGetMACString' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the MAC for an interface as string. For more information about
MAC see RFC4122.]]></info>
      <return type='const char *' info='a pointer to the MAC address (in null-terminated ASCII format) or NULL, the string need not be deallocated its lifetime will be the same as the interface object.'/>
      <arg name='iface' type='virInterfacePtr' info='an interface object'/>
    </function>
    <function name='virInterfaceGetName' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the public name for that interface]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the interface object.'/>
      <arg name='iface' type='virInterfacePtr' info='an interface object'/>
    </function>
    <function name='virInterfaceGetXMLDesc' file='libvirt' module='libvirt'>
      <info><![CDATA[VIR_INTERFACE_XML_INACTIVE - return the static configuration,
                                  suitable for use redefining the
                                  interface via virInterfaceDefineXML()

Provide an XML description of the interface. If
VIR_INTERFACE_XML_INACTIVE is set, the description may be reused
later to redefine the interface with virInterfaceDefineXML(). If it
is not set, the ip address and netmask will be the current live
setting of the interface, not the settings from the config files.]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='iface' type='virInterfacePtr' info='an interface object'/>
      <arg name='flags' type='unsigned int' info='an OR&apos;ed set of extraction flags. Current valid bits:'/>
    </function>
    <function name='virInterfaceIsActive' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the interface is currently running]]></info>
      <return type='int' info='1 if running, 0 if inactive, -1 on error'/>
      <arg name='iface' type='virInterfacePtr' info='pointer to the interface object'/>
    </function>
    <function name='virInterfaceLookupByMACString' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup an interface on the given hypervisor based on its MAC.]]></info>
      <return type='virInterfacePtr' info='a new interface object or NULL in case of failure.  If the interface cannot be found, then VIR_ERR_NO_INTERFACE error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='macstr' type='const char *' info='the MAC for the interface (null-terminated ASCII format)'/>
    </function>
    <function name='virInterfaceLookupByName' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup an interface on the given hypervisor based on its name.]]></info>
      <return type='virInterfacePtr' info='a new interface object or NULL in case of failure.  If the interface cannot be found, then VIR_ERR_NO_INTERFACE error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the interface'/>
    </function>
    <function name='virInterfaceRef' file='libvirt' module='libvirt'>
      <info><![CDATA[Increment the reference count on the interface. For each
additional call to this method, there shall be a corresponding
call to virInterfaceFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using an interface would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='iface' type='virInterfacePtr' info='the interface to hold a reference on'/>
    </function>
    <function name='virInterfaceUndefine' file='libvirt' module='libvirt'>
      <info><![CDATA[Undefine an interface, ie remove it from the config.
This does not free the associated virInterfacePtr object.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='iface' type='virInterfacePtr' info='pointer to a defined interface'/>
    </function>
    <function name='virNWFilterDefineXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Define a new network filter, based on an XML description
similar to the one returned by virNWFilterGetXMLDesc()]]></info>
      <return type='virNWFilterPtr' info='a new nwfilter object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='an XML description of the nwfilter'/>
    </function>
    <function name='virNWFilterFree' file='libvirt' module='libvirt'>
      <info><![CDATA[Free the nwfilter object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
    </function>
    <function name='virNWFilterGetName' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the public name for the network filter]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the nwfilter object.'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
    </function>
    <function name='virNWFilterGetUUID' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the UUID for a network filter]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virNWFilterGetUUIDString' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the UUID for a network filter as string. For more information about
UUID see RFC4122.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virNWFilterGetXMLDesc' file='libvirt' module='libvirt'>
      <info><![CDATA[Provide an XML description of the network filter. The description may be
reused later to redefine the network filter with virNWFilterCreateXML().]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
      <arg name='flags' type='int' info='an OR&apos;ed set of extraction flags, not used yet'/>
    </function>
    <function name='virNWFilterLookupByName' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a network filter on the given hypervisor based on its name.]]></info>
      <return type='virNWFilterPtr' info='a new nwfilter object or NULL in case of failure.  If the network filter cannot be found, then VIR_ERR_NO_NWFILTER error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the network filter'/>
    </function>
    <function name='virNWFilterLookupByUUID' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a network filter on the given hypervisor based on its UUID.]]></info>
      <return type='virNWFilterPtr' info='a new nwfilter object or NULL in case of failure.  If the nwfdilter cannot be found, then VIR_ERR_NO_NWFILTER error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the network filter'/>
    </function>
    <function name='virNWFilterLookupByUUIDString' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup an nwfilter on the given hypervisor based on its UUID.]]></info>
      <return type='virNWFilterPtr' info='a new nwfilter object or NULL in case of failure.  If the nwfilter cannot be found, then VIR_ERR_NO_NWFILTER error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the nwfilter'/>
    </function>
    <function name='virNWFilterRef' file='libvirt' module='libvirt'>
      <info><![CDATA[Increment the reference count on the nwfilter. For each
additional call to this method, there shall be a corresponding
call to virNWFilterFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using an nwfilter would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='the nwfilter to hold a reference on'/>
    </function>
    <function name='virNWFilterUndefine' file='libvirt' module='libvirt'>
      <info><![CDATA[Undefine the nwfilter object. This call will not succeed if
a running VM is referencing the filter. This does not free the
associated virNWFilterPtr object.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='nwfilter' type='virNWFilterPtr' info='a nwfilter object'/>
    </function>
    <function name='virNetworkCreate' file='libvirt' module='libvirt'>
      <info><![CDATA[Create and start a defined network. If the call succeed the network
moves from the defined to the running networks pools.]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='network' type='virNetworkPtr' info='pointer to a defined network'/>
    </function>
    <function name='virNetworkCreateXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Create and start a new virtual network, based on an XML description
similar to the one returned by virNetworkGetXMLDesc()]]></info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='an XML description of the network'/>
    </function>
    <function name='virNetworkDefineXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Define a network, but does not create it]]></info>
      <return type='virNetworkPtr' info='NULL in case of error, a pointer to the network otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the network, preferably in UTF-8'/>
    </function>
    <function name='virNetworkDestroy' file='libvirt' module='libvirt'>
      <info><![CDATA[Destroy the network object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor. This
does not free the associated virNetworkPtr object.
This function may require privileged access]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkFree' file='libvirt' module='libvirt'>
      <info><![CDATA[Free the network object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetAutostart' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides a boolean value indicating whether the network
configured to be automatically started when the host
machine boots.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='autostart' type='int *' info='the value returned'/>
    </function>
    <function name='virNetworkGetBridgeName' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides a bridge interface name to which a domain may connect
a network interface in order to join the network.]]></info>
      <return type='char *' info='a 0 terminated interface name, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetConnect' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the connection pointer associated with a network.  The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function.  Instead, store the connection and
the network object together.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='net' type='virNetworkPtr' info='pointer to a network'/>
    </function>
    <function name='virNetworkGetName' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the public name for that network]]></info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the network object.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetUUID' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the UUID for a network]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virNetworkGetUUIDString' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the UUID for a network as string. For more information about
UUID see RFC4122.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virNetworkGetXMLDesc' file='libvirt' module='libvirt'>
      <info><![CDATA[Provide an XML description of the network. The description may be reused
later to relaunch the network with virNetworkCreateXML().]]></info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='flags' type='int' info='an OR&apos;ed set of extraction flags, not used yet'/>
    </function>
    <function name='virNetworkIsActive' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the network is currently running]]></info>
      <return type='int' info='1 if running, 0 if inactive, -1 on error'/>
      <arg name='net' type='virNetworkPtr' info='pointer to the network object'/>
    </function>
    <function name='virNetworkIsPersistent' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the network has a persistent configuration
which means it will still exist after shutting down]]></info>
      <return type='int' info='1 if persistent, 0 if transient, -1 on error'/>
      <arg name='net' type='virNetworkPtr' info='pointer to the network object'/>
    </function>
    <function name='virNetworkLookupByName' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a network on the given hypervisor based on its name.]]></info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the network'/>
    </function>
    <function name='virNetworkLookupByUUID' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a network on the given hypervisor based on its UUID.]]></info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the network'/>
    </function>
    <function name='virNetworkLookupByUUIDString' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a network on the given hypervisor based on its UUID.]]></info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the network'/>
    </function>
    <function name='virNetworkRef' file='libvirt' module='libvirt'>
      <info><![CDATA[Increment the reference count on the network. For each
additional call to this method, there shall be a corresponding
call to virNetworkFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a network would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='network' type='virNetworkPtr' info='the network to hold a reference on'/>
    </function>
    <function name='virNetworkSetAutostart' file='libvirt' module='libvirt'>
      <info><![CDATA[Configure the network to be automatically started
when the host machine boots.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='autostart' type='int' info='whether the network should be automatically started 0 or 1'/>
    </function>
    <function name='virNetworkUndefine' file='libvirt' module='libvirt'>
      <info><![CDATA[Undefine a network but does not stop it if it is running]]></info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='network' type='virNetworkPtr' info='pointer to a defined network'/>
    </function>
    <function name='virNodeDeviceCreateXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Create a new device on the VM host machine, for example, virtual
HBAs created using vport_create.]]></info>
      <return type='virNodeDevicePtr' info='a node device object if successful, NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the device to be created'/>
      <arg name='flags' type='unsigned int' info='callers should always pass 0'/>
    </function>
    <function name='virNodeDeviceDestroy' file='libvirt' module='libvirt'>
      <info><![CDATA[Destroy the device object. The virtual device is removed from the host operating system.
This function may require privileged access]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='a device object'/>
    </function>
    <function name='virNodeDeviceDettach' file='libvirt' module='libvirt'>
      <info><![CDATA[Dettach the node device from the node itself so that it may be
assigned to a guest domain.

Depending on the hypervisor, this may involve operations such
as unbinding any device drivers from the device, binding the
device to a dummy device driver and resetting the device.

If the device is currently in use by the node, this method may
fail.

Once the device is not assigned to any guest, it may be re-attached
to the node using the virNodeDeviceReattach() method.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
    </function>
    <function name='virNodeDeviceFree' file='libvirt' module='libvirt'>
      <info><![CDATA[Drops a reference to the node device, freeing it if
this was the last reference.]]></info>
      <return type='int' info='the 0 for success, -1 for error.'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
    </function>
    <function name='virNodeDeviceGetName' file='libvirt' module='libvirt'>
      <info><![CDATA[Just return the device name]]></info>
      <return type='const char *' info='the device name or NULL in case of error'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
    </function>
    <function name='virNodeDeviceGetParent' file='libvirt' module='libvirt'>
      <info><![CDATA[Accessor for the parent of the device]]></info>
      <return type='const char *' info='the name of the device&apos;s parent, or NULL if the device has no parent.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
    </function>
    <function name='virNodeDeviceGetXMLDesc' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch an XML document describing all aspects of
the device.]]></info>
      <return type='char *' info='the XML document, or NULL on error'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
      <arg name='flags' type='unsigned int' info='flags for XML generation (unused, pass 0)'/>
    </function>
    <function name='virNodeDeviceListCaps' file='libvirt' module='libvirt'>
      <info><![CDATA[Lists the names of the capabilities supported by the device.]]></info>
      <return type='int' info='the number of capability names listed in @names.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
      <arg name='names' type='char ** const' info='array to collect the list of capability names'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virNodeDeviceLookupByName' file='libvirt' module='libvirt'>
      <info><![CDATA[Lookup a node device by its name.]]></info>
      <return type='virNodeDevicePtr' info='a virNodeDevicePtr if found, NULL otherwise.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='unique device name'/>
    </function>
    <function name='virNodeDeviceNumOfCaps' file='libvirt' module='libvirt'>
      <info><![CDATA[Accessor for the number of capabilities supported by the device.]]></info>
      <return type='int' info='the number of capabilities supported by the device.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
    </function>
    <function name='virNodeDeviceReAttach' file='libvirt' module='libvirt'>
      <info><![CDATA[Re-attach a previously dettached node device to the node so that it
may be used by the node again.

Depending on the hypervisor, this may involve operations such
as resetting the device, unbinding it from a dummy device driver
and binding it to its appropriate driver.

If the device is currently in use by a guest, this method may fail.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
    </function>
    <function name='virNodeDeviceRef' file='libvirt' module='libvirt'>
      <info><![CDATA[Increment the reference count on the dev. For each
additional call to this method, there shall be a corresponding
call to virNodeDeviceFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a dev would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the dev to hold a reference on'/>
    </function>
    <function name='virNodeDeviceReset' file='libvirt' module='libvirt'>
      <info><![CDATA[Reset a previously dettached node device to the node before or
after assigning it to a guest.

The exact reset semantics depends on the hypervisor and device
type but, for example, KVM will attempt to reset PCI devices with
a Function Level Reset, Secondary Bus Reset or a Power Management
D-State reset.

If the reset will affect other devices which are currently in use,
this function may fail.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
    </function>
    <function name='virNodeGetCellsFreeMemory' file='libvirt' module='libvirt'>
      <info><![CDATA[This call returns the amount of free memory in one or more NUMA cells.
The @freeMems array must be allocated by the caller and will be filled
with the amount of free memory in bytes for each cell requested,
starting with startCell (in freeMems[0]), up to either
(startCell + maxCells), or the number of additional cells in the node,
whichever is smaller.]]></info>
      <return type='int' info='the number of entries filled in freeMems, or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='freeMems' type='unsigned long long *' info='pointer to the array of unsigned long long'/>
      <arg name='startCell' type='int' info='index of first cell to return freeMems info on.'/>
      <arg name='maxCells' type='int' info='Maximum number of cells for which freeMems information can be returned.'/>
    </function>
    <function name='virNodeGetFreeMemory' file='libvirt' module='libvirt'>
      <info><![CDATA[provides the free memory available on the Node
Note: most libvirt APIs provide memory sizes in kilobytes, but in this
function the returned value is in bytes. Divide by 1024 as necessary.]]></info>
      <return type='unsigned long long' info='the available free memory in bytes or 0 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virNodeGetInfo' file='libvirt' module='libvirt'>
      <info><![CDATA[Extract hardware information about the node.]]></info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='info' type='virNodeInfoPtr' info='pointer to a virNodeInfo structure allocated by the user'/>
    </function>
    <function name='virNodeGetSecurityModel' file='libvirt' module='libvirt'>
      <info><![CDATA[Extract the security model of a hypervisor. The 'model' field
in the @secmodel argument may be initialized to the empty
string if the driver has not activated a security model.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='a connection object'/>
      <arg name='secmodel' type='virSecurityModelPtr' info='pointer to a virSecurityModel structure'/>
    </function>
    <function name='virNodeListDevices' file='libvirt' module='libvirt'>
      <info><![CDATA[Collect the list of node devices, and store their names in @names

If the optional 'cap'  argument is non-NULL, then the count
will be restricted to devices with the specified capability]]></info>
      <return type='int' info='the number of node devices found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='cap' type='const char *' info='capability name'/>
      <arg name='names' type='char ** const' info='array to collect the list of node device names'/>
      <arg name='maxnames' type='int' info='size of @names'/>
      <arg name='flags' type='unsigned int' info='flags (unused, pass 0)'/>
    </function>
    <function name='virNodeNumOfDevices' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the number of node devices.

If the optional 'cap'  argument is non-NULL, then the count
will be restricted to devices with the specified capability]]></info>
      <return type='int' info='the number of node devices or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='cap' type='const char *' info='capability name'/>
      <arg name='flags' type='unsigned int' info='flags (unused, pass 0)'/>
    </function>
    <function name='virResetError' file='virterror' module='virterror'>
      <info><![CDATA[Reset the error being pointed to]]></info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='pointer to the virError to clean up'/>
    </function>
    <function name='virResetLastError' file='virterror' module='virterror'>
      <info><![CDATA[Reset the last error caught at the library level.

The error object is kept in thread local storage, so separate
threads can safely access this concurrently, only resetting
their own error object.]]></info>
      <return type='void'/>
    </function>
    <function name='virSaveLastError' file='virterror' module='virterror'>
      <info><![CDATA[Save the last error into a new error object.]]></info>
      <return type='virErrorPtr' info='a pointer to the copied error or NULL if allocation failed. It is the caller&apos;s responsibility to free the error with virFreeError().'/>
    </function>
    <function name='virSecretDefineXML' file='libvirt' module='libvirt'>
      <info><![CDATA[If XML specifies a UUID, locates the specified secret and replaces all
attributes of the secret specified by UUID by attributes specified in xml
(any attributes not specified in xml are discarded).

Otherwise, creates a new secret with an automatically chosen UUID, and
initializes its attributes from xml.]]></info>
      <return type='virSecretPtr' info='a the secret on success, NULL on failure.'/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='xml' type='const char *' info='XML describing the secret.'/>
      <arg name='flags' type='unsigned int' info='flags, use 0 for now'/>
    </function>
    <function name='virSecretFree' file='libvirt' module='libvirt'>
      <info><![CDATA[Release the secret handle. The underlying secret continues to exist.]]></info>
      <return type='int' info='0 on success, or -1 on error'/>
      <arg name='secret' type='virSecretPtr' info='pointer to a secret'/>
    </function>
    <function name='virSecretGetConnect' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the connection pointer associated with a secret.  The reference
counter on the connection is not increased by this call.

WARNING: When writing libvirt bindings in other languages, do not use this
function.  Instead, store the connection and the secret object together.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret secret'/>
    </function>
    <function name='virSecretGetUUID' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetches the UUID of the secret.]]></info>
      <return type='int' info='0 on success with the uuid buffer being filled, or -1 upon failure.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret secret'/>
      <arg name='uuid' type='unsigned char *' info='buffer of VIR_UUID_BUFLEN bytes in size'/>
    </function>
    <function name='virSecretGetUUIDString' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the UUID for a secret as string. For more information about
UUID see RFC4122.]]></info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='secret' type='virSecretPtr' info='a secret object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virSecretGetUsageID' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the unique identifier of the object with which this
secret is to be used. The format of the identifier is
dependant on the usage type of the secret. For a secret
with a usage type of VIR_SECRET_USAGE_TYPE_VOLUME the
identifier will be a fully qualfied path name. The
identifiers are intended to be unique within the set of
all secrets sharing the same usage type. ie, there shall
only ever be one secret for each volume path.]]></info>
      <return type='const char *' info='a string identifying the object using the secret, or NULL upon error'/>
      <arg name='secret' type='virSecretPtr' info='a secret object'/>
    </function>
    <function name='virSecretGetUsageType' file='libvirt' module='libvirt'>
      <info><![CDATA[Get the type of object which uses this secret. The returned
value is one of the constants defined in the virSecretUsageType
enumeration. More values may be added to this enumeration in
the future, so callers should expect to see usage types they
do not explicitly know about.]]></info>
      <return type='int' info='a positive integer identifying the type of object, or -1 upon error.'/>
      <arg name='secret' type='virSecretPtr' info='a secret object'/>
    </function>
    <function name='virSecretGetValue' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetches the value of a secret.]]></info>
      <return type='unsigned char *' info='the secret value on success, NULL on failure.  The caller must free() the secret value.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret connection'/>
      <arg name='value_size' type='size_t *' info='Place for storing size of the secret value'/>
      <arg name='flags' type='unsigned int' info='flags, use 0 for now'/>
    </function>
    <function name='virSecretGetXMLDesc' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetches an XML document describing attributes of the secret.]]></info>
      <return type='char *' info='the XML document on success, NULL on failure.  The caller must free() the XML.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret secret'/>
      <arg name='flags' type='unsigned int' info='flags, use 0 for now'/>
    </function>
    <function name='virSecretLookupByUUID' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a secret on the given hypervisor based on its UUID.
Uses the 16 bytes of raw data to describe the UUID]]></info>
      <return type='virSecretPtr' info='a new secret object or NULL in case of failure.  If the secret cannot be found, then VIR_ERR_NO_SECRET error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the secret'/>
    </function>
    <function name='virSecretLookupByUUIDString' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a secret on the given hypervisor based on its UUID.
Uses the printable string value to describe the UUID]]></info>
      <return type='virSecretPtr' info='a new secret object or NULL in case of failure.  If the secret cannot be found, then VIR_ERR_NO_SECRET error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the secret'/>
    </function>
    <function name='virSecretLookupByUsage' file='libvirt' module='libvirt'>
      <info><![CDATA[Try to lookup a secret on the given hypervisor based on its usage
The usageID is unique within the set of secrets sharing the
same usageType value.]]></info>
      <return type='virSecretPtr' info='a new secret object or NULL in case of failure.  If the secret cannot be found, then VIR_ERR_NO_SECRET error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='usageType' type='int' info='the type of secret usage'/>
      <arg name='usageID' type='const char *' info='identifier of the object using the secret'/>
    </function>
    <function name='virSecretRef' file='libvirt' module='libvirt'>
      <info><![CDATA[Increment the reference count on the secret. For each additional call to
this method, there shall be a corresponding call to virSecretFree to release
the reference count, once the caller no longer needs the reference to this
object.

This method is typically useful for applications where multiple threads are
using a connection, and it is required that the connection remain open until
all threads have finished using it. ie, each new thread using a secret would
increment the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='secret' type='virSecretPtr' info='the secret to hold a reference on'/>
    </function>
    <function name='virSecretSetValue' file='libvirt' module='libvirt'>
      <info><![CDATA[Sets the value of a secret.]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret secret'/>
      <arg name='value' type='const unsigned char *' info='Value of the secret'/>
      <arg name='value_size' type='size_t' info='Size of the value'/>
      <arg name='flags' type='unsigned int' info='flags, use 0 for now'/>
    </function>
    <function name='virSecretUndefine' file='libvirt' module='libvirt'>
      <info><![CDATA[Deletes the specified secret.  This does not free the associated
virSecretPtr object.]]></info>
      <return type='int' info='0 on success, -1 on failure.'/>
      <arg name='secret' type='virSecretPtr' info='A virSecret secret'/>
    </function>
    <function name='virSetErrorFunc' file='virterror' module='virterror'>
      <info><![CDATA[Set a library global error handling function, if @handler is NULL,
it will reset to default printing on stderr. The error raised there
are those for which no handler at the connection level could caught.]]></info>
      <return type='void'/>
      <arg name='userData' type='void *' info='pointer to the user data provided in the handler callback'/>
      <arg name='handler' type='virErrorFunc' info='the function to get called in case of error or NULL'/>
    </function>
    <function name='virStoragePoolBuild' file='libvirt' module='libvirt'>
      <info><![CDATA[Build the underlying storage pool]]></info>
      <return type='int' info='0 on success, or -1 upon failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStoragePoolCreate' file='libvirt' module='libvirt'>
      <info><![CDATA[Starts an inactive storage pool]]></info>
      <return type='int' info='0 on success, or -1 if it could not be started'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStoragePoolCreateXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Create a new storage based on its XML description. The
pool is not persistent, so its definition will disappear
when it is destroyed, or if the host is restarted]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if creation failed'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='XML description for new pool'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStoragePoolDefineXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Define a new inactive storage pool based on its XML description. The
pool is persistent, until explicitly undefined.]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if creation failed'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='xml' type='const char *' info='XML description for new pool'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStoragePoolDelete' file='libvirt' module='libvirt'>
      <info><![CDATA[Delete the underlying pool resources. This is
a non-recoverable operation. The virStoragePoolPtr object
itself is not free'd.]]></info>
      <return type='int' info='0 on success, or -1 if it could not be obliterate'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='flags for obliteration process'/>
    </function>
    <function name='virStoragePoolDestroy' file='libvirt' module='libvirt'>
      <info><![CDATA[Destroy an active storage pool. This will deactivate the
pool on the host, but keep any persistent config associated
with it. If it has a persistent config it can later be
restarted with virStoragePoolCreate(). This does not free
the associated virStoragePoolPtr object.]]></info>
      <return type='int' info='0 on success, or -1 if it could not be destroyed'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolFree' file='libvirt' module='libvirt'>
      <info><![CDATA[Free a storage pool object, releasing all memory associated with
it. Does not change the state of the pool on the host.]]></info>
      <return type='int' info='0 on success, or -1 if it could not be free&apos;d.'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolGetAutostart' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetches the value of the autostart flag, which determines
whether the pool is automatically started at boot time]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='autostart' type='int *' info='location in which to store autostart flag'/>
    </function>
    <function name='virStoragePoolGetConnect' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the connection pointer associated with a storage pool.  The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function.  Instead, store the connection and
the pool object together.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to a pool'/>
    </function>
    <function name='virStoragePoolGetInfo' file='libvirt' module='libvirt'>
      <info><![CDATA[Get volatile information about the storage pool
such as free space / usage summary]]></info>
      <return type='int' info='0 on success, or -1 on failure.'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='info' type='virStoragePoolInfoPtr' info='pointer at which to store info'/>
    </function>
    <function name='virStoragePoolGetName' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch the locally unique name of the storage pool]]></info>
      <return type='const char *' info='the name of the pool, or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolGetUUID' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch the globally unique ID of the storage pool]]></info>
      <return type='int' info='0 on success, or -1 on error;'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='uuid' type='unsigned char *' info='buffer of VIR_UUID_BUFLEN bytes in size'/>
    </function>
    <function name='virStoragePoolGetUUIDString' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch the globally unique ID of the storage pool as a string]]></info>
      <return type='int' info='0 on success, or -1 on error;'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='buf' type='char *' info='buffer of VIR_UUID_STRING_BUFLEN bytes in size'/>
    </function>
    <function name='virStoragePoolGetXMLDesc' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch an XML document describing all aspects of the
storage pool. This is suitable for later feeding back
into the virStoragePoolCreateXML method.]]></info>
      <return type='char *' info='a XML document, or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='flags for XML format options (set of virDomainXMLFlags)'/>
    </function>
    <function name='virStoragePoolIsActive' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the storage pool is currently running]]></info>
      <return type='int' info='1 if running, 0 if inactive, -1 on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to the storage pool object'/>
    </function>
    <function name='virStoragePoolIsPersistent' file='libvirt' module='libvirt'>
      <info><![CDATA[Determine if the storage pool has a persistent configuration
which means it will still exist after shutting down]]></info>
      <return type='int' info='1 if persistent, 0 if transient, -1 on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to the storage pool object'/>
    </function>
    <function name='virStoragePoolListVolumes' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch list of storage volume names, limiting to
at most maxnames.]]></info>
      <return type='int' info='the number of names fetched, or -1 on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='names' type='char ** const' info='array in which to storage volume names'/>
      <arg name='maxnames' type='int' info='size of names array'/>
    </function>
    <function name='virStoragePoolLookupByName' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch a storage pool based on its unique name]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='name' type='const char *' info='name of pool to fetch'/>
    </function>
    <function name='virStoragePoolLookupByUUID' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch a storage pool based on its globally unique id]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='globally unique id of pool to fetch'/>
    </function>
    <function name='virStoragePoolLookupByUUIDString' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch a storage pool based on its globally unique id]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='globally unique id of pool to fetch'/>
    </function>
    <function name='virStoragePoolLookupByVolume' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch a storage pool which contains a particular volume]]></info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStoragePoolNumOfVolumes' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch the number of storage volumes within a pool]]></info>
      <return type='int' info='the number of storage pools, or -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolRef' file='libvirt' module='libvirt'>
      <info><![CDATA[Increment the reference count on the pool. For each
additional call to this method, there shall be a corresponding
call to virStoragePoolFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a pool would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='pool' type='virStoragePoolPtr' info='the pool to hold a reference on'/>
    </function>
    <function name='virStoragePoolRefresh' file='libvirt' module='libvirt'>
      <info><![CDATA[Request that the pool refresh its list of volumes. This may
involve communicating with a remote server, and/or initializing
new devices at the OS layer]]></info>
      <return type='int' info='0 if the volume list was refreshed, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='flags to control refresh behaviour (currently unused, use 0)'/>
    </function>
    <function name='virStoragePoolSetAutostart' file='libvirt' module='libvirt'>
      <info><![CDATA[Sets the autostart flag]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='autostart' type='int' info='new flag setting'/>
    </function>
    <function name='virStoragePoolUndefine' file='libvirt' module='libvirt'>
      <info><![CDATA[Undefine an inactive storage pool]]></info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStorageVolCreateXML' file='libvirt' module='libvirt'>
      <info><![CDATA[Create a storage volume within a pool based
on an XML description. Not all pools support
creation of volumes]]></info>
      <return type='virStorageVolPtr' info='the storage volume, or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='xmldesc' type='const char *' info='description of volume to create'/>
      <arg name='flags' type='unsigned int' info='flags for creation (unused, pass 0)'/>
    </function>
    <function name='virStorageVolCreateXMLFrom' file='libvirt' module='libvirt'>
      <info><![CDATA[Create a storage volume in the parent pool, using the
'clonevol' volume as input. Information for the new
volume (name, perms)  are passed via a typical volume
XML description.]]></info>
      <return type='virStorageVolPtr' info='the storage volume, or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to parent pool for the new volume'/>
      <arg name='xmldesc' type='const char *' info='description of volume to create'/>
      <arg name='clonevol' type='virStorageVolPtr' info='storage volume to use as input'/>
      <arg name='flags' type='unsigned int' info='flags for creation (unused, pass 0)'/>
    </function>
    <function name='virStorageVolDelete' file='libvirt' module='libvirt'>
      <info><![CDATA[Delete the storage volume from the pool]]></info>
      <return type='int' info='0 on success, or -1 on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStorageVolFree' file='libvirt' module='libvirt'>
      <info><![CDATA[Release the storage volume handle. The underlying
storage volume continues to exist.]]></info>
      <return type='int' info='0 on success, or -1 on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetConnect' file='libvirt' module='libvirt'>
      <info><![CDATA[Provides the connection pointer associated with a storage volume.  The
reference counter on the connection is not increased by this
call.

WARNING: When writing libvirt bindings in other languages, do
not use this function.  Instead, store the connection and
the volume object together.]]></info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to a pool'/>
    </function>
    <function name='virStorageVolGetInfo' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetches volatile information about the storage
volume such as its current allocation]]></info>
      <return type='int' info='0 on success, or -1 on failure'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='info' type='virStorageVolInfoPtr' info='pointer at which to store info'/>
    </function>
    <function name='virStorageVolGetKey' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch the storage volume key. This is globally
unique, so the same volume will have the same
key no matter what host it is accessed from]]></info>
      <return type='const char *' info='the volume key, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetName' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch the storage volume name. This is unique
within the scope of a pool]]></info>
      <return type='const char *' info='the volume name, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetPath' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch the storage volume path. Depending on the pool
configuration this is either persistent across hosts,
or dynamically assigned at pool startup. Consult
pool documentation for information on getting the
persistent naming]]></info>
      <return type='char *' info='the storage volume path, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetXMLDesc' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch an XML document describing all aspects of
the storage volume]]></info>
      <return type='char *' info='the XML document, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='flags' type='unsigned int' info='flags for XML generation (unused, pass 0)'/>
    </function>
    <function name='virStorageVolLookupByKey' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch a pointer to a storage volume based on its
globally unique key]]></info>
      <return type='virStorageVolPtr' info='a storage volume, or NULL if not found / error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='key' type='const char *' info='globally unique key'/>
    </function>
    <function name='virStorageVolLookupByName' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch a pointer to a storage volume based on its name
within a pool]]></info>
      <return type='virStorageVolPtr' info='a storage volume, or NULL if not found / error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='name' type='const char *' info='name of storage volume'/>
    </function>
    <function name='virStorageVolLookupByPath' file='libvirt' module='libvirt'>
      <info><![CDATA[Fetch a pointer to a storage volume based on its
locally (host) unique path]]></info>
      <return type='virStorageVolPtr' info='a storage volume, or NULL if not found / error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='path' type='const char *' info='locally unique path'/>
    </function>
    <function name='virStorageVolRef' file='libvirt' module='libvirt'>
      <info><![CDATA[Increment the reference count on the vol. For each
additional call to this method, there shall be a corresponding
call to virStorageVolFree to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a vol would increment
the reference count.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='vol' type='virStorageVolPtr' info='the vol to hold a reference on'/>
    </function>
    <function name='virStorageVolWipe' file='libvirt' module='libvirt'>
      <info><![CDATA[Ensure data previously on a volume is not accessible to future reads]]></info>
      <return type='int' info='0 on success, or -1 on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStreamAbort' file='libvirt' module='libvirt'>
      <info><![CDATA[Request that the in progress data transfer be cancelled
abnormally before the end of the stream has been reached.
For output streams this can be used to inform the driver
that the stream is being terminated early. For input
streams this can be used to inform the driver that it
should stop sending data.]]></info>
      <return type='int' info='0 on success, -1 upon error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
    </function>
    <function name='virStreamEventAddCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[Register a callback to be notified when a stream
becomes writable, or readable. This is most commonly
used in conjunction with non-blocking data streams
to integrate into an event loop]]></info>
      <return type='int' info='0 on success, -1 upon error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='events' type='int' info='set of events to monitor'/>
      <arg name='cb' type='virStreamEventCallback' info='callback to invoke when an event occurs'/>
      <arg name='opaque' type='void *' info='application defined data'/>
      <arg name='ff' type='virFreeCallback' info='callback to free @opaque data'/>
    </function>
    <functype name='virStreamEventCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[Callback for receiving stream events. The callback will
be invoked once for each event which is pending.]]></info>
      <return type='void'/>
      <arg name='stream' type='virStreamPtr' info='stream on which the event occurred'/>
      <arg name='events' type='int' info='bitset of events from virEventHandleType constants'/>
      <arg name='opaque' type='void *' info='user data registered with handle'/>
    </functype>
    <function name='virStreamEventRemoveCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[Remove an event callback from the stream]]></info>
      <return type='int' info='0 on success, -1 on error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
    </function>
    <function name='virStreamEventUpdateCallback' file='libvirt' module='libvirt'>
      <info><![CDATA[Changes the set of events to monitor for a stream. This allows
for event notification to be changed without having to
unregister & register the callback completely. This method
is guarenteed to succeed if a callback is already registered]]></info>
      <return type='int' info='0 on success, -1 if no callback is registered'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='events' type='int' info='set of events to monitor'/>
    </function>
    <function name='virStreamFinish' file='libvirt' module='libvirt'>
      <info><![CDATA[Indicate that there is no further data is to be transmitted
on the stream. For output streams this should be called once
all data has been written. For input streams this should be
called once virStreamRecv returns end-of-file.

This method is a synchronization point for all asynchronous
errors, so if this returns a success code the application can
be sure that all data has been successfully processed.]]></info>
      <return type='int' info='0 on success, -1 upon error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
    </function>
    <function name='virStreamFree' file='libvirt' module='libvirt'>
      <info><![CDATA[Decrement the reference count on a stream, releasing
the stream object if the reference count has hit zero.

There must not be an active data transfer in progress
when releasing the stream. If a stream needs to be
disposed of prior to end of stream being reached, then
the virStreamAbort function should be called first.]]></info>
      <return type='int' info='0 upon success, or -1 on error'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
    </function>
    <function name='virStreamNew' file='libvirt' module='libvirt'>
      <info><![CDATA[Creates a new stream object which can be used to perform
streamed I/O with other public API function.

When no longer needed, a stream object must be released
with virStreamFree. If a data stream has been used,
then the application must call virStreamFinish or
virStreamAbort before free'ing to, in order to notify
the driver of termination.

If a non-blocking data stream is required passed
VIR_STREAM_NONBLOCK for flags, otherwise pass 0.]]></info>
      <return type='virStreamPtr' info='the new stream, or NULL upon error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='flags' type='unsigned int' info='control features of the stream'/>
    </function>
    <function name='virStreamRecv' file='libvirt' module='libvirt'>
      <info><![CDATA[Write a series of bytes to the stream. This method may
block the calling application for an arbitrary amount
of time.

Errors are not guaranteed to be reported synchronously
with the call, but may instead be delayed until a
subsequent call.

An example using this with a hypothetical file download
API looks like

  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_WRONLY, 0600)

  virConnectDownloadFile(conn, "demo.iso", st);

  while (1) {
      char buf[1024];
      int got = virStreamRecv(st, buf, 1024);
      if (got < 0)
         break;
      if (got == 0) {
         virStreamFinish(st);
         break;
      }
      int offset = 0;
      while (offset < got) {
         int sent = write(fd, buf+offset, got-offset)
         if (sent < 0) {
            virStreamAbort(st);
            goto done;
         }
         offset += sent;
      }
  }
  if (virStreamFinish(st) < 0)
     ... report an error ....
done:
  virStreamFree(st);
  close(fd);]]></info>
      <return type='int' info='the number of bytes read, which may be less than requested.  Returns 0 when the end of the stream is reached, at which time the caller should invoke virStreamFinish() to get confirmation of stream completion.  Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree.  Returns -2 if there is no data pending to be read &amp; the stream is marked as non-blocking.'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='data' type='char *' info='buffer to write to stream'/>
      <arg name='nbytes' type='size_t' info='size of @data buffer'/>
    </function>
    <function name='virStreamRecvAll' file='libvirt' module='libvirt'>
      <info><![CDATA[Receive the entire data stream, sending the data to the
requested data sink. This is simply a convenient alternative
to virStreamRecv, for apps that do blocking-I/o.

An example using this with a hypothetical file download
API looks like

  int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {
      int *fd = opaque;

      return write(*fd, buf, nbytes);
  }

  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_WRONLY)

  virConnectUploadFile(conn, st);
  if (virStreamRecvAll(st, mysink, &fd) < 0) {
     ...report an error ...
     goto done;
  }
  if (virStreamFinish(st) < 0)
     ...report an error...
  virStreamFree(st);
  close(fd);]]></info>
      <return type='int' info='0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree  Returns -1 upon any error, with virStreamAbort() already having been called,  so the caller need only call virStreamFree()'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='handler' type='virStreamSinkFunc' info='sink callback for writing data to application'/>
      <arg name='opaque' type='void *' info='application defined data'/>
    </function>
    <function name='virStreamRef' file='libvirt' module='libvirt'>
      <info><![CDATA[Increment the reference count on the stream. For each
additional call to this method, there shall be a corresponding
call to virStreamFree to release the reference count, once
the caller no longer needs the reference to this object.]]></info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream'/>
    </function>
    <function name='virStreamSend' file='libvirt' module='libvirt'>
      <info><![CDATA[Write a series of bytes to the stream. This method may
block the calling application for an arbitrary amount
of time. Once an application has finished sending data
it should call virStreamFinish to wait for successful
confirmation from the driver, or detect any error

This method may not be used if a stream source has been
registered

Errors are not guaranteed to be reported synchronously
with the call, but may instead be delayed until a
subsequent call.

An example using this with a hypothetical file upload
API looks like

  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_RDONLY)

  virConnectUploadFile(conn, "demo.iso", st);

  while (1) {
      char buf[1024];
      int got = read(fd, buf, 1024);
      if (got < 0) {
         virStreamAbort(st);
         break;
      }
      if (got == 0) {
         virStreamFinish(st);
         break;
      }
      int offset = 0;
      while (offset < got) {
         int sent = virStreamSend(st, buf+offset, got-offset)
         if (sent < 0) {
            virStreamAbort(st);
            goto done;
         }
         offset += sent;
      }
  }
  if (virStreamFinish(st) < 0)
     ... report an error ....
done:
  virStreamFree(st);
  close(fd);]]></info>
      <return type='int' info='the number of bytes written, which may be less than requested.  Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree.  Returns -2 if the outgoing transmit buffers are full &amp; the stream is marked as non-blocking.'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='data' type='const char *' info='buffer to write to stream'/>
      <arg name='nbytes' type='size_t' info='size of @data buffer'/>
    </function>
    <function name='virStreamSendAll' file='libvirt' module='libvirt'>
      <info><![CDATA[Send the entire data stream, reading the data from the
requested data source. This is simply a convenient alternative
to virStreamSend, for apps that do blocking-I/o.

An example using this with a hypothetical file upload
API looks like

  int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {
      int *fd = opaque;

      return read(*fd, buf, nbytes);
  }

  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_RDONLY)

  virConnectUploadFile(conn, st);
  if (virStreamSendAll(st, mysource, &fd) < 0) {
     ...report an error ...
     goto done;
  }
  if (virStreamFinish(st) < 0)
     ...report an error...
  virStreamFree(st);
  close(fd);]]></info>
      <return type='int' info='0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree  Returns -1 upon any error, with virStreamAbort() already having been called,  so the caller need only call virStreamFree()'/>
      <arg name='stream' type='virStreamPtr' info='pointer to the stream object'/>
      <arg name='handler' type='virStreamSourceFunc' info='source callback for reading data from application'/>
      <arg name='opaque' type='void *' info='application defined data'/>
    </function>
    <functype name='virStreamSinkFunc' file='libvirt' module='libvirt'>
      <info><![CDATA[The virStreamSinkFunc callback is used together
with the virStreamRecvAll function for libvirt to
provide the data that has been received.

The callback will be invoked multiple times,
providing data in small chunks. The application
should consume up 'nbytes' from the 'data' array
of data and then return the number actual number
of bytes consumed. The callback will continue to be
invoked until it indicates the end of the stream
has been reached. A return value of -1 at any time
will abort the receive operation]]></info>
      <return type='int' info='the number of bytes consumed or -1 upon error'/>
      <arg name='st' type='virStreamPtr' info='the stream object'/>
      <arg name='data' type='const char *' info='preallocated array to be filled with data'/>
      <arg name='nbytes' type='size_t' info='size of the data array'/>
      <arg name='opaque' type='void *' info='optional application provided data'/>
    </functype>
    <functype name='virStreamSourceFunc' file='libvirt' module='libvirt'>
      <info><![CDATA[The virStreamSourceFunc callback is used together
with the virStreamSendAll function for libvirt to
obtain the data that is to be sent.

The callback will be invoked multiple times,
fetching data in small chunks. The application
should fill the 'data' array with upto 'nbytes'
of data and then return the number actual number
of bytes. The callback will continue to be
invoked until it indicates the end of the source
has been reached by returning 0. A return value
of -1 at any time will abort the send operation]]></info>
      <return type='int' info='the number of bytes filled, 0 upon end of file, or -1 upon error'/>
      <arg name='st' type='virStreamPtr' info='the stream object'/>
      <arg name='data' type='char *' info='preallocated array to be filled with data'/>
      <arg name='nbytes' type='size_t' info='size of the data array'/>
      <arg name='opaque' type='void *' info='optional application provided data'/>
    </functype>
  </symbols>
</api>
